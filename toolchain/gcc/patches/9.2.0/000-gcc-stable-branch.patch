akrl (1):
      Backport fix for PR jit/91928

anlauf (1):
      2019-09-05  Harald Anlauf  <anlauf@gmx.de>

avieira (1):
      [arm] Backport -- Fix multilibs for Armv7-R

bergner (1):
      Backport from mainline 	2019-10-08  Tulio Magno Quites Machado Filho  <tuliom@linux.ibm.com>

burnus (7):
      Fortran] PR91586 Fix ICE on invalid code with CLASS
      Fortran] PR91863 - fix call to bind(C) with array descriptor
      Backport Fortran BIND(C) fixes
      Fortran] PR 92208 don't use function-result dummy variable as actual argument
      PR 92208 + PR 92277 – GCC 9 follow-up fix
      Fortran] PR91253 fix continuation-line handling with -pre_include
      PR fortran/92470 Fixes for CFI_address

danglin (9):
      * config/pa/pa.c (pa_trampoline_init): Remove spurious extended 	character.
      * config/pa/lib2funcs.S (__gcc_plt_call): Load branch target to %r21. 	Load PIC register after branch target.  Fix white space. 	* config/pa/milli64.S ($$dyncall): Separate LINUX and non LINUX 	implementations.  Load PIC register after branch target.  Don't 	clobber function pointer when it points to function descriptor. 	Use nullification instead of branch in LINUX implementation.
      * config/pa/pa.c (pa_output_call): Load descriptor address to register 	%r22.  Load function address before global pointer. 	(pa_attr_length_indirect_call): Adjust length of inline versions of 	$$dyncall. 	(pa_output_indirect_call): Remove fast inline version of $$dyncall 	before normal cases.  Update inline $$dyncall sequences to preserve 	function descriptor address in register %r22. 	(TRAMPOLINE_CODE_SIZE): Adjust. 	(pa_asm_trampoline_template): Revise 32-bit trampoline.  Don't assume 	register %r22 contains trampoline address. 	(pa_trampoline_init): Adjust offsets. 	(pa_trampoline_adjust_address): Likewise. 	* config/pa/pa.h (TRAMPOLINE_SIZE): Adjust 32-bit size.
      * config/pa/fptr.c (_dl_read_access_allowed): Change argument to 	unsigned int.  Adjust callers. 	(__canonicalize_funcptr_for_compare): Change plabel type to volatile 	unsigned int *.  Load relocation offset before function pointer. 	Add barrier to ensure ordering.
      * config/pa/pa.c (pa_output_indirect_call): Fix typos in last change.
      * config/abi/post/hppa-linux-gnu/baseline_symbols.txt: Update.
      Backport from mainline 	2019-10-03  John David Anglin  <danglin@gcc.gnu.org>
      Backport from mainline 	2019-10-03  John David Anglin  <danglin@gcc.gnu.org>
      Backport from mainline 	2019-11-07  John David Anglin  <danglin@gcc.gnu.org>

draganm (4):
      Backprot fix for uninitialised use in mips_split_move
      Backport fix for PR target/91769
      Backport fix for PR89245
      Sanitize the constant argument for rotr<mode>3

ebotcazou (11):
      PR rtl-optimization/91347 	* dse.c (scan_insn): Call add_wild_read for non-const/memset tail calls 	before reload if HARD_FRAME_POINTER_IS_ARG_POINTER.
      PR target/91472 	* config/sparc/sparc.c (sparc_cannot_force_const_mem): Return true 	during LRA/reload in PIC mode if the PIC register hasn't been used yet. 	(sparc_pic_register_p): Test reload_in_progress for consistency's sake.
      PR rtl-optimization/89795 	* rtlanal.c (nonzero_bits1) <SUBREG>: Do not propagate results from 	inner REGs to paradoxical SUBREGs if WORD_REGISTER_OPERATIONS is set.
      PR target/91269 	* config/sparc/sparc.h (HARD_REGNO_CALLER_SAVE_MODE): Define.
      * gcc-interface/trans.c (Attribute_to_gnu): Test Can_Use_Internal_Rep 	on the underlying type of the node. 	(Call_to_gnu): Likewise with the type of the prefix.
      * gcc-interface/decl.c (annotate_value) <INTEGER_CST>: Really test the 	sign of the value when deciding to build a NEGATE_EXPR. 	<PLUS_EXPR>: Remove redundant line. 	<BIT_AND_EXPR>: Do the negation here.
      PR ada/91995 	* sem_ch8.adb (Chain_Use_Clause): Remove second argument in calls 	to Defining_Entity. 	* sem_elab.adb (Find_Unit_Entity): Likewise.  Deal with N_Subunit 	here in lieu of in Defining_Entity. 	* sem_spark.adb (Check_Callable_Body): Likewise. 	(Check_Package_Body): Likewise. 	* sem_util.ads (Defining_Entity): Remove 2nd and 3th parameters. 	* sem_util.adb (Defining_Entity): Remove 2nd and 3th parameters, 	and adjust accordingly.  Deal with N_Compilation_Unit.
      PR tree-optimization/92131 	* tree-vrp.c (extract_range_from_plus_minus_expr): If the resulting 	range would be symbolic, drop to varying for any explicit overflow 	in the constant part or if neither range is a singleton.
      PR target/92095 	* config/sparc/sparc-protos.h (output_load_pcrel_sym): Declare. 	* config/sparc/sparc.c (sparc_cannot_force_const_mem): Revert latest  	change. 	(got_helper_needed): New static variable. 	(output_load_pcrel_sym): New function. 	(get_pc_thunk_name): Remove after inlining... 	(load_got_register): ...here.  Rework the initialization of the GOT 	register and of the GOT helper. 	(save_local_or_in_reg_p): Test the REGNO of the GOT register. 	(sparc_file_end): Test got_helper_needed to decide whether the GOT 	helper must be emitted.  Use output_asm_insn instead of fprintf. 	(sparc_init_pic_reg): In PIC mode, always initialize the PIC register 	if optimization is enabled. 	* config/sparc/sparc.md (load_pcrel_sym<P:mode>): Emit the assembly 	by calling output_load_pcrel_sym.
      * gcc.target/sparc/overflow-1.c: Add -fno-pie to the options. 	* gcc.target/sparc/overflow-2.c: Likewise.
      * c-ada-spec.c (get_underlying_decl): Do not look through typedefs. 	(dump_forward_type): Do not generate a declaration for function types. 	(dump_nested_type) <ARRAY_TYPE>: Do not generate a nested declaration 	of the component type if it is declared in another file.

edlinger (3):
      2019-08-16  Bernd Edlinger  <bernd.edlinger@hotmail.de>
      2019-08-16  Bernd Edlinger  <bernd.edlinger@hotmail.de>
      2019-10-02  Bernd Edlinger  <bernd.edlinger@hotmail.de>

emsr (1):
      2019-09-09  Edward Smith-Rowland  <3dw4rd@verizon.net>

gccadmin (94):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

gjl (2):
      * doc/avr-mmcu.texi: Re-generate because config/avr/avr-devices.c 	was changed in r269487.
      Backport from 2019-10-18 trunk r277143. 	PR target/86040 	* config/avr/avr.c (avr_out_lpm): Do not shortcut-return.

guojiufu (2):
      [rs6000] PR70010, avoid no-vsx function to be inlined to vsx function
      Backport from mainline

hubicka (3):
      Backport ggc_trim 	Backport from mainline
      free summary vectors. 	Backport from mainline 	2019-10-24  Jan Hubicka  <hubicka@ucw.cz> 	* symbols-summary.h (fast_function_summary<T *, V>::release, 	fast_call_summary<T *, V>::release): Free m_vector.
      Avoid gimple body modifications while streaming. 	Backport from mainline 	2019-10-11  Jan Hubicka  <hubicka@ucw.cz> 	* gimple-streamer-out.c (output_gimple_stmt): Add explicit function 	parameter. 	* lto-streamer-out.c: Include tree-dfa.h. 	(output_cfg): Do not use cfun. 	(lto_prepare_function_for_streaming): New. 	(output_function): Do not push cfun; do not initialize loop optimizer. 	* lto-streamer.h (lto_prepare_function_for_streaming): Declare. 	* passes.c (ipa_write_summaries): Use it. 	(ipa_write_optimization_summaries): Do not modify bodies. 	* tree-dfa.c (renumber_gimple_stmt_uids): Add function parameter. 	* tree.dfa.h (renumber_gimple_stmt_uids): Update prototype. 	* tree-ssa-dse.c (pass_dse::execute): Update use of 	renumber_gimple_stmt_uids. 	* tree-ssa-math-opts.c (pass_optimize_widening_mul::execute): Likewise.

iains (22):
      Darwin, libsanitizer - remove reference to __cxa_rethrow_primary_exception.
      [Darwin, PPC] Fix fail of cpp/assert4.c
      [Darwin, fixincludes] Backport fix for PR83531
      [c-family] Backport fix for PCH / PR61250.
      [Darwin, opts processing] Fix missing RejectNegative etc.
      [Darwin, specs] Backport fixes for driver handling of PIE options.
      [Darwin] Pick up SDKROOT as the sysroot fallback.
      [Darwin] Update machopic_legitimize_pic_address.
      [Darwin] Amend section for constants with relocations.
      [Darwin, PPC] Check for out of range asm values.
      [Darwin, machopic] Preparatory patches.
      [Darwin, machopic] Fix for 67183
      [Darwin, PPC] Fix PR 65342.
      [Darwin] Use of symbol stubs should depend on the linker in use.
      [Darwin] The need for FDE symbols is dependent on linker used, not OS rev.
      [Darwin, PPC] Move the out of line register save/restore to an endfile.
      [Darwin, PPC] Move the out of line register save/restore to an endfile.
      [Darwin] Some TLC for older Darwin versions.
      [Darwin] Fix Objective-C NeXT ABI version check diagnostics.
      [Darwin, machopic] Back out part of PR71767 fix.
      [testsuite] Make the Wnonnull test independent of system headers.
      [objective-c/c++, testsuite] Fix stubify tests for -fnext-runtime.

ian (3):
      go/internal/gccgoimporter: support embedded field in pointer loop
      PR go/91621     mksysinfo: change test == to test =
      compiler: don't inline integer expressions with named types

iii (2):
      Move jump threading before reload
      S/390: Fix failing RTL check in s390_canonicalize_comparison

jakub (34):
      * BASE-VER: Set to 9.2.1.
      * config/abi/post/aarch64-linux-gnu/baseline_symbols.txt: Update. 	* config/abi/post/s390x-linux-gnu/baseline_symbols.txt: Update.
      PR tree-optimization/91597 	* tree-vrp.c (extract_range_from_binary_expr): Remove unsafe 	BIT_AND_EXPR optimization for pointers, even if both operand 	ranges don't include NULL, the result can be NULL.
      PR target/91704 	* config/i386/avxintrin.h (__v32qs): New typedef. 	* config/i386/avx2intrin.h (_mm256_cmpgt_epi8): Use casts to __v32qs 	instead of __v32qi.
      PR target/87853 	* config/i386/emmintrin.h (_mm_cmpeq_epi8): Use casts to __v16qi 	instead of __v16qs.
      Backported from mainline 	2019-08-02  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-08-09  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-09-02  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-09-01  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-09-01  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-09-02  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-09-06  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-09-07  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-09-11  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-09-11  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-09-27  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-09-27  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-09-29  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-10-01  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-10-04  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-10-05  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-10-17  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-10-17  Jakub Jelinek  <jakub@redhat.com>
      PR c++/92201 	* cp-gimplify.c (cp_gimplify_expr): If gimplify_to_rvalue changes the 	function pointer type, re-add cast to the original one.
      Backported from mainline 	2019-10-21  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-10-22  Tamar Christina  <tamar.christina@arm.com>
      Backported from mainline 	2019-10-22  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-10-27  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-10-29  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2019-11-05  Jakub Jelinek  <jakub@redhat.com>
      PR c++/92384 	* function.c (assign_parm_setup_block, assign_parm_setup_stack): Don't 	copy TYPE_EMPTY_P arguments from data->entry_parm to data->stack_parm 	slot. 	(assign_parms): For TREE_ADDRESSABLE parms with TYPE_EMPTY_P type 	force creation of a unique data.stack_parm slot.

jason (4):
      PR c++/90538 - multiple expansions of capture packs
      PR c++/91378 - ICE with noexcept and auto return type.
      PR c++/88095, CTAD for literal operator templates per P0732
      PR c++/90393 - ICE with throw in ?:

jb (2):
      PR fortran/91414 Improve initialization of PRNG
      PR fortran/91414 Correctly fill master_state from os_seed.

jcmvbkbc (1):
      xtensa: backport fix for PR target/90922

jsm28 (6):
      * zh_CN.po: Update.
      Fix libstdc++ lstat missing return type for Windows target.
      * es.po: Update.
      * es.po: Update.
      * es.po: Update.
      * fi.po: Update.

kargl (34):
      2019-08-01  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-18  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-09-02  Steven G. Kargl  <kargl@gc.gnu.org>
      2019-09-05  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-09-14  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-09-14  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-09-14  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-09-19  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-10-01  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-10-01  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-10-01  Steven G. Kargl  <kargl@gcc.ngu.org>
      2019-10-01  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-10-04  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-10-04  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-10-05  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-10-10  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-10-11  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-10-11  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-10-17  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-10-18  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-10-22  Steven G. Kargl  <kargl@gcc.gnu.org>

kito (2):
      RISC-V: Fix bad insn splits with paradoxical subregs.
      RISC-V: Fix more splitters accidentally calling gen_reg_rtx.

krebbel (6):
      Fix PR88751
      S/390: Add support for z15 as CPU name.
      IBM Z: Use tree_fits_uhwi_p in vector_alignment hook
      IBM Z: Fix testsuite useable_hw check
      IBM Z: gen-vect-11/32: Set min-vect-loop-bound param back to default
      IBM Z: gen-vect-26/28: Vectorizing without peeling is ok for Z

ktkachov (3):
      [arm] Fix use of CRC32 intrinsics with Armv8-a and hard-float
      driver: Also prune joined switches with negation
      [AArch64] Don't split 64-bit constant stores to volatile location

law (1):
      * config/mips/mips.md (mips_get_fcsr, *mips_get_fcsr): Use SI         machine mode for unspec_volatile operand.

luoxhu (1):
      Backport r274411 from trunk to gcc-9-branch

marxin (7):
      Backport r274502
      Backport r274503
      Backport r274504
      Backport r275291
      Backport r275292
      Backport r276141
      Backport r276178

mpolacek (13):
      PR c++/81429 - wrong parsing of constructor with C++11 attribute. 	* parser.c (cp_parser_constructor_declarator_p): Handle the scenario 	when a parameter declaration begins with [[attribute]].
      PR c++/87519 - bogus warning with -Wsign-conversion. 	* typeck.c (cp_build_binary_op): Use same_type_p instead of comparing 	the types directly.
      PR c++/90473 - wrong code with nullptr in default argument. 	* call.c (null_ptr_cst_p): Update quote from the standard. 	* decl.c (check_default_argument): Don't return nullptr when the arg 	has side-effects.
      PR c++/90884 - stray note with -Wctor-dtor-privacy. 	* class.c (maybe_warn_about_overly_private_class): Guard the call to 	inform.
      PR c++/91521 - wrong error with operator->. 	* decl.c (grokdeclarator): Return error_mark_node for an invalid 	trailing return type.
      PR c++/91129 - wrong error with binary op in template argument. 	* typeck.c (warn_for_null_address): Use fold_for_warn instead of 	fold_non_dependent_expr. 	(cp_build_binary_op): Likewise.
      PR c++/91705 - constexpr evaluation rejects ++/-- on floats. 	* constexpr.c (cxx_eval_increment_expression): Call fold_simple on 	the offset.
      PR c++/91923 - failure-to-SFINAE with class type NTTP in C++17. 	* pt.c (invalid_nontype_parm_type_p): Only emit errors when 	tf_error.
      PR c++/91740 - ICE with constexpr call and ?: in ARRAY_REF. 	* pt.c (build_non_dependent_expr): Call build_non_dependent_expr for 	the first operand.
      PR c++/92106 - ICE with structured bindings and -Wreturn-local-addr.
      PR c++/92062 - ODR-use ignored for static member of class template.
      * decl.c (reshape_init_r): Add missing space.
      PR c++/90998 - ICE with copy elision in init by ctor and -Wconversion.

msebor (1):
      Backport from mainline

olegendo (4):
      gcc/ 2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
      gcc/ 2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
      gcc/ 2019-10-01  Oleg Endo  <olegendo@gcc.gnu.org>
      gcc/ 	Backport from mainline 	2019-10-10  Oleg Endo  <olegendo@gcc.gnu.org>

pault (4):
      2019-09-07  Paul Thomas  <pault@gcc.gnu.org>
      2019-09-21  Paul Thomas  <pault@gcc.gnu.org>
      2019-10-27  Paul Thomas  <pault@gcc.gnu.org>
      2019-10-28  Paul Thomas  <pault@gcc.gnu.org>

rearnsha (3):
      [aarch64] PR target/91386 Use copy_rtx to avoid modifying original insns in peep2 pattern
      [arm]  PR target/89400 fix thumb1 unaligned access expansion
      [arm][PR88167] Fix __builtin_return_address returns invalid address

redi (27):
      PR libstdc++/90361 add missing macro definition
      PR c++/91436 fix C++ dialect for std::make_unique fix-it hint
      Implement new serial algorithms from Parallelism TS (P0024R2)
      Fix markdown in Doxygen comments for std::reduce
      Update ABI baselines for x86 and powerpc GNU targets
      PR libstdc++/91067 add more missing exports for directory iterators
      Update libstdc++ docs for library version bumps
      Fix Xmethod for shared_ptr::use_count()
      PR libstdc++/91748 fix std::for_each_n for random access iterators
      PR libstdc++/92059 fix several bugs in tr2::dynamic_bitset
      P1651R0 bind_front should not unwrap reference_wrapper
      Fix array index error in address_v6 comparisons
      Include netinet/in.h in include/experimental/internet
      PR libstdc++/91456 make INVOKE<R> work with uncopyable prvalues
      Update URL for Hoard in libstdc++ docs
      Update URL for CUJ article in libstdc++ docs
      Add makefile target to update HTML files in source tree
      Fix testsuite bugs
      Fix more tests that fail in C++2a mode
      PR libstdc++/92143 adjust for OS X aligned_alloc behaviour
      Do not declare std::uses_allocator before C++11
      PR libstdc++/89164 enforce constraints for uninitialized algos
      Fix indentation in testsuite utility header
      Fix tests that fail with -std=gnu++98 or -std=gnu++11
      Fix more failing tests for C++98 mode
      PR libstdc++/61761 fix std::proj for targets without C99 cproj
      PR libstdc++/90682 allow set_terminate(0) and set_unexpected(0)

rguenth (8):
      2019-08-12  Richard Biener  <rguenther@suse.de>
      2019-08-15  Richard Biener  <rguenther@suse.de>
      2019-08-28  Richard Biener  <rguenther@suse.de>
      2019-08-29  Richard Biener  <rguenther@suse.de>
      2019-08-30  Richard Biener  <rguenther@suse.de>
      2019-10-16  Richard Biener  <rguenther@suse.de>
      2019-10-23  Richard Biener  <rguenther@suse.de>
      2019-11-11  Richard Biener  <rguenther@suse.de>

ro (1):
      Update Solaris baselines for GCC 9.3

segher (5):
      Backport from trunk 	2019-08-22  Segher Boessenkool  <segher@kernel.crashing.org>
      Backport from trunk 	2019-08-22  Segher Boessenkool  <segher@kernel.crashing.org>
      Backport from trunk 	2019-08-23  Segher Boessenkool  <segher@kernel.crashing.org>
      backport for PR91289
      backport "rs6000: Implement [u]avg<mode>3_ceil"

sje (1):
      2019-08-15  Steve Ellcey  <sellcey@marvell.com>

tkoenig (8):
      2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2013-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-09-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-09-18  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-10-07  Thomas Koenig <tkoenig@gcc.gnu.org>
      Commit symbol for external BLAS routine when translating MATMUL to *GEMM.
      Put vtab into RO section, same for __def_init if it contains an initializer.

tschwinge (5):
      Avoid '-Wmaybe-uninitialized' diagnostic in 'gcc/dwarf2out.c'
      [LIBPHOBOS] Fix multi-lib RUNTESTFLAGS handling
      [build] Properly track GCC language configure fragments
      Assert 'offset2' instead of 'offset' in 'gcc/gimplify.c:gimplify_scan_omp_clauses'
      [PR87833] x86: Put -fPIC and -shared the last to create offload image

uros (5):
      * test_summary: Do not escape "=".
      * config/abi/post/alpha-linux-gnu/baseline_symbols.txt: Update.
      PR target/91533 	Backport from mainline 	2019-06-30  Uroš Bizjak  <ubizjak@gmail.com>
      PR target/92022 	* config/alpha/alpha.c (alpha_handle_trap_shadows): Skip DEBUG_INSN.
      PR target/92225 	* config/i386/sse.md (REDUC_SSE_SMINMAX_MODE): Use TARGET_SSE4_2 	condition for V2DImode.

ville (1):
      PR c++/85254

wilco (1):
      [AArch64] Fix PR81800

willschm (1):
      Backport from trunk [gcc]

wschmidt (2):
      [gcc]
      2019-10-17  Bill Schmidt  <wschmidt@linux.ibm.com>

diff --git a/contrib/ChangeLog b/contrib/ChangeLog
index 8565be188d9..c9b9e26ee57 100644
--- a/contrib/ChangeLog
+++ b/contrib/ChangeLog
@@ -1,3 +1,7 @@
+2019-08-16  Uros Bizjak  <ubizjak@gmail.com>
+
+	* test_summary: Do not escape "=".
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/contrib/test_summary b/contrib/test_summary
index 3560a64c4f1..5760b053ec2 100755
--- a/contrib/test_summary
+++ b/contrib/test_summary
@@ -127,7 +127,7 @@ NR == 1 {
   if (lang == "") lang = " "$2" "; else lang = " ";
 }
 $2 == "version" { save = $0; $1 = ""; $2 = ""; version = $0; gsub(/^ */, "", version); gsub(/\r$/, "", version); $0 = save; }
-/\===.*Summary/ { print ""; print; blanks=1; }
+/===.*Summary/ { print ""; print; blanks=1; }
 /tests ===/ || /^(Target|Host|Native)/ || $2 == "version" { print; blanks=1; }
 /^(XPASS|FAIL|UNRESOLVED|WARNING|ERROR|# of )/ { sub ("\r", ""); print; }
 /^using:/ { print ""; print; print ""; }
diff --git a/fixincludes/ChangeLog b/fixincludes/ChangeLog
index 829d91dac87..6f22154630c 100644
--- a/fixincludes/ChangeLog
+++ b/fixincludes/ChangeLog
@@ -1,3 +1,15 @@
+2019-08-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-08-18  C.G. Dogan <gcc+cgdogan.00@gmail.com>
+		    Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/83531
+	* inclhack.def (darwin_api_availability): New; strip leading
+	underscores from API_XXXX defines.
+	* fixincl.x: Regenerate.
+	* tests/base/os/availability.h: New file.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/fixincludes/fixincl.x b/fixincludes/fixincl.x
index 802162bb507..5d297868758 100644
--- a/fixincludes/fixincl.x
+++ b/fixincludes/fixincl.x
@@ -2,11 +2,11 @@
  *
  * DO NOT EDIT THIS FILE   (fixincl.x)
  *
- * It has been AutoGen-ed  July  7, 2019 at 11:43:37 AM by AutoGen 5.17.4
+ * It has been AutoGen-ed  August 21, 2019 at 07:47:23 PM by AutoGen 5.17.4
  * From the definitions    inclhack.def
  * and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Sun Jul  7 11:43:37 BST 2019
+/* DO NOT SVN-MERGE THIS FILE, EITHER Wed Aug 21 19:47:23 BST 2019
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -15,7 +15,7 @@
  * certain ANSI-incompatible system header files which are fixed to work
  * correctly with ANSI C and placed in a directory that GNU C will search.
  *
- * This file contains 255 fixup descriptions.
+ * This file contains 256 fixup descriptions.
  *
  * See README for more information.
  *
@@ -267,6 +267,56 @@ static const char* apzAab_Darwin7_9_Long_Double_FuncsPatch[] = {
 #endif /* __MATH__ */",
     (char*)NULL };
 
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ *  Description of Darwin_Api_Availability fix
+ */
+tSCC zDarwin_Api_AvailabilityName[] =
+     "darwin_api_availability";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Api_AvailabilityList[] =
+  "os/availability.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Api_AvailabilityMachs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Api_AvailabilitySelect0[] =
+       " *#define __API_AVAILABLE.*\n\
+ *#define __API_DEPRECATED.*\n\
+ *#define __API_DEPRECATED_WITH_REPLACEMENT.*\n\
+ *#define __API_UNAVAILABLE.*\n";
+
+/*
+ *  content bypass pattern - skip fix if pattern found
+ */
+tSCC zDarwin_Api_AvailabilityBypass0[] =
+       "__IPHONE_OS_VERSION_MIN_REQUIRED";
+
+#define    DARWIN_API_AVAILABILITY_TEST_CT  2
+static tTestDesc aDarwin_Api_AvailabilityTests[] = {
+  { TT_NEGREP,   zDarwin_Api_AvailabilityBypass0, (regex_t*)NULL },
+  { TT_EGREP,    zDarwin_Api_AvailabilitySelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Api_Availability
+ */
+static const char* apzDarwin_Api_AvailabilityPatch[] = {
+    "format",
+    "    #define API_AVAILABLE(...)\n\
+    #define API_DEPRECATED(...)\n\
+    #define API_DEPRECATED_WITH_REPLACEMENT(...)\n\
+    #define API_UNAVAILABLE(...)\n",
+    (char*)NULL };
+
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
  *  Description of Aab_Fd_Zero_Asm_Posix_Types_H fix
@@ -10346,9 +10396,9 @@ static const char* apzX11_SprintfPatch[] = {
  *
  *  List of all fixes
  */
-#define REGEX_COUNT          293
+#define REGEX_COUNT          295
 #define MACH_LIST_SIZE_LIMIT 187
-#define FIX_COUNT            255
+#define FIX_COUNT            256
 
 /*
  *  Enumerate the fixes
@@ -10357,6 +10407,7 @@ typedef enum {
     AAB_AIX_STDIO_FIXIDX,
     AAB_AIX_FCNTL_FIXIDX,
     AAB_DARWIN7_9_LONG_DOUBLE_FUNCS_FIXIDX,
+    DARWIN_API_AVAILABILITY_FIXIDX,
     AAB_FD_ZERO_ASM_POSIX_TYPES_H_FIXIDX,
     AAB_FD_ZERO_GNU_TYPES_H_FIXIDX,
     AAB_FD_ZERO_SELECTBITS_H_FIXIDX,
@@ -10627,6 +10678,11 @@ tFixDesc fixDescList[ FIX_COUNT ] = {
      AAB_DARWIN7_9_LONG_DOUBLE_FUNCS_TEST_CT, FD_MACH_ONLY | FD_REPLACEMENT,
      aAab_Darwin7_9_Long_Double_FuncsTests,   apzAab_Darwin7_9_Long_Double_FuncsPatch, 0 },
 
+  {  zDarwin_Api_AvailabilityName,    zDarwin_Api_AvailabilityList,
+     apzDarwin_Api_AvailabilityMachs,
+     DARWIN_API_AVAILABILITY_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aDarwin_Api_AvailabilityTests,   apzDarwin_Api_AvailabilityPatch, 0 },
+
   {  zAab_Fd_Zero_Asm_Posix_Types_HName,    zAab_Fd_Zero_Asm_Posix_Types_HList,
      apzAab_Fd_Zero_Asm_Posix_Types_HMachs,
      AAB_FD_ZERO_ASM_POSIX_TYPES_H_TEST_CT, FD_MACH_ONLY | FD_REPLACEMENT,
diff --git a/fixincludes/inclhack.def b/fixincludes/inclhack.def
index 861532c2a1d..3c6b48d26e1 100644
--- a/fixincludes/inclhack.def
+++ b/fixincludes/inclhack.def
@@ -194,6 +194,33 @@ fix = {
 	_EndOfHeader_;
 };
 
+/*
+ *  SDKs for 10.13 and 10.14 omit the definitions for API_AVAILABLE where
+ *  __attribute__((availability)) is not supported.
+ */
+fix = {
+    hackname  = darwin_api_availability;
+    mach      = "*-*-darwin*";
+    files     = os/availability.h;
+    bypass    = "__IPHONE_OS_VERSION_MIN_REQUIRED";
+    select    =
+    " *#define __API_AVAILABLE.*\n"
+    " *#define __API_DEPRECATED.*\n"
+    " *#define __API_DEPRECATED_WITH_REPLACEMENT.*\n"
+    " *#define __API_UNAVAILABLE.*\n";
+    c_fix     = format;
+    c_fix_arg =
+    "    #define API_AVAILABLE(...)\n"
+    "    #define API_DEPRECATED(...)\n"
+    "    #define API_DEPRECATED_WITH_REPLACEMENT(...)\n"
+    "    #define API_UNAVAILABLE(...)\n";
+    test_text =
+    "#define __API_AVAILABLE(...)\n"
+    "#define __API_DEPRECATED(...)\n"
+    "#define __API_DEPRECATED_WITH_REPLACEMENT(...)\n"
+    "#define __API_UNAVAILABLE(...)\n";
+};
+
 /*
  *  This fixes __FD_ZERO bug for linux 2.x.y (x <= 2 && y <= some n)
  */
diff --git a/fixincludes/tests/base/os/availability.h b/fixincludes/tests/base/os/availability.h
new file mode 100644
index 00000000000..e8696b14acd
--- /dev/null
+++ b/fixincludes/tests/base/os/availability.h
@@ -0,0 +1,18 @@
+/*  DO NOT EDIT THIS FILE.
+
+    It has been auto-edited by fixincludes from:
+
+	"fixinc/tests/inc/os/availability.h"
+
+    This had to be done to correct non-standard usages in the
+    original, manufacturer supplied header file.  */
+
+
+
+#if defined( DARWIN_API_AVAILABILITY_CHECK )
+    #define API_AVAILABLE(...)
+    #define API_DEPRECATED(...)
+    #define API_DEPRECATED_WITH_REPLACEMENT(...)
+    #define API_UNAVAILABLE(...)
+
+#endif  /* DARWIN_API_AVAILABILITY_CHECK */
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index deeb3d66ef0..45acc9e6670 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-9.2.0
+9.2.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 7f6557d8018..400e02fae59 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,1280 @@
+2019-11-13  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	Backport from mainline
+	* config/mips/mips.md (rotr<mode>3): Sanitize the constant argument
+	instead of asserting its value.
+
+2019-11-11  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-06-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90930
+	* tree-ssa-reassoc.c (reassociate_bb): Only rewrite expression
+	into parallel form in the last pass instance.
+
+2019-11-11  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backport from trunk:
+	PR target/87833
+	* config/i386/intelmic-mkoffload.c (prepare_target_image): Put
+	-fPIC and -shared the last to create offload image.
+
+2019-11-11  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport from trunk:
+	* gimplify.c (gimplify_scan_omp_clauses): Assert 'offset2' instead
+	of 'offset'.
+
+	Backport from trunk:
+	* Makefile.in (LANG_CONFIGUREFRAGS): Define.
+	(config.status): Use/depend on it.
+	* configure.ac (all_lang_configurefrags): Track, 'AC_SUBST'.
+	* configure: Regenerate.
+
+2019-11-09  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-11-07  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (memory_barrier): Revise to use ldcw barriers.
+	Enhance comment.
+	(memory_barrier_coherent, memory_barrier_64, memory_barrier_32): New
+	insn patterns using ldcw instruction.
+	(memory_barrier): Remove insn pattern using sync instruction.
+	* config/pa/pa.opt (coherent-ldcw): New option.
+	(ordered): New option.
+
+2019-11-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92384
+	* function.c (assign_parm_setup_block, assign_parm_setup_stack): Don't
+	copy TYPE_EMPTY_P arguments from data->entry_parm to data->stack_parm
+	slot.
+	(assign_parms): For TREE_ADDRESSABLE parms with TYPE_EMPTY_P type
+	force creation of a unique data.stack_parm slot.
+
+	Backported from mainline
+	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/92231
+	* tree.h (fndecl_built_in_p): Use fndecl_built_in_p instead of
+	DECL_BUILT_IN in comment.  Remove redundant ()s around return
+	argument.
+	* tree.c (free_lang_data_in_decl): Check if var is FUNCTION_DECL
+	before calling fndecl_built_in_p.
+	* gimple-fold.c (gimple_fold_stmt_to_constant_1): Check if
+	TREE_OPERAND (fn, 0) is a FUNCTION_DECL before calling
+	fndecl_built_in_p on it.
+
+	PR c++/90947
+	* tree.h (type_initializer_zero_p): Remove.
+	* tree.c (type_initializer_zero_p): Remove.
+
+	2019-10-29  Jakub Jelinek  <jakub@redhat.com>
+
+	* doc/install.texi (--enable-offload-targets): Fix up a typo in the
+	example, use actual names of supported offload targets.
+
+2019-11-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/92095
+	* config/sparc/sparc-protos.h (output_load_pcrel_sym): Declare.
+	* config/sparc/sparc.c (sparc_cannot_force_const_mem): Revert latest
+ 	change.
+	(got_helper_needed): New static variable.
+	(output_load_pcrel_sym): New function.
+	(get_pc_thunk_name): Remove after inlining...
+	(load_got_register): ...here.  Rework the initialization of the GOT
+	register and of the GOT helper.
+	(save_local_or_in_reg_p): Test the REGNO of the GOT register.
+	(sparc_file_end): Test got_helper_needed to decide whether the GOT
+	helper must be emitted.  Use output_asm_insn instead of fprintf.
+	(sparc_init_pic_reg): In PIC mode, always initialize the PIC register
+	if optimization is enabled.
+	* config/sparc/sparc.md (load_pcrel_sym<P:mode>): Emit the assembly
+	by calling output_load_pcrel_sym.
+
+2019-11-06  Ilya Leoshkevich  <iii@linux.ibm.com>
+
+	Backport from mainline
+	* config/s390/s390.c (s390_canonicalize_comparison): Use XEXP
+	(*op0, 1) instead of XEXP (*op1, 0).
+
+2019-11-05  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-10-24  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* config/rs6000/altivec.md (altivec_vavgu<VI_char>): Rename to...
+	(uavg<mode>3_ceil): ... This.
+	(altivec_vavgs<VI_char>): Rename to...
+	(avg<mode>3_ceil): ... This.
+	* config/rs6000/rs6000-builtin.def (VAVGUB, VAVGSB, VAVGUH, VAVGSH,
+	VAVGUW, VAVGSW): Adjust.
+
+2019-11-05  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-10-26  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/91289
+	* config/rs6000/rs6000.c (rs6000_emit_allocate_stack): Don't add an
+	immediate to r0; use r11 instead.  Save and restore r11 to r0 around
+	this.
+
+2019-11-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-11-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390.c (s390_vector_alignment): Check if the value
+	fits into uhwi before using it.
+
+2019-11-01  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-10-03  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_output_call): Remove 64-bit sibcall sequence.
+	(pa_attr_length_call): Adjust length for 64-bit plabel sequence.
+
+2019-11-01  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-10-03  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.h (MAX_PCREL17F_OFFSET): Adjust.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirection_name): Rework the
+	function to emit linker-visible symbols only for indirections
+	in the data section.  Clean up the code and update comments.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_override_options): Make the check for
+	Objective-C ABI version more specific for 64bit code.
+
+	Backport from mainline
+	2019-10-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_override_options): Adjust objective-c
+	ABI version error messages to avoid punctuation and contracted
+	negations.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.h (REAL_LIBGCC_SPEC): Adjust for earlier Darwin.
+	(STARTFILE_SPEC): Split crt3 into a separate spec.
+	(DARWIN_EXTRA_SPECS): Add crt2 and crt3 spec.
+	(DARWIN_CRT2_SPEC): New.
+	(DARWIN_CRT3_SPEC): New.
+	(MIN_LD64_OMIT_STUBS): Revise to 62.1.
+	* config/rs6000/darwin.h (DARWIN_CRT2_SPEC): Revise conditions.
+	(DARWIN_CRT3_SPEC): New.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (ENDFILE_SPEC): Correct whitespace in the
+	spec.
+
+	Backport from mainline
+	2019-06-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (ENDFILE_SPEC): New.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_emit_unwind_label): New.
+	(darwin_override_options): Set darwin_emit_unwind_label as needed.
+
+2019-10-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-13 Iain Sandoe <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_call_target): Rename symbol stub
+	flag.
+	(darwin_override_options): Likewise.
+	* config/darwin.h: Likewise.
+	* config/darwin.opt: Likewise.
+	* config/i386/i386.c (output_pic_addr_const): Likewise.
+	* config/rs6000/darwin.h: Likewise.
+	* config/rs6000/rs6000.c (rs6000_call_darwin_1): Likewise.
+	* config/i386/darwin.h (TARGET_MACHO_PICSYM_STUBS): Rename to ...
+	... this TARGET_MACHO_SYMBOL_STUBS.
+	(FUNCTION_PROFILER):Likewise.
+	* config/i386/i386.h: Likewise.
+
+	Backport from mainline
+	2019-06-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_call_target): Use renamed
+	darwin_picsymbol_stubs to decide on output.
+	(darwin_override_options): Handle darwin_picsymbol_stubs.
+	* config/darwin.h (MIN_LD64_OMIT_STUBS): New.
+	(LD64_VERSION): Revise default.
+	* config/darwin.opt: (mpic-symbol-stubs): New option.
+	(darwin_picsymbol_stubs): New variable.
+	* config/i386/darwin.h (TARGET_MACHO_BRANCH_ISLANDS):
+	rename to TARGET_MACHO_PICSYM_STUBS.
+	* config/i386/i386.c (output_pic_addr_const): Likewise.
+	* config/i386/i386.h Likewise.
+	* config/rs6000/darwin.h: Likewise.
+	* config/rs6000/rs6000.c (rs6000_call_darwin_1): Use renamed
+	darwin_picsymbol_stubs.
+
+2019-10-30  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	Backport from mainline
+	2019-07-09  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	* cfgcleanup.c (old_insns_match_p): Check if used hard regs set is equal
+	for both call instructions.
+
+2019-10-30  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport from trunk:
+
+	2019-05-06  Richard Biener  <rguenther@suse.de>
+
+	* dwarf2out.c (mem_loc_descriptor): Initialize int_mode.
+
+2019-10-28  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/92225
+	* config/i386/sse.md (REDUC_SSE_SMINMAX_MODE): Use TARGET_SSE4_2
+	condition for V2DImode.
+
+2019-10-28  Ilya Leoshkevich  <iii@linux.ibm.com>
+
+	Backport from mainline
+	PR rtl-optimization/92007
+	* cfgcleanup.c (thread_jump): Add an assertion that we don't
+	call it after reload if hot/cold partitioning has been done.
+	(class pass_postreload_jump): Rename to
+	pass_jump_after_combine.
+	(make_pass_postreload_jump): Rename to
+	make_pass_jump_after_combine.
+	* passes.def(pass_postreload_jump): Move before reload, rename
+	to pass_jump_after_combine.
+	* tree-pass.h (make_pass_postreload_jump): Rename to
+	make_pass_jump_after_combine.
+
+2019-10-28  Peter Bergner <bergner@linux.ibm.com>
+	    Jiufu Guo  <guojiufu@linux.ibm.com>
+
+	PR target/70010
+	* config/rs6000/rs6000.c (rs6000_can_inline_p): Prohibit inlining if
+	the callee explicitly disables some isa_flags the caller is using.
+
+2019-10-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-17  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/65342
+	* config/rs6000/darwin.md (movdi_low, movsi_low_st): Delete.
+	(movdi_low_st): Delete.
+	* config/rs6000/rs6000.c
+	(darwin_rs6000_legitimate_lo_sum_const_p): New.
+	(mem_operand_gpr): Validate Mach-O LO_SUM cases separately.
+	* config/rs6000/rs6000.md (movsi_low): Delete.
+
+2019-10-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/67183
+	* config/darwin.c (machopic_indirection): New field to flag
+	non-lazy-symbol-pointers in the data section.
+	(machopic_indirection_name): Compute if an indirection should
+	appear in the data section.
+	(machopic_output_data_section_indirection): New callback split
+	from machopic_output_indirection.
+	(machopic_output_stub_indirection): Likewise.
+	(machopic_output_indirection): Retain the code for non-lazy
+	symbol pointers in their regular section.
+	(machopic_finish): Use the new callbacks to order the indirection
+	output.
+
+2019-10-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin-protos.h (machopic_finish): Delete.
+	* config/darwin.c (machopic_finish): Make static.
+
+	Backport from mainline
+	2019-10-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_data_reference): Set flag to
+	indicate that the new symbol is an indirection.
+	(machopic_indirect_call_target): Likewise.
+	* config/darwin.h (MACHO_SYMBOL_FLAG_INDIRECTION): New.
+	(MACHO_SYMBOL_INDIRECTION_P): New.
+	(MACHO_SYMBOL_FLAG_STATIC): Adjust bit number.
+
+	Backport from mainline
+	2019-10-08  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_data_reference): Check for
+	required indirections before making direct access to defined
+	values.
+	(machopic_output_indirection): Place the indirected pointes for
+	required indirections into the non-lazy symbol pointers section.
+	(darwin_encode_section_info):
+	* config/darwin.h (MACHO_SYMBOL_FLAG_MUST_INDIRECT): New.
+	(MACHO_SYMBOL_MUST_INDIRECT_P): New.
+
+	Backport from mainline
+	2019-10-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_output_indirection): Don't put
+	hidden symbol indirections into the .data section, use the
+	non-lazy symbol pointers section as normal.
+	(darwin_encode_section_info): Record if a symbol is hidden.
+	* config/darwin.h (MACHO_SYMBOL_FLAG_HIDDEN_VIS): New.
+	(MACHO_SYMBOL_HIDDEN_VIS_P): New.
+
+	Backport from mainline
+	2019-10-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_symbol_defined_p): Use symbol flag
+	predicates instead of accessing bits directly.
+	(machopic_indirect_call_target): Likewise.
+	(machopic_output_indirection): Likewise.
+	(darwin_encode_section_info): Improve description.  Use renamed
+	symbol flags.  Use predicate macros for variables and functions.
+	* config/darwin.h:
+	Rename MACHO_SYMBOL_VARIABLE to MACHO_SYMBOL_FLAG_VARIABLE.
+	Rename MACHO_SYMBOL_DEFINED to MACHO_SYMBOL_FLAG_DEFINED.
+	Rename MACHO_SYMBOL_STATIC to MACHO_SYMBOL_FLAG_STATIC.
+	(MACHO_SYMBOL_VARIABLE_P): New.
+	(MACHO_SYMBOL_DEFINED_P):New.
+	(MACHO_SYMBOL_STATIC_P): New.
+	* config/i386/darwin.h (MACHO_SYMBOL_FLAG_VARIABLE): Delete.
+	(SYMBOL_FLAG_SUBT_DEP): New.
+	* config/rs6000/darwin.h (SYMBOL_FLAG_SUBT_DEP): New.
+
+2019-10-25  Jan Hubicka  <hubicka@ucw.cz>
+
+	Backport from mainline
+	2019-10-11  Jan Hubicka  <hubicka@ucw.cz>
+	* gimple-streamer-out.c (output_gimple_stmt): Add explicit function
+	parameter.
+	* lto-streamer-out.c: Include tree-dfa.h.
+	(output_cfg): Do not use cfun.
+	(lto_prepare_function_for_streaming): New.
+	(output_function): Do not push cfun; do not initialize loop optimizer.
+	* lto-streamer.h (lto_prepare_function_for_streaming): Declare.
+	* passes.c (ipa_write_summaries): Use it.
+	(ipa_write_optimization_summaries): Do not modify bodies.
+	* tree-dfa.c (renumber_gimple_stmt_uids): Add function parameter.
+	* tree.dfa.h (renumber_gimple_stmt_uids): Update prototype.
+	* tree-ssa-dse.c (pass_dse::execute): Update use of
+	renumber_gimple_stmt_uids.
+	* tree-ssa-math-opts.c (pass_optimize_widening_mul::execute): Likewise.
+
+	2019-10-12  Jan Hubicka  <hubicka@ucw.cz>
+	* lto-streamer-out.c (collect_block_tree_leafs): Renumber statements
+	so non-virutal are before virutals.
+	(output_function): Avoid body modifications.
+
+2019-10-25  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-05-08  Mihail Ionescu  <mihail.ionescu@arm.com>
+	    Richard Earnshaw  <rearnsha@arm.com>
+	PR target/88167
+	* config/arm/arm.c (thumb1_prologue_unused_call_clobbered_lo_regs): New
+	function.
+	(thumb1_epilogue_unused_call_clobbered_lo_regs): New function.
+	(thumb1_compute_save_core_reg_mask): Don't force a spare work
+	register if both the epilogue and prologue can use call-clobbered
+	regs.
+	(thumb1_unexpanded_epilogue): Use
+	thumb1_epilogue_unused_call_clobbered_lo_regs.  Reverse the logic for
+	picking temporaries for restoring high regs to match that of the
+	prologue where possible.
+	(thumb1_expand_prologue): Add any usable call-clobbered low registers to
+	the list of work registers.  Detect if the return address is still live
+	at the end of the prologue and avoid using it for a work register if so.
+	If the return address is not live, add LR to the list of pushable regs
+	after the first pass.
+
+2019-10-25  Jan Hubicka  <hubicka@ucw.cz>
+
+	Backport from mainline
+	2019-10-24  Jan Hubicka  <hubicka@ucw.cz>
+	* symbols-summary.h (fast_function_summary<T *, V>::release,
+	fast_call_summary<T *, V>::release): Free m_vector.
+
+2019-10-25  Jan Hubicka  <hubicka@ucw.cz>
+
+	Backport from mainline
+
+	2019-10-18  Jakub Jelinek  <jakub@redhat.com>
+	PR middle-end/92153
+	* ggc-page.c (release_pages): Read g->alloc_size before free rather
+	than after it.
+
+	2019-10-11  Jan Hubicka  <hubicka@ucw.cz>
+	* ggc-page.c (release_pages): Output statistics when !quiet_flag.
+	(ggc_collect): Dump later to not interfere with release_page dump.
+	(ggc_trim): New function.
+	* ggc-none.c (ggc_trim): New.
+	* ggc.h (ggc_trim): Declare.
+
+2019-10-24  Mihail Ionescu  <mihail.ionescu@arm.com>
+
+	Backport from mainline
+	2019-10-18  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* config/arm/t-multilib: Add new multilib variants and new
+	mappings.
+
+2019-10-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-23  Iain Sandoe  <iain@sandoe.co.uk>
+	* config/rs6000/darwin.h (ASM_OUTPUT_MAX_SKIP_ALIGN): Guard
+	against out of range max skip or log values.
+
+2019-10-23  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-08  Tulio Magno Quites Machado Filho  <tuliom@linux.ibm.com>
+
+	* config.gcc: Move -L usage from LINK_OS_EXTRA_SPEC32 and
+	LINK_OS_EXTRA_SPEC64 to MD_STARTFILE_PREFIX and
+	MD_STARTFILE_PREFIX_1 when using --with-advance-toolchain.
+
+2019-10-23  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-09-26  Martin Liska  <mliska@suse.cz>
+
+	PR tree-optimization/91885
+	* tree-vectorizer.c (try_vectorize_loop_1):
+	Add TODO_update_ssa_only_virtuals similarly to what slp
+	pass does.
+
+2019-10-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/92131
+	* tree-vrp.c (extract_range_from_plus_minus_expr): If the resulting
+	range would be symbolic, drop to varying for any explicit overflow
+	in the constant part or if neither range is a singleton.
+
+2019-10-23  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-17  Richard Biener  <rguenther@suse.de>
+
+	PR debug/91887
+	* dwarf2out.c (gen_formal_parameter_die): Also try to match
+	context_die against a DW_TAG_GNU_formal_parameter_pack parent.
+
+2019-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/92056
+	* tree-object-size.c (cond_expr_object_size): Return early if then_
+	processing resulted in unknown size.
+
+	2019-10-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91734
+	* generic-match-head.c: Include fold-const-call.h.
+	* match.pd (sqrt(x) cmp c): Check the boundary value and
+	in case inexact computation of c*c affects comparison of the boundary,
+	turn LT_EXPR into LE_EXPR, GE_EXPR into GT_EXPR, LE_EXPR into LT_EXPR
+	or GT_EXPR into GE_EXPR.  Punt for sqrt comparisons against NaN and
+	for -frounding-math.  For c2, try the next smaller or larger floating
+	point constant depending on comparison code and if it has the same
+	sqrt as c2, use it instead of c2.
+
+	2019-09-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/90543
+	* optc-save-gen.awk: Fix up printing string option differences.
+
+	2019-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91920
+	* gimplify.c (omp_default_clause): Predetermine DECL_IN_CONSTANT_POOL
+	variables as shared.
+
+	2019-09-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91723
+	* tree-vect-stmts.c (vectorizable_call): Use types_compatible_p check
+	instead of pointer equality when checking if argument vectypes are
+	the same.
+
+	2019-09-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91665
+	* tree-vect-loop.c (vectorizable_reduction): Punt if base has type
+	incompatible with the type of PHI result.
+
+	2019-09-06  Jakub Jelinek  <jakub@redhat.com>
+
+	* function.c (assign_parm_find_data_types): Use RECORD_OR_UNION_TYPE_P
+	before testing TYPE_TRANSPARENT_AGGR.
+	* calls.c (initialize_argument_information, load_register_parameters):
+	Likewise.
+
+	2019-09-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91001
+	PR middle-end/91105
+	PR middle-end/91106
+	* calls.c (load_register_parameters): For TYPE_TRANSPARENT_AGGR
+	types, use type of their first field instead of type of
+	args[i].tree_value.
+
+	2019-09-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR go/91617
+	* fold-const.c (range_check_type): For enumeral and boolean
+	type, pass 1 to type_for_size langhook instead of
+	TYPE_UNSIGNED (etype).  Return unsigned_type_for result whenever
+	etype isn't TYPE_UNSIGNED INTEGER_TYPE.
+	(build_range_check): Don't call unsigned_type_for for pointer types.
+	* match.pd (X / C1 op C2): Don't call unsigned_type_for on
+	range_check_type result.
+
+	2019-09-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91623
+	* optabs.c (expand_vec_cond_expr): If op0 is a VECTOR_CST and only
+	EQ_EXPR/NE_EXPR is supported, verify that op0 only contains
+	zeros or negative elements and use NE_EXPR instead of LT_EXPR against
+	zero vector.
+
+	PR lto/91572
+	* tree.c (find_decls_types_in_node): Also walk TREE_PURPOSE of
+	GIMPLE_ASM TREE_LIST operands.
+
+	2019-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91351
+	* tree-cfg.c (generate_range_test): Use range_check_type instead of
+	unsigned_type_for.
+	* tree-cfgcleanup.c (convert_single_case_switch): Punt if
+	range_check_type returns NULL.
+	* tree-switch-conversion.c (switch_conversion::build_one_array):
+	Use range_check_type instead of unsigned_type_for, don't perform
+	linear opt if it returns NULL.
+	(bit_test_cluster::find_bit_tests): Formatting fix.
+	(bit_test_cluster::emit): Use range_check_type instead of
+	unsigned_type_for.
+	(switch_decision_tree::try_switch_expansion): Punt if range_check_type
+	returns NULL.
+
+2019-10-18  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2019-10-18 trunk r277143.
+
+	PR target/86040
+	* config/avr/avr.c (avr_out_lpm): Do not shortcut-return.
+
+2019-10-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/59888
+	* config/darwin.c (darwin_rodata_section): Add relocation flag,
+	choose const_data section for constants with relocations.
+	(machopic_select_section): Pass relocation flag to
+	darwin_rodata_section ().
+
+2019-10-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-09-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_legitimize_pic_address): Check
+	for lra, rather than reload.
+
+2019-10-17  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_output_indirect_call): Fix typos in last change.
+
+2019-10-17  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-05-03  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/89400
+	* config/arm/arm.md (unaligned_loadsi): Add variant for thumb1.
+	Restrict 'all' variant to 32-bit configurations.
+	(unaligned_loadhiu): Likewise.
+	(unaligned_storehi): Likewise.
+	(unaligned_storesi): Likewise.
+	(unaligned_loadhis): Disable when compiling for thumb1.
+
+2019-10-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/87243
+	* config/darwin-driver.c (maybe_get_sysroot_from_sdkroot): New.
+	(darwin_driver_init): Use the sysroot provided by SDKROOT when that
+	is available and the user has not set one on the command line.
+
+2019-10-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.h (DRIVER_SELF_SPECS): Remove the linker cases.
+	(RDYNAMIC): Rename to, DARWIN_RDYNAMIC.
+	(DARWIN_PIE_SPEC, DARWIN_NOPIE_SPEC): Adjust to remove the Xlinker
+	clauses.
+	(LINK_COMMAND_SPEC_A): Add DARWIN_RDYNAMIC, DARWIN_PIE_SPEC and
+	DARWIN_NOPIE_SPEC.
+
+	Backport from mainline
+	2019-06-19  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.h (DRIVER_SELF_SPECS): Add RDYNAMIC, DARWIN_PIE_SPEC
+	and DARWIN_NOPIE_SPEC.
+	(RDYNAMIC): New, modified from DARWIN_EXPORT_DYNAMIC.
+	(DARWIN_PIE_SPEC): Collate from darwin.h and darwin9.h.
+	(DARWIN_NOPIE_SPEC): Collate from darwin10.h.
+	(DARWIN_NOCOMPACT_UNWIND): New from darwin10.h
+	(DARWIN_EXPORT_DYNAMIC): Delete.
+	* config/darwin10.h (LINK_GCC_C_SEQUENCE_SPEC): Move no_compact_unwind
+	and pie options processing to  darwin.h.
+	* config/darwin9.h (DARWIN_PIE_SPEC): Move pie processing to darwin.h
+
+2019-10-16  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-04  Richard Biener  <rguenther@suse.de>
+
+	PR lto/91968
+	* tree.c (find_decls_types_r): Do not remove LABEL_DECLs from
+	BLOCK_VARS.
+
+	2019-09-19  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91812
+	* tree-ssa-phiprop.c (propagate_with_phi): Do not replace
+	volatile loads.
+
+	2019-09-17  Richard Biener  <rguenther@suse.de>
+
+	PR debug/91772
+	* dwarf2out.c (dwarf2out_late_global_decl): If early dwarf
+	was missing generate locations only once.
+
+	2019-09-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91790
+	* tree-vect-stmts.c (vectorizable_load): For BB vectorization
+	use the correct DR for setting up realignment.
+
+2019-10-14  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	Backport from trunk
+	2019-09-26  Will Schmidt <will_schmidt@vnet.ibm.com>
+
+	* config/rs6000/rs6000-builtin.def: (LVSL, LVSR, LVEBX, LVEHX,
+	LVEWX, LVXL, LVXL_V2DF, LVXL_V2DI, LVXL_V4SF, LVXL_V4SI, LVXL_V8HI,
+	LVXL_V16QI, LVX, LVX_V1TI, LVX_V2DF, LVX_V2DI, LVX_V4SF, LVX_V4SI,
+	LVX_V8HI, LVX_V16QI, LVLX, LVLXL, LVRX, LVRXL, LXSDX, LXVD2X_V1TI,
+	LXVD2X_V2DF, LXVD2X_V2DI, LXVDSX, LXVW4X_V4SF, LXVW4X_V4SI,
+	LXVW4X_V8HI, LXVW4X_V16QI, LD_ELEMREV_V1TI, LD_ELEMREV_V2DF,
+	LD_ELEMREV_V2DI, LD_ELEMREV_V4SF, LD_ELEMREV_V4SI, LD_ELEMREV_V8HI,
+	LD_ELEMREV_V16QI): Use the PURE attribute.
+
+2019-10-10  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/92022
+	* config/alpha/alpha.c (alpha_handle_trap_shadows): Skip DEBUG_INSN.
+
+2019-10-10  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2019-10-10  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/88630
+	* config/sh/sh.h (TARGET_FPU_SH4_300): New macro.
+	* config/sh/sh.c (sh_option_override): Enable fsca and fsrra insns
+	also for TARGET_FPU_SH4_300.
+	(sh_emit_mode_set): Check for TARGET_FPU_SH4_300 instead of
+	TARGET_SH4_300.
+	* config/sh/sh.md (toggle_pr): Add TARGET_FPU_SH4_300 condition.
+	(negsf2): Expand to either negsf2_fpscr or negsf2_no_fpscr.
+	(*negsf2_i): Split into ...
+	(negsf2_fpscr, negsf2_no_fpscr): ... these new patterns.
+	(abssf2): Expand to either abssf2_fpsc or abssf2_no_fpsc.
+	(**abssf2_i): Split into ...
+	(abssf2_fpscr, abssf2_no_fpscr): ... these new patterns.
+	(negdf2): Expand to either negdf2_fpscr or negdf2_no_fpscr.
+	(*negdf2_i): Split into ...
+	(negdf2_fpscr, negdf2_no_fpscr): ... these new patterns.
+	(absdf2): Expand to either absdf2_fpscr or absdf2_no_fpsc.
+	(**abssf2_i): Split into ...
+	(absdf2_fpscr, absdf2_no_fpscr): ... these new patterns.
+
+2019-10-10  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-10  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* common/config/s390/s390-common.c (PF_ARCH13): Rename to...
+	(PF_Z15): ... this.
+	* config.gcc: Add z15 as option for --with-arch and --with-tune
+	configure switches.
+	* config/s390/s390-c.c (s390_resolve_overloaded_builtin): Add
+	error reporting for unsupported builtins.
+	* config/s390/s390-opts.h (enum processor_type): Rename
+	PROCESSOR_8561_ARCH13 to PROCESSOR_8561_Z15.
+	* config/s390/8561.md: Rename arch13 to z15 throughout the file.
+	* config/s390/driver-native.c (s390_host_detect_local_cpu):
+	Likewise.
+	* config/s390/s390-builtins.def: Likewise.
+	* config/s390/s390.c (processor_table): Add z15 as option and keep arch13 as alternative.
+	(s390_expand_builtin): Add missing check for unsupported builtins.
+	(s390_canonicalize_comparison): Rename TARGET_ARCH13 to TARGET_Z15.
+	(s390_rtx_costs): Likewise.
+	(s390_get_sched_attrmask): Rename arch13 to z15.
+	(s390_get_unit_mask): Likewise.
+	(s390_is_fpd): Likewise.
+	(s390_is_fxd): Likewise.
+	* config/s390/s390.h (enum processor_flags): Likewise.
+	* config/s390/s390.md: Likewise.
+	* config/s390/vector.md: Likewise.
+	* config/s390/vx-builtins.md: Likewise.
+	* config/s390/s390.opt: Add z15 to processor_type value.
+
+2019-10-07  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-01  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/91275
+	* config/rs6000/rs6000-p8swap.c (rtx_is_swappable_p): Don't swap
+	vpmsumd.
+
+2019-10-05  Andrea Corallo  <andrea.corallo@arm.com>
+
+	Backport from mainline
+	2019-10-03  Andrea Corallo  <andrea.corallo@arm.com>
+	* gcc/ipa-cp.c (ipa_cp_c_finalize): Release ipcp_transformation_sum
+	when finished.
+	* ipa-prop.c (ipcp_free_transformation_sum): New function.
+	* ipa-prop.h (ipcp_free_transformation_sum): Add declaration.
+
+2019-10-04  Dragan Mladjenovic <dmladjenovic@wavecomp.com>
+
+	Backport from mainline
+	2019-10-03  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	PR target/91769
+	* config/mips/mips.c (mips_split_move): Use reg_overlap_mentioned_p
+	instead of REGNO equality check on addr.reg.
+
+2019-10-04  Dragan Mladjenovic <dmladjenovic@wavecomp.com>
+
+	Backport from mainline
+	2019-07-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/mips/mips.c (mips_split_move): Zero-initialize addr
+	and check whether addr.reg is nonnull before using it.
+
+2019-10-02  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	Backport from mainline
+
+	2019-09-13  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR fortran/91716
+	* trans-array.c (gfc_conv_array_initializer): Always assign the
+	array type of the field to the string constant.
+
+2019-10-01  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+
+	2019-10-01  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/88562
+	* config/sh/sh.c (sh_extending_set_of_reg::use_as_extended_reg): Use
+	sh_check_add_incdec_notes to preserve REG_INC notes when replacing
+	a memory access insn.
+
+
+2019-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64.md (mov<mode>): Don't call
+	aarch64_split_dimode_const_store on volatile MEM.
+
+2019-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-26  Matt Turner  <mattst88@gmail.com>
+
+	PR driver/69471
+	* config/aarch64/aarch64.opt (march=): Add Negative(march=).
+	(mtune=): Add Negative(mtune=).
+	(mcpu=): Add Negative(mcpu=).
+	* config/arm/arm.opt: Likewise.
+
+2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/86805
+	* config/sh/sh.c (TARGET_HAVE_SPECULATION_SAFE_VALUE): Define.
+
+2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/80672
+	* config/sh/sh.c (parse_validate_atomic_model_option): Use
+	std::string::compare instead of std::string::find.
+
+2019-09-25  Kyrylo Tkachov <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-08-22  Kyrylo Tkachov <kyrylo.tkachov@arm.com>
+
+	* config/arm/arm_acle.h: Use arch=armv8-a+crc+simd pragma for CRC32
+	intrinsics if __ARM_FP.
+	Use __ARM_FEATURE_CRC32 ifdef guard.
+
+2019-09-23  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline
+	2019-06-18  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* config/xtensa/xtensa.c (xtensa_expand_prologue): Add stack
+	pointer adjustment for the case of no callee-saved registers and
+	stack frame bigger than 128 bytes.
+
+2019-09-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.opt (prebind, noprebind, seglinkedit,
+	noseglinkedit): Add RejectNegative.
+
+	Backport from mainline
+	2019-06-14  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.opt: Add RejectNegative where needed, reorder
+	and add minimal functional descriptions.
+
+2019-09-20  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_trampoline_init): Remove spurious extended
+	character.
+
+2019-09-20  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-06-06  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR rtl-optimization/88751
+	* ira.c (ira): Use the number of the actually referenced registers
+	when calculating the threshold.
+
+2019-09-20  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backport from mainline
+	2019-09-18  Jim Wilson  <jimw@sifive.com>
+
+	PR target/91683
+	* config/riscv/riscv-protos.h (riscv_split_symbol): New bool parameter.
+	(riscv_move_integer): Likewise.
+	* config/riscv/riscv.c (riscv_split_integer): Pass FALSE for new
+	riscv_move_integer arg.
+	(riscv_legitimize_move): Likewise.
+	(riscv_force_temporary): New parameter in_splitter.  Don't call
+	force_reg if true.
+	(riscv_unspec_offset_high): Pass FALSE for new riscv_force_temporary
+	arg.
+	(riscv_add_offset): Likewise.
+	(riscv_split_symbol): New parameter in_splitter.  Pass to
+	riscv_force_temporary.
+	(riscv_legitimize_address): Pass FALSE for new riscv_split_symbol
+	arg.
+	(riscv_move_integer): New parameter in_splitter.  New local
+	can_create_psuedo.  Don't call riscv_split_integer or force_reg when
+	in_splitter TRUE.
+	(riscv_legitimize_const_move): Pass FALSE for new riscv_move_integer,
+	riscv_split_symbol, and riscv_force_temporary args.
+	* config/riscv/riscv.md (low<mode>+1): Pass TRUE for new
+	riscv_move_integer arg.
+	(low<mode>+2): Pass TRUE for new riscv_split_symbol arg.
+
+2019-09-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/91269
+	* config/sparc/sparc.h (HARD_REGNO_CALLER_SAVE_MODE): Define.
+
+2019-09-19  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backport from mainline
+	2019-09-05  Jakub Jelinek  <jakub@redhat.com>
+		    Jim Wilson  <jimw@sifive.com>
+
+	PR target/91635
+	* config/riscv/riscv.md (zero_extendsidi2, zero_extendhi<GPR:mode>2,
+	extend<SHORT:mode><SUPERQI:mode>2): Don't split if
+	paradoxical_subreg_p (operands[0]).
+	(*lshrsi3_zero_extend_3+1, *lshrsi3_zero_extend_3+2): Add clobber and
+	use as intermediate value.
+
+2019-09-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/89795
+	* rtlanal.c (nonzero_bits1) <SUBREG>: Do not propagate results from
+	inner REGs to paradoxical SUBREGs if WORD_REGISTER_OPERATIONS is set.
+
+2019-09-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87853
+	* config/i386/emmintrin.h (_mm_cmpeq_epi8): Use casts to __v16qi
+	instead of __v16qs.
+
+	PR target/91704
+	* config/i386/avxintrin.h (__v32qs): New typedef.
+	* config/i386/avx2intrin.h (_mm256_cmpgt_epi8): Use casts to __v32qs
+	instead of __v32qi.
+
+2019-09-04  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-08-13  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR target/81800
+	* gcc/config/aarch64/aarch64.md (lrint): Disable lrint pattern if GPF
+	operand is larger than a long int.
+
+2019-09-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91597
+	* tree-vrp.c (extract_range_from_binary_expr): Remove unsafe
+	BIT_AND_EXPR optimization for pointers, even if both operand
+	ranges don't include NULL, the result can be NULL.
+
+2019-09-02  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-09-02  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/91601
+	* gcov.c (path_contains_zero_cycle_arc): Rename to ...
+	(path_contains_zero_or_negative_cycle_arc): ... this and handle
+	also negative edges.
+	(circuit): Handle also negative edges as they can happen
+	in some situations.
+
+2019-09-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/91472
+	* config/sparc/sparc.c (sparc_cannot_force_const_mem): Return true
+	during LRA/reload in PIC mode if the PIC register hasn't been used yet.
+	(sparc_pic_register_p): Test reload_in_progress for consistency's sake.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* ggc-page.c (ggc_pch_read): Read the ggc_pch_ondisk structure
+	and issue any diagnostics needed before collecting the pre-PCH
+	state.
+
+2019-08-30  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-08-22  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/91481
+	* config/rs6000/rs6000.md (unspec): Delete UNSPEC_DARN, UNSPEC_DARN_32,
+	and UNSPEC_DARN_RAW.
+	(unspecv): New enumerator values UNSPECV_DARN, UNSPECV_DARN_32, and
+	UNSPECV_DARN_RAW.
+	(darn_32): Use an unspec_volatile, and UNSPECV_DARN_32.
+	(darn_raw): Use an unspec_volatile, and UNSPECV_DARN_RAW.
+	(darn): Use an unspec_volatile, and UNSPECV_DARN.
+
+2019-08-30  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-08-22  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* config/rs6000/altivec.md (unspec): Delete UNSPEC_DARN, UNSPEC_DARN_32,
+	UNSPEC_DARN_RAW, UNSPEC_CMPRB, UNSPEC_CMPRB2, UNSPEC_CMPEQB; move to...
+	* config/rs6000/rs6000.md (unspec): ... here.
+	* config/rs6000/altivec.md (darn_32, darn_raw, darn, cmprb,
+	*cmprb_internal, setb_signed, setb_unsigned, cmprb2, *cmprb2_internal,
+	cmpeqb, *cmpeqb_internal): Delete, move to...
+	* config/rs6000/rs6000.md (darn_32, darn_raw, darn, cmprb,
+	*cmprb_internal, setb_signed, setb_unsigned, cmprb2, *cmprb2_internal,
+	cmpeqb, *cmpeqb_internal): ... here.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-04-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90278
+	* tree-ssa-forwprop.c (pass_forwprop::execute): Transfer/clean
+	EH on comparison simplification.
+
+2019-08-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91568
+	* tree-vectorizer.h (_slp_tree::max_nunits): Add.
+	(vect_update_max_nunits): Add overload for poly_uint64.
+	* tree-vect-slp.c (vect_create_new_slp_node): Initialize it.
+	(vect_build_slp_tree): Record max_nunits into the subtree
+	and merge it upwards.
+	(vect_print_slp_tree): Print max_nunits.
+
+2019-08-28  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-05-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90637
+	* tree-ssa-sink.c (statement_sink_location): Honor the
+	computed sink location for single-uses.
+
+2019-08-26  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport r274411 from trunk to gcc-9-branch.
+	2019-08-14  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	PR lto/91287
+	* builtins.c (builtin_with_linkage_p): New function.
+	* builtins.h (builtin_with_linkage_p): New function.
+	* symtab.c (write_symbol): Remove redundant assert.
+	* lto-streamer-out.c (symtab_node::output_to_lto_symbol_table_p):
+	Remove FIXME and use builtin_with_linkage_p.
+
+2019-08-25  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/91533
+	Backport from mainline
+	2019-06-30  Uroš Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sse.md (ssse3_abs<mode>2): Rename from abs<mode>2.
+	* config/i386/i386-builtin.def (__builtin_ia32_pabsb):
+	Use CODE_FOR_ssse3_absv8qi2.
+	(__builtin_ia32_pabsw): Use CODE_FOR_ssse3_absv4hi2.
+	(__builtin_ia32_pabsd): Use CODE_FOR_ssse3_absv2si2.
+
+2019-08-23  Mihailo Stojanovic  <mistojanovic@wavecomp.com>
+
+	Backport from mainline
+	2019-08-23  Mihailo Stojanovic  <mistojanovic@wavecomp.com>
+
+	* config/mips/mips.md (mips_get_fcsr, *mips_get_fcsr): Use SI
+	machine mode for unspec_volatile operand.
+
+2019-08-23  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/91508
+	Backport from mainline
+	2019-08-15  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/91438
+	* cgraph.c (cgraph_node::remove): When setting
+	n->origin = NULL for all nested functions, reset
+	also next_nested.
+
+2019-08-23  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-08-15  Martin Liska  <mliska@suse.cz>
+
+	* cgraph.c (cgraph_node::verify_node): Verify origin, nested
+	and next_nested.
+
+2019-08-23  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-08-15  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/91404
+	* passes.c (order): Remove.
+	(uid_hash_t): Likewise).
+	(remove_cgraph_node_from_order): Remove from set
+	of pointers (cgraph_node *).
+	(insert_cgraph_node_to_order): New.
+	(duplicate_cgraph_node_to_order): New.
+	(do_per_function_toporder): Register all 3 cgraph hooks.
+	Skip removed_nodes now as we know about all of them.
+
+2019-08-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (TARGET_OS_CPP_BUILTINS): Add asserts
+	for cpu and machine.  Factor 64/32b builtins.
+
+2019-08-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/91347
+	* dse.c (scan_insn): Call add_wild_read for non-const/memset tail calls
+	before reload if HARD_FRAME_POINTER_IS_ARG_POINTER.
+
+2019-08-19  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-09-09  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/91386
+	* config/aarch64/aarch64.c (aarch64_gen_adjusted_ldpstp): Use copy_rtx
+	to preserve the contents of the original insns.
+
+2019-08-16  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	Backport from mainline
+	2019-08-16  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR tree-optimization/91109
+	* lra-int.h (lra_need_for_scratch_reg_p): Declare.
+	* lra.c (lra): Use lra_need_for_scratch_reg_p.
+	* lra-spills.c (lra_need_for_scratch_reg_p): New function.
+
+	2019-08-07  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR tree-optimization/91109
+	* lra-remat.c (update_scratch_ops): Remove assignment of the
+	hard register.
+
+2019-08-15  Steve Ellcey  <sellcey@marvell.com>
+
+	Backport from mainline
+	2019-08-02  Steve Ellcey  <sellcey@marvell.com>
+
+	* omp-simd-clone.c (simd_clone_adjust_return_type): Remove call to
+	build_distinct_type_copy.
+	(simd_clone_adjust_argument_types): Ditto.
+	(simd_clone_adjust): Call build_distinct_type_copy here.
+	(expand_simd_clones): Ditto.
+
+2019-08-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91445
+	Backport from mainline
+	2019-07-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91091
+	* tree-ssa-alias.h (get_continuation_for_phi): Add tbaa_p parameter.
+	(walk_non_aliased_vuses): Likewise.
+	* tree-ssa-alias.c (maybe_skip_until): Pass down tbaa_p.
+	(get_continuation_for_phi): New tbaa_p parameter and pass
+	it down.
+	(walk_non_aliased_vuses): Likewise.
+	* tree-ssa-pre.c (translate_vuse_through_block): Likewise.
+	* tree-ssa-scopedtables.c (avail_exprs_stack::lookup_avail_expr):
+	Likewise.
+	* tree-ssa-sccvn.c (struct vn_walk_cb_data): Add tbaa_p flag.
+	(vn_reference_lookup_3): Handle and pass down tbaa_p flag.
+	(vn_reference_lookup_pieces): Adjust.
+	(vn_reference_lookup): Remove alias-set altering, instead pass
+	down false as tbaa_p.
+
+	2019-07-04  Richard Biener  <rguenther@suse.de>
+
+	* tree-ssa-sccvn.h (vn_reference_lookup): Add last_vuse_ptr
+	argument.
+	* tree-ssa-sccvn.c (last_vuse_ptr, vn_walk_kind): Move
+	globals into...
+	(struct vn_walk_cb_data): New callback data struct.
+	(vn_reference_lookup_2): Adjust.
+	(vn_reference_lookup_3): Likewise.
+	(vn_reference_lookup_pieces): Likewise.
+	(vn_reference_lookup): Likewise, get last_vuse_ptr argument.
+	(visit_reference_op_load): Adjust.
+
+2019-08-14  Martin Sebor  <msebor@redhat.com>
+
+	Backport from mainline
+
+	2019-08-01  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/90947
+	* tree.c (type_initializer_zero_p): Define.
+	* tree.h (type_initializer_zero_p): New function.
+
+	2019-08-05  Martin Sebor  <msebor@redhat.com>
+
+	* doc/extend.texi (Common Variable Attributes): Document alias
+	attribute.
+
+2019-08-12  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-08-12  Richard Biener  <rguenther@suse.de>
+
+	PR lto/91375
+	* tree.c (free_lang_data_in_type): Do not free TYPE_BINFO dependent on
+	flag_devirtualize.
+
+	2019-08-12  Richard Biener  <rguenther@suse.de>
+
+	PR driver/91130
+	* lto-wrapper.c (get_options_from_collect_gcc_options): Remove
+	lang_mask option, always use CL_DRIVER.
+	(find_and_merge_options): Adjust.
+	(run_gcc): Likewise.
+
+	2019-08-07  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR driver/91130
+	* lto-wrapper.c (find_and_merge_options): Use CL_DRIVER when
+	processing COLLECT_GCC_OPTIONS.
+	(run_gcc): Likewise.
+
+2019-08-12  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 9.2.1.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
@@ -513,7 +1790,7 @@
 
 2019-07-11  Uroš Bizjak  <ubizjak@gmail.com>
 
-	Backported from mainline
+	Backport from mainline
 	2019-07-06  Richard Sandiford  <richard.sandiford@arm.com>
 
 	* config/i386/sse.md (*andnot<mode>3_bcst): Fix VI/VI48_AVX512VL typo.
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 5f43d9de00e..abae872cd63 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -1120,6 +1120,7 @@ endif
 # Support for additional languages (other than C).
 # C can be supported this way too (leave for later).
 
+LANG_CONFIGUREFRAGS  = @all_lang_configurefrags@
 LANG_MAKEFRAGS = @all_lang_makefrags@
 
 # Used by gcc/jit/Make-lang.in
@@ -1894,7 +1895,7 @@ cstamp-h: config.in config.status
 # Really, really stupid make features, such as SUN's KEEP_STATE, may force
 # a target to build even if it is up-to-date.  So we must verify that
 # config.status does not exist before failing.
-config.status: $(srcdir)/configure $(srcdir)/config.gcc
+config.status: $(srcdir)/configure $(srcdir)/config.gcc $(LANG_CONFIGUREFRAGS)
 	@if [ ! -f config.status ] ; then \
 	  echo You must configure gcc.  Look at http://gcc.gnu.org/install/ for details.; \
 	  false; \
--- a/gcc/builtins.c
+++ b/gcc/builtins.c
@@ -11236,3 +11236,90 @@ target_char_cst_p (tree t, char *p)
   *p = (char)tree_to_uhwi (t);
   return true;
 }
+
+/* Return true if the builtin DECL is implemented in a standard library.
+   Otherwise returns false which doesn't guarantee it is not (thus the list of
+   handled builtins below may be incomplete).  */
+
+bool
+builtin_with_linkage_p (tree decl)
+{
+  if (DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)
+    switch (DECL_FUNCTION_CODE (decl))
+    {
+      CASE_FLT_FN (BUILT_IN_ACOS):
+      CASE_FLT_FN (BUILT_IN_ACOSH):
+      CASE_FLT_FN (BUILT_IN_ASIN):
+      CASE_FLT_FN (BUILT_IN_ASINH):
+      CASE_FLT_FN (BUILT_IN_ATAN):
+      CASE_FLT_FN (BUILT_IN_ATANH):
+      CASE_FLT_FN (BUILT_IN_ATAN2):
+      CASE_FLT_FN (BUILT_IN_CBRT):
+      CASE_FLT_FN (BUILT_IN_CEIL):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_CEIL):
+      CASE_FLT_FN (BUILT_IN_COPYSIGN):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_COPYSIGN):
+      CASE_FLT_FN (BUILT_IN_COS):
+      CASE_FLT_FN (BUILT_IN_COSH):
+      CASE_FLT_FN (BUILT_IN_ERF):
+      CASE_FLT_FN (BUILT_IN_ERFC):
+      CASE_FLT_FN (BUILT_IN_EXP):
+      CASE_FLT_FN (BUILT_IN_EXP2):
+      CASE_FLT_FN (BUILT_IN_EXPM1):
+      CASE_FLT_FN (BUILT_IN_FABS):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_FABS):
+      CASE_FLT_FN (BUILT_IN_FDIM):
+      CASE_FLT_FN (BUILT_IN_FLOOR):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_FLOOR):
+      CASE_FLT_FN (BUILT_IN_FMA):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_FMA):
+      CASE_FLT_FN (BUILT_IN_FMAX):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_FMAX):
+      CASE_FLT_FN (BUILT_IN_FMIN):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_FMIN):
+      CASE_FLT_FN (BUILT_IN_FMOD):
+      CASE_FLT_FN (BUILT_IN_FREXP):
+      CASE_FLT_FN (BUILT_IN_HYPOT):
+      CASE_FLT_FN (BUILT_IN_ILOGB):
+      CASE_FLT_FN (BUILT_IN_LDEXP):
+      CASE_FLT_FN (BUILT_IN_LGAMMA):
+      CASE_FLT_FN (BUILT_IN_LLRINT):
+      CASE_FLT_FN (BUILT_IN_LLROUND):
+      CASE_FLT_FN (BUILT_IN_LOG):
+      CASE_FLT_FN (BUILT_IN_LOG10):
+      CASE_FLT_FN (BUILT_IN_LOG1P):
+      CASE_FLT_FN (BUILT_IN_LOG2):
+      CASE_FLT_FN (BUILT_IN_LOGB):
+      CASE_FLT_FN (BUILT_IN_LRINT):
+      CASE_FLT_FN (BUILT_IN_LROUND):
+      CASE_FLT_FN (BUILT_IN_MODF):
+      CASE_FLT_FN (BUILT_IN_NAN):
+      CASE_FLT_FN (BUILT_IN_NEARBYINT):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_NEARBYINT):
+      CASE_FLT_FN (BUILT_IN_NEXTAFTER):
+      CASE_FLT_FN (BUILT_IN_NEXTTOWARD):
+      CASE_FLT_FN (BUILT_IN_POW):
+      CASE_FLT_FN (BUILT_IN_REMAINDER):
+      CASE_FLT_FN (BUILT_IN_REMQUO):
+      CASE_FLT_FN (BUILT_IN_RINT):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_RINT):
+      CASE_FLT_FN (BUILT_IN_ROUND):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_ROUND):
+      CASE_FLT_FN (BUILT_IN_SCALBLN):
+      CASE_FLT_FN (BUILT_IN_SCALBN):
+      CASE_FLT_FN (BUILT_IN_SIN):
+      CASE_FLT_FN (BUILT_IN_SINH):
+      CASE_FLT_FN (BUILT_IN_SINCOS):
+      CASE_FLT_FN (BUILT_IN_SQRT):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_SQRT):
+      CASE_FLT_FN (BUILT_IN_TAN):
+      CASE_FLT_FN (BUILT_IN_TANH):
+      CASE_FLT_FN (BUILT_IN_TGAMMA):
+      CASE_FLT_FN (BUILT_IN_TRUNC):
+      CASE_FLT_FN_FLOATN_NX (BUILT_IN_TRUNC):
+	return true;
+      default:
+	break;
+    }
+  return false;
+}
diff --git a/gcc/builtins.h b/gcc/builtins.h
index 1ffb491d785..66c9295ff4a 100644
--- a/gcc/builtins.h
+++ b/gcc/builtins.h
@@ -150,5 +150,6 @@ extern internal_fn replacement_internal_fn (gcall *);
 
 extern void warn_string_no_nul (location_t, const char *, tree, tree);
 extern tree unterminated_array (tree, tree * = NULL, bool * = NULL);
+extern bool builtin_with_linkage_p (tree);
 
 #endif /* GCC_BUILTINS_H */
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index acdfe79894e..e7f0127dcf2 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,45 @@
+2019-11-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* c-ada-spec.c (get_underlying_decl): Do not look through typedefs.
+	(dump_forward_type): Do not generate a declaration for function types.
+	(dump_nested_type) <ARRAY_TYPE>: Do not generate a nested declaration
+	of the component type if it is declared in another file.
+
+2019-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/91925
+	* c-warn.c (check_alignment_of_packed_member): Ignore FIELD_DECLs
+	with NULL DECL_FIELD_OFFSET.
+
+	2019-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88203
+	* c-common.h (c_omp_predefined_variable): Declare.
+	* c-omp.c (c_omp_predefined_variable): New function.
+	(c_omp_predetermined_sharing): Return OMP_CLAUSE_DEFAULT_SHARED
+	for predefined variables.
+
+2019-09-02  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-09-02  Martin Liska  <mliska@suse.cz>
+
+	PR c++/91155
+	* c-common.c (fname_as_string): Use cxx_printable_name for
+	__PRETTY_FUNCTION__ same as was used before r265711.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* c-lex.c (c_lex_with_flags):  Don't call
+	c_common_no_more_pch () from here.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/gcc/c-family/c-ada-spec.c b/gcc/c-family/c-ada-spec.c
index 76e736964de..0fee9a0d037 100644
--- a/gcc/c-family/c-ada-spec.c
+++ b/gcc/c-family/c-ada-spec.c
@@ -1025,7 +1025,9 @@ get_underlying_decl (tree type)
 
   if (TYPE_P (type))
     {
-      type = TYPE_MAIN_VARIANT (type);
+      /* Strip qualifiers but do not look through typedefs.  */
+      if (TYPE_QUALS_NO_ADDR_SPACE (type))
+	type = TYPE_MAIN_VARIANT (type);
 
       /* type is a typedef.  */
       if (TYPE_NAME (type) && DECL_P (TYPE_NAME (type)))
@@ -2451,6 +2453,9 @@ dump_forward_type (pretty_printer *buffer, tree type, tree t, int spc)
   if (DECL_SOURCE_FILE (decl) != DECL_SOURCE_FILE (t))
     return;
 
+  if (TREE_CODE (type) == FUNCTION_TYPE)
+    return;
+
   /* Generate an incomplete type declaration.  */
   pp_string (buffer, "type ");
   dump_ada_node (buffer, decl, NULL_TREE, spc, false, true);
@@ -2519,7 +2524,10 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,
       while (TREE_CODE (tmp) == ARRAY_TYPE)
 	tmp = TREE_TYPE (tmp);
       decl = get_underlying_decl (tmp);
-      if (decl && !DECL_NAME (decl) && !TREE_VISITED (decl))
+      if (decl
+	  && !DECL_NAME (decl)
+	  && DECL_SOURCE_FILE (decl) == DECL_SOURCE_FILE (t)
+	  && !TREE_VISITED (decl))
 	{
 	  /* Generate full declaration.  */
 	  dump_nested_type (buffer, decl, t, parent, spc);
diff --git a/gcc/c-family/c-common.h b/gcc/c-family/c-common.h
index 1cf2cae6395..e9ef16aff29 100644
--- a/gcc/c-family/c-common.h
+++ b/gcc/c-family/c-common.h
@@ -1184,6 +1184,7 @@ extern void c_omp_split_clauses (location_t, enum tree_code, omp_clause_mask,
 				 tree, tree *);
 extern tree c_omp_declare_simd_clauses_to_numbers (tree, tree);
 extern void c_omp_declare_simd_clauses_to_decls (tree, tree);
+extern bool c_omp_predefined_variable (tree);
 extern enum omp_clause_default_kind c_omp_predetermined_sharing (tree);
 
 /* Return next tree in the chain for chain_next walking of tree nodes.  */
diff --git a/gcc/c-family/c-lex.c b/gcc/c-family/c-lex.c
index 0a368a33a58..3c92103a5d4 100644
--- a/gcc/c-family/c-lex.c
+++ b/gcc/c-family/c-lex.c
@@ -394,7 +394,6 @@ enum cpp_ttype
 c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,
 		  int lex_flags)
 {
-  static bool no_more_pch;
   const cpp_token *tok;
   enum cpp_ttype type;
   unsigned char add_flags = 0;
@@ -628,12 +627,6 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,
   if (cpp_flags)
     *cpp_flags = tok->flags | add_flags;
 
-  if (!no_more_pch)
-    {
-      no_more_pch = true;
-      c_common_no_more_pch ();
-    }
-
   timevar_pop (TV_CPP);
 
   return type;
diff --git a/gcc/c-family/c-omp.c b/gcc/c-family/c-omp.c
index 1f288a6fbb2..ebe0b4e8155 100644
--- a/gcc/c-family/c-omp.c
+++ b/gcc/c-family/c-omp.c
@@ -2023,6 +2023,25 @@ c_omp_declare_simd_clauses_to_decls (tree fndecl, tree clauses)
       }
 }
 
+/* Return true for __func__ and similar function-local predefined
+   variables (which are in OpenMP predetermined shared, allowed in
+   shared/firstprivate clauses).  */
+
+bool
+c_omp_predefined_variable (tree decl)
+{
+  if (VAR_P (decl)
+      && DECL_ARTIFICIAL (decl)
+      && TREE_READONLY (decl)
+      && TREE_STATIC (decl)
+      && DECL_NAME (decl)
+      && (DECL_NAME (decl) == ridpointers[RID_C99_FUNCTION_NAME]
+	  || DECL_NAME (decl) == ridpointers[RID_FUNCTION_NAME]
+	  || DECL_NAME (decl) == ridpointers[RID_PRETTY_FUNCTION_NAME]))
+    return true;
+  return false;
+}
+
 /* True if OpenMP sharing attribute of DECL is predetermined.  */
 
 enum omp_clause_default_kind
@@ -2036,5 +2055,8 @@ c_omp_predetermined_sharing (tree decl)
       && INTEGRAL_TYPE_P (TREE_TYPE (decl)))
     return OMP_CLAUSE_DEFAULT_SHARED;
 
+  if (c_omp_predefined_variable (decl))
+    return OMP_CLAUSE_DEFAULT_SHARED;
+
   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
 }
diff --git a/gcc/c-family/c-warn.c b/gcc/c-family/c-warn.c
index 322cf98eb02..67dce9e125a 100644
--- a/gcc/c-family/c-warn.c
+++ b/gcc/c-family/c-warn.c
@@ -2784,6 +2784,8 @@ check_alignment_of_packed_member (tree type, tree field, bool rvalue)
   /* Check alignment of the data member.  */
   if (TREE_CODE (field) == FIELD_DECL
       && (DECL_PACKED (field) || TYPE_PACKED (TREE_TYPE (field)))
+      /* Ignore FIELDs not laid out yet.  */
+      && DECL_FIELD_OFFSET (field)
       && (!rvalue || TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE))
     {
       /* Check the expected alignment against the field alignment.  */
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
index 89e5b25d020..126a51e5748 100644
--- a/gcc/c/ChangeLog
+++ b/gcc/c/ChangeLog
@@ -1,3 +1,33 @@
+2019-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88203
+	* c-parser.c (c_parser_predefined_identifier): New function.
+	(c_parser_postfix_expression): Use it.
+	(c_parser_omp_variable_list): Parse predefined identifiers.
+	* c-typeck.c (c_finish_omp_clauses): Allow predefined variables
+	in shared and firstprivate clauses, even when they are predetermined
+	shared.
+
+	2019-08-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/91401
+	* c-parser.c (c_parser_omp_clause_dist_schedule): Fix up typos in the
+	check_no_duplicate_clause call.  Comment it out, instead emit a
+	warning for duplicate dist_schedule clauses.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* c-parser.c (c_parse_file): Call c_common_no_more_pch ()
+	after determining that the first token is not
+	PRAGMA_GCC_PCH_PREPROCESS.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
index f8d1fb3fa78..aafe8d1740b 100644
--- a/gcc/c/c-parser.c
+++ b/gcc/c/c-parser.c
@@ -8012,6 +8012,41 @@ enum tgmath_parm_kind
     tgmath_fixed, tgmath_real, tgmath_complex
   };
 
+/* Helper function for c_parser_postfix_expression.  Parse predefined
+   identifiers.  */
+
+static struct c_expr
+c_parser_predefined_identifier (c_parser *parser)
+{
+  location_t loc = c_parser_peek_token (parser)->location;
+  switch (c_parser_peek_token (parser)->keyword)
+    {
+    case RID_FUNCTION_NAME:
+      pedwarn (loc, OPT_Wpedantic, "ISO C does not support %qs predefined "
+	       "identifier", "__FUNCTION__");
+      break;
+    case RID_PRETTY_FUNCTION_NAME:
+      pedwarn (loc, OPT_Wpedantic, "ISO C does not support %qs predefined "
+	       "identifier", "__PRETTY_FUNCTION__");
+      break;
+    case RID_C99_FUNCTION_NAME:
+      pedwarn_c90 (loc, OPT_Wpedantic, "ISO C90 does not support "
+		   "%<__func__%> predefined identifier");
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  struct c_expr expr;
+  expr.original_code = ERROR_MARK;
+  expr.original_type = NULL;
+  expr.value = fname_decl (loc, c_parser_peek_token (parser)->keyword,
+			   c_parser_peek_token (parser)->value);
+  set_c_expr_source_range (&expr, loc, loc);
+  c_parser_consume_token (parser);
+  return expr;
+}
+
 /* Parse a postfix expression (C90 6.3.1-6.3.2, C99 6.5.1-6.5.2,
    C11 6.5.1-6.5.2).  Compound literals aren't handled here; callers have to
    call c_parser_postfix_expression_after_paren_type on encountering them.
@@ -8232,31 +8267,9 @@ c_parser_postfix_expression (c_parser *parser)
       switch (c_parser_peek_token (parser)->keyword)
 	{
 	case RID_FUNCTION_NAME:
-	  pedwarn (loc, OPT_Wpedantic,  "ISO C does not support "
-		   "%<__FUNCTION__%> predefined identifier");
-	  expr.value = fname_decl (loc,
-				   c_parser_peek_token (parser)->keyword,
-				   c_parser_peek_token (parser)->value);
-	  set_c_expr_source_range (&expr, loc, loc);
-	  c_parser_consume_token (parser);
-	  break;
 	case RID_PRETTY_FUNCTION_NAME:
-	  pedwarn (loc, OPT_Wpedantic,  "ISO C does not support "
-		   "%<__PRETTY_FUNCTION__%> predefined identifier");
-	  expr.value = fname_decl (loc,
-				   c_parser_peek_token (parser)->keyword,
-				   c_parser_peek_token (parser)->value);
-	  set_c_expr_source_range (&expr, loc, loc);
-	  c_parser_consume_token (parser);
-	  break;
 	case RID_C99_FUNCTION_NAME:
-	  pedwarn_c90 (loc, OPT_Wpedantic,  "ISO C90 does not support "
-		   "%<__func__%> predefined identifier");
-	  expr.value = fname_decl (loc,
-				   c_parser_peek_token (parser)->keyword,
-				   c_parser_peek_token (parser)->value);
-	  set_c_expr_source_range (&expr, loc, loc);
-	  c_parser_consume_token (parser);
+	  expr = c_parser_predefined_identifier (parser);
 	  break;
 	case RID_VA_ARG:
 	  {
@@ -11950,15 +11963,9 @@ c_parser_omp_variable_list (c_parser *parser,
 {
   auto_vec<c_token> tokens;
   unsigned int tokens_avail = 0;
+  bool first = true;
 
-  if (kind != OMP_CLAUSE_DEPEND
-      && (c_parser_next_token_is_not (parser, CPP_NAME)
-	  || c_parser_peek_token (parser)->id_kind != C_ID_ID))
-    c_parser_error (parser, "expected identifier");
-
-  while (kind == OMP_CLAUSE_DEPEND
-	 || (c_parser_next_token_is (parser, CPP_NAME)
-	     && c_parser_peek_token (parser)->id_kind == C_ID_ID))
+  while (1)
     {
       bool array_section_p = false;
       if (kind == OMP_CLAUSE_DEPEND)
@@ -11979,6 +11986,7 @@ c_parser_omp_variable_list (c_parser *parser,
 		break;
 
 	      c_parser_consume_token (parser);
+	      first = false;
 	      continue;
 	    }
 
@@ -12029,16 +12037,35 @@ c_parser_omp_variable_list (c_parser *parser,
 	  parser->tokens_avail = tokens.length ();
 	}
 
-      tree t = lookup_name (c_parser_peek_token (parser)->value);
+      tree t = NULL_TREE;
 
-      if (t == NULL_TREE)
+      if (c_parser_next_token_is (parser, CPP_NAME)
+	  && c_parser_peek_token (parser)->id_kind == C_ID_ID)
 	{
-	  undeclared_variable (c_parser_peek_token (parser)->location,
-			       c_parser_peek_token (parser)->value);
-	  t = error_mark_node;
-	}
+	  t = lookup_name (c_parser_peek_token (parser)->value);
 
-      c_parser_consume_token (parser);
+	  if (t == NULL_TREE)
+	    {
+	      undeclared_variable (c_parser_peek_token (parser)->location,
+	      c_parser_peek_token (parser)->value);
+	      t = error_mark_node;
+	    }
+
+	  c_parser_consume_token (parser);
+	}
+      else if (c_parser_next_token_is (parser, CPP_KEYWORD)
+	       && (c_parser_peek_token (parser)->keyword == RID_FUNCTION_NAME
+		   || (c_parser_peek_token (parser)->keyword
+		       == RID_PRETTY_FUNCTION_NAME)
+		   || (c_parser_peek_token (parser)->keyword
+		       == RID_C99_FUNCTION_NAME)))
+	t = c_parser_predefined_identifier (parser).value;
+      else
+	{
+	  if (first)
+	    c_parser_error (parser, "expected identifier");
+	  break;
+	}
 
       if (t == error_mark_node)
 	;
@@ -12176,6 +12203,7 @@ c_parser_omp_variable_list (c_parser *parser,
 	break;
 
       c_parser_consume_token (parser);
+      first = false;
     }
 
   return list;
@@ -14707,7 +14735,10 @@ c_parser_omp_clause_dist_schedule (c_parser *parser, tree list)
     c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,
 			       "expected %<,%> or %<)%>");
 
-  check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, "schedule");
+  /* check_no_duplicate_clause (list, OMP_CLAUSE_DIST_SCHEDULE,
+				"dist_schedule"); */
+  if (omp_find_clause (list, OMP_CLAUSE_DIST_SCHEDULE))
+    warning_at (loc, 0, "too many %qs clauses", "dist_schedule");
   if (t == error_mark_node)
     return list;
 
@@ -19859,6 +19890,8 @@ c_parse_file (void)
 
   if (c_parser_peek_token (&tparser)->pragma_kind == PRAGMA_GCC_PCH_PREPROCESS)
     c_parser_pragma_pch_preprocess (&tparser);
+  else
+    c_common_no_more_pch ();
 
   the_parser = ggc_alloc<c_parser> ();
   *the_parser = tparser;
diff --git a/gcc/c/c-typeck.c b/gcc/c/c-typeck.c
index 4a4eb08b73f..be12a0a605e 100644
--- a/gcc/c/c-typeck.c
+++ b/gcc/c/c-typeck.c
@@ -14713,6 +14713,13 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)
 		case OMP_CLAUSE_DEFAULT_UNSPECIFIED:
 		  break;
 		case OMP_CLAUSE_DEFAULT_SHARED:
+		  if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED
+		       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE)
+		      && c_omp_predefined_variable (t))
+		    /* The __func__ variable and similar function-local
+		       predefined variables may be listed in a shared or
+		       firstprivate clause.  */
+		    break;
 		  share_name = "shared";
 		  break;
 		case OMP_CLAUSE_DEFAULT_PRIVATE:
diff --git a/gcc/calls.c b/gcc/calls.c
index c8a42680041..56795995650 100644
--- a/gcc/calls.c
+++ b/gcc/calls.c
@@ -1971,8 +1971,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,
       /* If TYPE is a transparent union or record, pass things the way
 	 we would pass the first field of the union or record.  We have
 	 already verified that the modes are the same.  */
-      if ((TREE_CODE (type) == UNION_TYPE || TREE_CODE (type) == RECORD_TYPE)
-	   && TYPE_TRANSPARENT_AGGR (type))
+      if (RECORD_OR_UNION_TYPE_P (type) && TYPE_TRANSPARENT_AGGR (type))
 	type = TREE_TYPE (first_field (type));
 
       /* Decide where to pass this arg.
@@ -2750,6 +2749,9 @@ load_register_parameters (struct arg_data *args, int num_actuals,
 	  poly_int64 size = 0;
 	  HOST_WIDE_INT const_size = 0;
 	  rtx_insn *before_arg = get_last_insn ();
+	  tree type = TREE_TYPE (args[i].tree_value);
+	  if (RECORD_OR_UNION_TYPE_P (type) && TYPE_TRANSPARENT_AGGR (type))
+	    type = TREE_TYPE (first_field (type));
 	  /* Set non-negative if we must move a word at a time, even if
 	     just one word (e.g, partial == 4 && mode == DFmode).  Set
 	     to -1 if we just use a normal move insn.  This value can be
@@ -2762,11 +2764,11 @@ load_register_parameters (struct arg_data *args, int num_actuals,
 	      gcc_assert (partial % UNITS_PER_WORD == 0);
 	      nregs = partial / UNITS_PER_WORD;
 	    }
-	  else if (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode)
+	  else if (TYPE_MODE (type) == BLKmode)
 	    {
 	      /* Variable-sized parameters should be described by a
 		 PARALLEL instead.  */
-	      const_size = int_size_in_bytes (TREE_TYPE (args[i].tree_value));
+	      const_size = int_size_in_bytes (type);
 	      gcc_assert (const_size >= 0);
 	      nregs = (const_size + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;
 	      size = const_size;
@@ -2893,8 +2895,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,
 	  if (GET_CODE (reg) == PARALLEL)
 	    use_group_regs (call_fusage, reg);
 	  else if (nregs == -1)
-	    use_reg_mode (call_fusage, reg,
-			  TYPE_MODE (TREE_TYPE (args[i].tree_value)));
+	    use_reg_mode (call_fusage, reg, TYPE_MODE (type));
 	  else if (nregs > 0)
 	    use_regs (call_fusage, REGNO (reg), nregs);
 	}
diff --git a/gcc/cfgcleanup.c b/gcc/cfgcleanup.c
index 992912ce195..e90cc43e1f0 100644
--- a/gcc/cfgcleanup.c
+++ b/gcc/cfgcleanup.c
@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "dce.h"
 #include "dbgcnt.h"
 #include "rtl-iter.h"
+#include "regs.h"
 
 #define FORWARDER_BLOCK_P(BB) ((BB)->flags & BB_FORWARDER_BLOCK)
 
@@ -257,6 +258,10 @@ thread_jump (edge e, basic_block b)
   bool failed = false;
   reg_set_iterator rsi;
 
+  /* Jump threading may cause fixup_partitions to introduce new crossing edges,
+     which is not allowed after reload.  */
+  gcc_checking_assert (!reload_completed || !crtl->has_bb_partition);
+
   if (b->flags & BB_NONTHREADABLE_BLOCK)
     return NULL;
 
@@ -1224,6 +1229,14 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx_insn *i1, rtx_insn *i2)
 		}
 	    }
 	}
+
+      HARD_REG_SET i1_used, i2_used;
+
+      get_call_reg_set_usage (i1, &i1_used, call_used_reg_set);
+      get_call_reg_set_usage (i2, &i2_used, call_used_reg_set);
+
+      if (!hard_reg_set_equal_p (i1_used, i2_used))
+        return dir_none;
     }
 
   /* If both i1 and i2 are frame related, verify all the CFA notes
@@ -3269,10 +3282,10 @@ make_pass_jump (gcc::context *ctxt)
 
 namespace {
 
-const pass_data pass_data_postreload_jump =
+const pass_data pass_data_jump_after_combine =
 {
   RTL_PASS, /* type */
-  "postreload_jump", /* name */
+  "jump_after_combine", /* name */
   OPTGROUP_NONE, /* optinfo_flags */
   TV_JUMP, /* tv_id */
   0, /* properties_required */
@@ -3282,20 +3295,20 @@ const pass_data pass_data_postreload_jump =
   0, /* todo_flags_finish */
 };
 
-class pass_postreload_jump : public rtl_opt_pass
+class pass_jump_after_combine : public rtl_opt_pass
 {
 public:
-  pass_postreload_jump (gcc::context *ctxt)
-    : rtl_opt_pass (pass_data_postreload_jump, ctxt)
+  pass_jump_after_combine (gcc::context *ctxt)
+    : rtl_opt_pass (pass_data_jump_after_combine, ctxt)
   {}
 
   /* opt_pass methods: */
   virtual unsigned int execute (function *);
 
-}; // class pass_postreload_jump
+}; // class pass_jump_after_combine
 
 unsigned int
-pass_postreload_jump::execute (function *)
+pass_jump_after_combine::execute (function *)
 {
   cleanup_cfg (flag_thread_jumps ? CLEANUP_THREADING : 0);
   return 0;
@@ -3304,9 +3317,9 @@ pass_postreload_jump::execute (function *)
 } // anon namespace
 
 rtl_opt_pass *
-make_pass_postreload_jump (gcc::context *ctxt)
+make_pass_jump_after_combine (gcc::context *ctxt)
 {
-  return new pass_postreload_jump (ctxt);
+  return new pass_jump_after_combine (ctxt);
 }
 
 namespace {
diff --git a/gcc/cgraph.c b/gcc/cgraph.c
index db4c9c747b9..1febb6369a0 100644
--- a/gcc/cgraph.c
+++ b/gcc/cgraph.c
@@ -1779,8 +1779,6 @@ cgraph_node::release_body (bool keep_arguments)
 void
 cgraph_node::remove (void)
 {
-  cgraph_node *n;
-
   if (symtab->ipa_clones_dump_file && symtab->cloned_nodes.contains (this))
     fprintf (symtab->ipa_clones_dump_file,
 	     "Callgraph removal;%s;%d;%s;%d;%d\n", asm_name (), order,
@@ -1797,8 +1795,13 @@ cgraph_node::remove (void)
      */
   force_output = false;
   forced_by_abi = false;
-  for (n = nested; n; n = n->next_nested)
+  cgraph_node *next = nested;
+  for (cgraph_node *n = nested; n; n = next)
+  {
+    next = n->next_nested;
     n->origin = NULL;
+    n->next_nested = NULL;
+  }
   nested = NULL;
   if (origin)
     {
@@ -1852,7 +1855,7 @@ cgraph_node::remove (void)
      */
   if (symtab->state != LTO_STREAMING)
     {
-      n = cgraph_node::get (decl);
+      cgraph_node *n = cgraph_node::get (decl);
       if (!n
 	  || (!n->clones && !n->clone_of && !n->global.inlined_to
 	      && ((symtab->global_info_ready || in_lto_p)
@@ -3449,6 +3452,30 @@ cgraph_node::verify_node (void)
 	  e->aux = 0;
 	}
     }
+
+  if (nested != NULL)
+    {
+      for (cgraph_node *n = nested; n != NULL; n = n->next_nested)
+	{
+	  if (n->origin == NULL)
+	    {
+	      error ("missing origin for a node in a nested list");
+	      error_found = true;
+	    }
+	  else if (n->origin != this)
+	    {
+	      error ("origin points to a different parent");
+	      error_found = true;
+	      break;
+	    }
+	}
+    }
+  if (next_nested != NULL && origin == NULL)
+    {
+      error ("missing origin for a node in a nested list");
+      error_found = true;
+    }
+
   if (error_found)
     {
       dump (stderr);
diff --git a/gcc/common/config/s390/s390-common.c b/gcc/common/config/s390/s390-common.c
index f9c3a95f897..2e1914e3768 100644
--- a/gcc/common/config/s390/s390-common.c
+++ b/gcc/common/config/s390/s390-common.c
@@ -47,9 +47,9 @@ EXPORTED_CONST int processor_flags_table[] =
     /* z14 */    PF_IEEE_FLOAT | PF_ZARCH | PF_LONG_DISPLACEMENT
 		 | PF_EXTIMM | PF_DFP | PF_Z10 | PF_Z196 | PF_ZEC12 | PF_TX
 		 | PF_Z13 | PF_VX | PF_VXE | PF_Z14,
-    /* arch13 */ PF_IEEE_FLOAT | PF_ZARCH | PF_LONG_DISPLACEMENT
+    /* z15 */    PF_IEEE_FLOAT | PF_ZARCH | PF_LONG_DISPLACEMENT
 		 | PF_EXTIMM | PF_DFP | PF_Z10 | PF_Z196 | PF_ZEC12 | PF_TX
-		 | PF_Z13 | PF_VX | PF_VXE | PF_Z14 | PF_VXE2 | PF_ARCH13
+		 | PF_Z13 | PF_VX | PF_VXE | PF_Z14 | PF_VXE2 | PF_Z15
   };
 
 /* Change optimizations to be performed, depending on the
diff --git a/gcc/config.gcc b/gcc/config.gcc
index ddd3b8f4d9d..b2282ecdf0b 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -4700,14 +4700,12 @@ case "${target}" in
 			 echo "#undef  LINK_OS_EXTRA_SPEC32"
 			 echo "#define LINK_OS_EXTRA_SPEC32" \
 			      "\"%(link_os_new_dtags)" \
-			      "-rpath $prefix/lib -rpath $at/lib" \
-			      "-L $prefix/lib -L $at/lib\""
+			      "-rpath $prefix/lib -rpath $at/lib\""
 			 echo
 			 echo "#undef  LINK_OS_EXTRA_SPEC64"
 			 echo "#define LINK_OS_EXTRA_SPEC64" \
 			      "\"%(link_os_new_dtags)" \
-			      "-rpath $prefix/lib64 -rpath $at/lib64" \
-			      "-L $prefix/lib64 -L $at/lib64\""
+			      "-rpath $prefix/lib64 -rpath $at/lib64\""
 			 echo
 			 echo "#undef  LINK_OS_NEW_DTAGS_SPEC"
 			 echo "#define LINK_OS_NEW_DTAGS_SPEC" \
@@ -4720,7 +4718,10 @@ case "${target}" in
 			 echo "#define MD_EXEC_PREFIX \"$at/bin/\""
 			 echo
 			 echo "#undef  MD_STARTFILE_PREFIX"
-			 echo "#define MD_STARTFILE_PREFIX \"$at/lib/\"") \
+			 echo "#define MD_STARTFILE_PREFIX \"$prefix/lib/\""
+			 echo
+			 echo "#undef  MD_STARTFILE_PREFIX_1"
+			 echo "#define MD_STARTFILE_PREFIX_1 \"$at/lib/\"") \
 			    > advance-toolchain.h
 		    else
 			echo "Unknown advance-toolchain $with_advance_toolchain"
@@ -4743,7 +4744,7 @@ case "${target}" in
 		for which in arch tune; do
 			eval "val=\$with_$which"
 			case ${val} in
-			"" | native | z900 | z990 | z9-109 | z9-ec | z10 | z196 | zEC12 | z13 | z14 | arch5 | arch6 | arch7 | arch8 | arch9 | arch10 | arch11 | arch12 | arch13 )
+			"" | native | z900 | z990 | z9-109 | z9-ec | z10 | z196 | zEC12 | z13 | z14 | z15 | arch5 | arch6 | arch7 | arch8 | arch9 | arch10 | arch11 | arch12 | arch13 )
 				# OK
 				;;
 			*)
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index 6b25d9cbfae..82e9b1fbfd8 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -18162,19 +18162,21 @@ aarch64_gen_adjusted_ldpstp (rtx *operands, bool load,
   /* Sort the operands.  */
   qsort (temp_operands, 4, 2 * sizeof (rtx *), aarch64_ldrstr_offset_compare);
 
+  /* Copy the memory operands so that if we have to bail for some
+     reason the original addresses are unchanged.  */
   if (load)
     {
-      mem_1 = temp_operands[1];
-      mem_2 = temp_operands[3];
-      mem_3 = temp_operands[5];
-      mem_4 = temp_operands[7];
+      mem_1 = copy_rtx (temp_operands[1]);
+      mem_2 = copy_rtx (temp_operands[3]);
+      mem_3 = copy_rtx (temp_operands[5]);
+      mem_4 = copy_rtx (temp_operands[7]);
     }
   else
     {
-      mem_1 = temp_operands[0];
-      mem_2 = temp_operands[2];
-      mem_3 = temp_operands[4];
-      mem_4 = temp_operands[6];
+      mem_1 = copy_rtx (temp_operands[0]);
+      mem_2 = copy_rtx (temp_operands[2]);
+      mem_3 = copy_rtx (temp_operands[4]);
+      mem_4 = copy_rtx (temp_operands[6]);
       gcc_assert (code == UNKNOWN);
     }
 
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index 5a1894063a1..cc5a887d404 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -1059,8 +1059,8 @@
 	(match_operand:GPI 1 "general_operand" ""))]
   ""
   "
-    if (MEM_P (operands[0]) && CONST_INT_P (operands[1])
-	&& <MODE>mode == DImode
+    if (MEM_P (operands[0]) && !MEM_VOLATILE_P (operands[0])
+	&& CONST_INT_P (operands[1]) && <MODE>mode == DImode
 	&& aarch64_split_dimode_const_store (operands[0], operands[1]))
       DONE;
 
@@ -6304,7 +6304,7 @@
   [(match_operand:GPI 0 "register_operand")
    (match_operand:GPF 1 "register_operand")]
   "TARGET_FLOAT
-   && ((GET_MODE_SIZE (<GPF:MODE>mode) <= GET_MODE_SIZE (<GPI:MODE>mode))
+   && ((GET_MODE_BITSIZE (<GPF:MODE>mode) <= LONG_TYPE_SIZE)
    || !flag_trapping_math || flag_fp_int_builtin_inexact)"
 {
   rtx cvt = gen_reg_rtx (<GPF:MODE>mode);
diff --git a/gcc/config/aarch64/aarch64.opt b/gcc/config/aarch64/aarch64.opt
index 7719c3b6352..3c6d1cc90ad 100644
--- a/gcc/config/aarch64/aarch64.opt
+++ b/gcc/config/aarch64/aarch64.opt
@@ -119,15 +119,15 @@ EnumValue
 Enum(aarch64_tls_size) String(48) Value(48)
 
 march=
-Target RejectNegative ToLower Joined Var(aarch64_arch_string)
+Target RejectNegative Negative(march=) ToLower Joined Var(aarch64_arch_string)
 Use features of architecture ARCH.
 
 mcpu=
-Target RejectNegative ToLower Joined Var(aarch64_cpu_string)
+Target RejectNegative Negative(mcpu=) ToLower Joined Var(aarch64_cpu_string)
 Use features of and optimize for CPU.
 
 mtune=
-Target RejectNegative ToLower Joined Var(aarch64_tune_string)
+Target RejectNegative Negative(mtune=) ToLower Joined Var(aarch64_tune_string)
 Optimize for CPU.
 
 mabi=
diff --git a/gcc/config/alpha/alpha.c b/gcc/config/alpha/alpha.c
index 984540f0b53..524379d3763 100644
--- a/gcc/config/alpha/alpha.c
+++ b/gcc/config/alpha/alpha.c
@@ -8839,6 +8839,9 @@ alpha_handle_trap_shadows (void)
 		    case CODE_LABEL:
 		      goto close_shadow;
 
+		    case DEBUG_INSN:
+		      break;
+
 		    default:
 		      gcc_unreachable ();
 		    }
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 45abcd89963..91bb65130b8 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -19670,6 +19670,35 @@ arm_compute_save_core_reg_mask (void)
   return save_reg_mask;
 }
 
+/* Return a mask for the call-clobbered low registers that are unused
+   at the end of the prologue.  */
+static unsigned long
+thumb1_prologue_unused_call_clobbered_lo_regs (void)
+{
+  unsigned long mask = 0;
+
+  for (int reg = 0; reg <= LAST_LO_REGNUM; reg++)
+    if (!callee_saved_reg_p (reg)
+	&& !REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),
+			     reg))
+      mask |= 1 << reg;
+  return mask;
+}
+
+/* Similarly for the start of the epilogue.  */
+static unsigned long
+thumb1_epilogue_unused_call_clobbered_lo_regs (void)
+{
+  unsigned long mask = 0;
+
+  for (int reg = 0; reg <= LAST_LO_REGNUM; reg++)
+    if (!callee_saved_reg_p (reg)
+	&& !REGNO_REG_SET_P (df_get_live_in (EXIT_BLOCK_PTR_FOR_FN (cfun)),
+			     reg))
+      mask |= 1 << reg;
+  return mask;
+}
+
 /* Compute a bit mask of which core registers need to be
    saved on the stack for the current function.  */
 static unsigned long
@@ -19701,10 +19730,19 @@ thumb1_compute_save_core_reg_mask (void)
   if (mask & 0xff || thumb_force_lr_save ())
     mask |= (1 << LR_REGNUM);
 
-  /* Make sure we have a low work register if we need one.
-     We will need one if we are going to push a high register,
-     but we are not currently intending to push a low register.  */
+  bool call_clobbered_scratch
+    = (thumb1_prologue_unused_call_clobbered_lo_regs ()
+       && thumb1_epilogue_unused_call_clobbered_lo_regs ());
+
+  /* Make sure we have a low work register if we need one.  We will
+     need one if we are going to push a high register, but we are not
+     currently intending to push a low register.  However if both the
+     prologue and epilogue have a spare call-clobbered low register,
+     then we won't need to find an additional work register.  It does
+     not need to be the same register in the prologue and
+     epilogue.  */
   if ((mask & 0xff) == 0
+      && !call_clobbered_scratch
       && ((mask & 0x0f00) || TARGET_BACKTRACE))
     {
       /* Use thumb_find_work_register to choose which register
@@ -24930,12 +24968,7 @@ thumb1_unexpanded_epilogue (void)
       unsigned long mask = live_regs_mask & 0xff;
       int next_hi_reg;
 
-      /* The available low registers depend on the size of the value we are
-         returning.  */
-      if (size <= 12)
-	mask |=  1 << 3;
-      if (size <= 8)
-	mask |= 1 << 2;
+      mask |= thumb1_epilogue_unused_call_clobbered_lo_regs ();
 
       if (mask == 0)
 	/* Oh dear!  We have no low registers into which we can pop
@@ -24943,7 +24976,7 @@ thumb1_unexpanded_epilogue (void)
 	internal_error
 	  ("no low registers available for popping high registers");
 
-      for (next_hi_reg = 8; next_hi_reg < 13; next_hi_reg++)
+      for (next_hi_reg = 12; next_hi_reg > LAST_LO_REGNUM; next_hi_reg--)
 	if (live_regs_mask & (1 << next_hi_reg))
 	  break;
 
@@ -24951,7 +24984,7 @@ thumb1_unexpanded_epilogue (void)
 	{
 	  /* Find lo register(s) into which the high register(s) can
              be popped.  */
-	  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)
+	  for (regno = LAST_LO_REGNUM; regno >= 0; regno--)
 	    {
 	      if (mask & (1 << regno))
 		high_regs_pushed--;
@@ -24959,20 +24992,22 @@ thumb1_unexpanded_epilogue (void)
 		break;
 	    }
 
-	  mask &= (2 << regno) - 1;	/* A noop if regno == 8 */
+	  if (high_regs_pushed == 0 && regno >= 0)
+	    mask &= ~((1 << regno) - 1);
 
 	  /* Pop the values into the low register(s).  */
 	  thumb_pop (asm_out_file, mask);
 
 	  /* Move the value(s) into the high registers.  */
-	  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)
+	  for (regno = LAST_LO_REGNUM; regno >= 0; regno--)
 	    {
 	      if (mask & (1 << regno))
 		{
 		  asm_fprintf (asm_out_file, "\tmov\t%r, %r\n", next_hi_reg,
 			       regno);
 
-		  for (next_hi_reg++; next_hi_reg < 13; next_hi_reg++)
+		  for (next_hi_reg--; next_hi_reg > LAST_LO_REGNUM;
+		       next_hi_reg--)
 		    if (live_regs_mask & (1 << next_hi_reg))
 		      break;
 		}
@@ -25354,10 +25389,20 @@ thumb1_expand_prologue (void)
 	  break;
 
       /* Here we need to mask out registers used for passing arguments
-	 even if they can be pushed.  This is to avoid using them to stash the high
-	 registers.  Such kind of stash may clobber the use of arguments.  */
+	 even if they can be pushed.  This is to avoid using them to
+	 stash the high registers.  Such kind of stash may clobber the
+	 use of arguments.  */
       pushable_regs = l_mask & (~arg_regs_mask);
-      if (lr_needs_saving)
+      pushable_regs |= thumb1_prologue_unused_call_clobbered_lo_regs ();
+
+      /* Normally, LR can be used as a scratch register once it has been
+	 saved; but if the function examines its own return address then
+	 the value is still live and we need to avoid using it.  */
+      bool return_addr_live
+	= REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),
+			   LR_REGNUM);
+
+      if (lr_needs_saving || return_addr_live)
 	pushable_regs &= ~(1 << LR_REGNUM);
 
       if (pushable_regs == 0)
@@ -25398,6 +25443,11 @@ thumb1_expand_prologue (void)
 	      push_mask |= 1 << LR_REGNUM;
 	      real_regs_mask |= 1 << LR_REGNUM;
 	      lr_needs_saving = false;
+	      /* If the return address is not live at this point, we
+		 can add LR to the list of registers that we can use
+		 for pushes.  */
+	      if (!return_addr_live)
+		pushable_regs |= 1 << LR_REGNUM;
 	    }
 
 	  insn = thumb1_emit_multi_reg_push (push_mask, real_regs_mask);
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index 0aecd03891c..ae582172ab9 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -4483,62 +4483,78 @@
 ; ARMv6+ unaligned load/store instructions (used for packed structure accesses).
 
 (define_insn "unaligned_loadsi"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
-	(unspec:SI [(match_operand:SI 1 "memory_operand" "Uw,m")]
+  [(set (match_operand:SI 0 "s_register_operand" "=l,l,r")
+	(unspec:SI [(match_operand:SI 1 "memory_operand" "m,Uw,m")]
 		   UNSPEC_UNALIGNED_LOAD))]
   "unaligned_access"
-  "ldr%?\t%0, %1\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   ldr\t%0, %1\t@ unaligned
+   ldr%?\t%0, %1\t@ unaligned
+   ldr%?\t%0, %1\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "load_4")])
 
+;; The 16-bit Thumb1 variant of ldrsh requires two registers in the
+;; address (there's no immediate format).  That's tricky to support
+;; here and we don't really need this pattern for that case, so only
+;; enable for 32-bit ISAs.
 (define_insn "unaligned_loadhis"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(sign_extend:SI
 	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uh")]
 		     UNSPEC_UNALIGNED_LOAD)))]
-  "unaligned_access"
+  "unaligned_access && TARGET_32BIT"
   "ldrsh%?\t%0, %1\t@ unaligned"
   [(set_attr "predicable" "yes")
    (set_attr "type" "load_byte")])
 
 (define_insn "unaligned_loadhiu"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
+  [(set (match_operand:SI 0 "s_register_operand" "=l,l,r")
 	(zero_extend:SI
-	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uw,m")]
+	  (unspec:HI [(match_operand:HI 1 "memory_operand" "m,Uw,m")]
 		     UNSPEC_UNALIGNED_LOAD)))]
   "unaligned_access"
-  "ldrh%?\t%0, %1\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   ldrh\t%0, %1\t@ unaligned
+   ldrh%?\t%0, %1\t@ unaligned
+   ldrh%?\t%0, %1\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "load_byte")])
 
 (define_insn "unaligned_storesi"
-  [(set (match_operand:SI 0 "memory_operand" "=Uw,m")
-	(unspec:SI [(match_operand:SI 1 "s_register_operand" "l,r")]
+  [(set (match_operand:SI 0 "memory_operand" "=m,Uw,m")
+	(unspec:SI [(match_operand:SI 1 "s_register_operand" "l,l,r")]
 		   UNSPEC_UNALIGNED_STORE))]
   "unaligned_access"
-  "str%?\t%1, %0\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   str\t%1, %0\t@ unaligned
+   str%?\t%1, %0\t@ unaligned
+   str%?\t%1, %0\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "store_4")])
 
 (define_insn "unaligned_storehi"
-  [(set (match_operand:HI 0 "memory_operand" "=Uw,m")
-	(unspec:HI [(match_operand:HI 1 "s_register_operand" "l,r")]
+  [(set (match_operand:HI 0 "memory_operand" "=m,Uw,m")
+	(unspec:HI [(match_operand:HI 1 "s_register_operand" "l,l,r")]
 		   UNSPEC_UNALIGNED_STORE))]
   "unaligned_access"
-  "strh%?\t%1, %0\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   strh\t%1, %0\t@ unaligned
+   strh%?\t%1, %0\t@ unaligned
+   strh%?\t%1, %0\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "store_4")])
 
 
diff --git a/gcc/config/arm/arm.opt b/gcc/config/arm/arm.opt
index 9067d491b9c..78f3878e037 100644
--- a/gcc/config/arm/arm.opt
+++ b/gcc/config/arm/arm.opt
@@ -82,7 +82,7 @@ mapcs-stack-check
 Target Report Mask(APCS_STACK) Undocumented
 
 march=
-Target RejectNegative ToLower Joined Var(arm_arch_string)
+Target RejectNegative Negative(march=) ToLower Joined Var(arm_arch_string)
 Specify the name of the target architecture.
 
 ; Other arm_arch values are loaded from arm-tables.opt
@@ -107,7 +107,7 @@ Target Report Mask(CALLER_INTERWORKING)
 Thumb: Assume function pointers may go to non-Thumb aware code.
 
 mcpu=
-Target RejectNegative ToLower Joined Var(arm_cpu_string)
+Target RejectNegative Negative(mcpu=) ToLower Joined Var(arm_cpu_string)
 Specify the name of the target CPU.
 
 mfloat-abi=
@@ -232,7 +232,7 @@ Target Report Mask(TPCS_LEAF_FRAME)
 Thumb: Generate (leaf) stack frames even if not needed.
 
 mtune=
-Target RejectNegative ToLower Joined Var(arm_tune_string)
+Target RejectNegative Negative(mtune=) ToLower Joined Var(arm_tune_string)
 Tune code for the given processor.
 
 mprint-tune-info
diff --git a/gcc/config/arm/arm_acle.h b/gcc/config/arm/arm_acle.h
index 2c7acc698ea..6857ab1787d 100644
--- a/gcc/config/arm/arm_acle.h
+++ b/gcc/config/arm/arm_acle.h
@@ -174,8 +174,12 @@ __arm_mrrc2 (const unsigned int __coproc, const unsigned int __opc1,
 #endif /* (!__thumb__ || __thumb2__) &&  __ARM_ARCH >= 4.  */
 
 #pragma GCC push_options
-#if __ARM_ARCH >= 8
+#ifdef __ARM_FEATURE_CRC32
+#ifdef __ARM_FP
+#pragma GCC target ("arch=armv8-a+crc+simd")
+#else
 #pragma GCC target ("arch=armv8-a+crc")
+#endif
 
 __extension__ static __inline uint32_t __attribute__ ((__always_inline__))
 __crc32b (uint32_t __a, uint8_t __b)
@@ -235,7 +239,7 @@ __crc32cd (uint32_t __a, uint64_t __b)
 }
 #endif
 
-#endif /* __ARM_ARCH >= 8.  */
+#endif /* __ARM_FEATURE_CRC32  */
 #pragma GCC pop_options
 
 #ifdef __cplusplus
diff --git a/gcc/config/arm/t-multilib b/gcc/config/arm/t-multilib
index 08526302283..dc97c8f09fb 100644
--- a/gcc/config/arm/t-multilib
+++ b/gcc/config/arm/t-multilib
@@ -24,6 +24,8 @@
 # values during the configure step.  We enforce this during the
 # top-level configury.
 
+s-mlib: $(srcdir)/config/arm/t-multilib $(srcdir)/config/arm/t-aprofile $(srcdir)/config/arm/t-rmprofile
+
 MULTILIB_OPTIONS     =
 MULTILIB_DIRNAMES    =
 MULTILIB_EXCEPTIONS  =
@@ -63,6 +65,8 @@ all_early_arch		:= armv5tej armv6 armv6j armv6k armv6z armv6kz \
 v7_a_arch_variants	:= $(call all_feat_combs, mp sec)
 v7_a_nosimd_variants	:= +fp +vfpv3 +vfpv3-d16-fp16 +vfpv3-fp16 +vfpv4-d16 +vfpv4
 v7_a_simd_variants	:= +simd +neon-fp16 +neon-vfpv4
+v7_r_sp_variants	:= +fp.sp +fp.sp+idiv +vfpv3xd-fp16 +vfpv3xd-fp16+idiv
+v7_r_dp_variants	:= +fp +fp+idiv +vfpv3-d16-fp16 +vfpv3-d16-fp16+idiv
 v7ve_nosimd_variants	:= +vfpv3-d16 +vfpv3 +vfpv3-d16-fp16 +vfpv3-fp16 +fp +vfpv4
 v7ve_vfpv3_simd_variants := +neon +neon-fp16
 v7ve_vfpv4_simd_variants := +simd
@@ -86,8 +90,8 @@ SEP := $(and $(HAS_APROFILE),$(HAS_RMPROFILE),/)
 MULTILIB_OPTIONS	+= marm/mthumb
 MULTILIB_DIRNAMES	+= arm thumb
 
-MULTILIB_OPTIONS	+= march=armv5te+fp/march=armv7/march=armv7+fp/$(MULTI_ARCH_OPTS_A)$(SEP)$(MULTI_ARCH_OPTS_RM)
-MULTILIB_DIRNAMES	+= v5te v7 v7+fp $(MULTI_ARCH_DIRS_A) $(MULTI_ARCH_DIRS_RM)
+MULTILIB_OPTIONS	+= march=armv5te+fp/march=armv7/march=armv7+fp/march=armv7-r+fp.sp/$(MULTI_ARCH_OPTS_A)$(SEP)$(MULTI_ARCH_OPTS_RM)
+MULTILIB_DIRNAMES	+= v5te v7 v7+fp v7-r+fp.sp $(MULTI_ARCH_DIRS_A) $(MULTI_ARCH_DIRS_RM)
 
 MULTILIB_OPTIONS	+= mfloat-abi=soft/mfloat-abi=softfp/mfloat-abi=hard
 MULTILIB_DIRNAMES	+= nofp softfp hard
@@ -100,22 +104,31 @@ MULTILIB_REQUIRED	+= mthumb/march=armv7/mfloat-abi=soft
 MULTILIB_REQUIRED	+= mthumb/march=armv7+fp/mfloat-abi=softfp
 MULTILIB_REQUIRED	+= mthumb/march=armv7+fp/mfloat-abi=hard
 
-# Map v7-r down onto common v7 code.
+MULTILIB_REQUIRED	+= mthumb/march=armv7-r+fp.sp/mfloat-abi=softfp
+MULTILIB_REQUIRED	+= mthumb/march=armv7-r+fp.sp/mfloat-abi=hard
+
+# Map v7-r with double precision down onto common v7 code.
 MULTILIB_MATCHES	+= march?armv7=march?armv7-r
 MULTILIB_MATCHES	+= march?armv7=march?armv7-r+idiv
-MULTILIB_MATCHES	+= march?armv7+fp=march?armv7-r+fp
-MULTILIB_MATCHES	+= march?armv7+fp=march?armv7-r+fp+idiv
+MULTILIB_MATCHES	+= $(foreach ARCH, $(v7_r_dp_variants), \
+			     march?armv7+fp=march?armv7-r$(ARCH))
+
+# Map v7-r single precision variants to v7-r with single precision.
+MULTILIB_MATCHES	+= $(foreach ARCH, \
+			     $(filter-out +fp.sp, $(v7_r_sp_variants)), \
+			     march?armv7-r+fp.sp=march?armv7-r$(ARCH))
 
 MULTILIB_MATCHES	+= $(foreach ARCH, $(all_early_arch), \
 			     march?armv5te+fp=march?$(ARCH)+fp)
-# Map v8-r down onto common v7 code.
+# Map v8-r down onto common v7 code or v7-r sp.
 MULTILIB_MATCHES	+= march?armv7=march?armv8-r
 MULTILIB_MATCHES	+= $(foreach ARCH, $(v8_r_nosimd_variants), \
 			     march?armv7=march?armv8-r$(ARCH))
 MULTILIB_MATCHES	+= $(foreach ARCH,+simd +crypto, \
 			     march?armv7+fp=march?armv8-r$(ARCH) \
 			     march?armv7+fp=march?armv8-r+crc$(ARCH))
-
+MULTILIB_MATCHES	+= march?armv7-r+fp.sp=march?armv8-r+fp.sp
+MULTILIB_MATCHES	+= march?armv7-r+fp.sp=march?armv8-r+crc+fp.sp
 
 ifeq (,$(HAS_APROFILE))
 # Map all v7-a
@@ -177,7 +190,7 @@ MULTILIB_MATCHES	+= $(foreach ARCH, $(v8_5_a_simd_variants), \
 MULTILIB_REUSE		+= mthumb/march.armv7/mfloat-abi.soft=marm/march.armv7/mfloat-abi.soft
 
 MULTILIB_REUSE		+= $(foreach ABI, hard softfp, \
-			     $(foreach ARCH, armv7+fp, \
+			     $(foreach ARCH, armv7+fp armv7-r+fp\.sp, \
 			       mthumb/march.$(ARCH)/mfloat-abi.$(ABI)=marm/march.$(ARCH)/mfloat-abi.$(ABI)))
 
 # Softfp but no FP, use the soft-float libraries.
diff --git a/gcc/config/avr/avr.c b/gcc/config/avr/avr.c
index a9f72b314c2..cb4b14ae379 100644
--- a/gcc/config/avr/avr.c
+++ b/gcc/config/avr/avr.c
@@ -3797,13 +3797,14 @@ avr_out_lpm (rtx_insn *insn, rtx *op, int *plen)
           gcc_unreachable();
 
         case 1:
-          return avr_asm_len ("%4lpm %0,%a2", xop, plen, 1);
+          avr_asm_len ("%4lpm %0,%a2", xop, plen, 1);
+          break;
 
         case 2:
           if (REGNO (dest) == REG_Z)
-            return avr_asm_len ("%4lpm %5,%a2+" CR_TAB
-                                "%4lpm %B0,%a2" CR_TAB
-                                "mov %A0,%5", xop, plen, 3);
+            avr_asm_len ("%4lpm %5,%a2+" CR_TAB
+                         "%4lpm %B0,%a2" CR_TAB
+                         "mov %A0,%5", xop, plen, 3);
           else
             {
               avr_asm_len ("%4lpm %A0,%a2+" CR_TAB
@@ -3832,9 +3833,9 @@ avr_out_lpm (rtx_insn *insn, rtx *op, int *plen)
                        "%4lpm %B0,%a2+", xop, plen, 2);
 
           if (REGNO (dest) == REG_Z - 2)
-            return avr_asm_len ("%4lpm %5,%a2+" CR_TAB
-                                "%4lpm %C0,%a2" CR_TAB
-                                "mov %D0,%5", xop, plen, 3);
+            avr_asm_len ("%4lpm %5,%a2+" CR_TAB
+                         "%4lpm %C0,%a2" CR_TAB
+                         "mov %D0,%5", xop, plen, 3);
           else
             {
               avr_asm_len ("%4lpm %C0,%a2+" CR_TAB
diff --git a/gcc/config/darwin-driver.c b/gcc/config/darwin-driver.c
index 3d85f29cb3d..b3577c416bc 100644
--- a/gcc/config/darwin-driver.c
+++ b/gcc/config/darwin-driver.c
@@ -210,6 +210,28 @@ darwin_default_min_version (void)
   return new_flag;
 }
 
+/* See if we can find the sysroot from the SDKROOT environment variable.  */
+
+static const char *
+maybe_get_sysroot_from_sdkroot ()
+{
+  const char *maybe_sysroot = getenv ("SDKROOT");
+
+  /* We'll use the same rules as the clang driver, for compatibility.
+     1) The path must be absolute
+     2) Ignore "/", that is the default anyway and we do not want the
+	sysroot semantics to be applied to it.
+     3) It must exist (actually, we'll check it's readable too).  */
+
+   if (maybe_sysroot  == NULL
+       || *maybe_sysroot != '/'
+       || strlen (maybe_sysroot) == 1
+       || access (maybe_sysroot, R_OK) == -1)
+    return NULL;
+
+  return xstrndup (maybe_sysroot, strlen (maybe_sysroot));
+}
+
 /* Translate -filelist and -framework options in *DECODED_OPTIONS
    (size *DECODED_OPTIONS_COUNT) to use -Xlinker so that they are
    considered to be linker inputs in the case that no other inputs are
@@ -234,6 +256,7 @@ darwin_driver_init (unsigned int *decoded_options_count,
   bool appendM64 = false;
   const char *vers_string = NULL;
   bool seen_version_min = false;
+  bool seen_sysroot_p = false;
 
   for (i = 1; i < *decoded_options_count; i++)
     {
@@ -314,6 +337,11 @@ darwin_driver_init (unsigned int *decoded_options_count,
 	  --*decoded_options_count;
 	  break;
 
+	case OPT__sysroot_:
+	case OPT_isysroot:
+	  seen_sysroot_p = true;
+	  break;
+
 	default:
 	  break;
 	}
@@ -375,6 +403,22 @@ darwin_driver_init (unsigned int *decoded_options_count,
 		       &(*decoded_options)[*decoded_options_count - 1]);
     }
 
+  if (! seen_sysroot_p)
+    {
+      /* We will pick up an SDKROOT if we didn't specify a sysroot and treat
+	 it as overriding any configure-time --with-sysroot.  */
+       const char *sdkroot = maybe_get_sysroot_from_sdkroot ();
+       if (sdkroot)
+	{
+	  ++*decoded_options_count;
+	  *decoded_options = XRESIZEVEC (struct cl_decoded_option,
+					 *decoded_options,
+					 *decoded_options_count);
+	  generate_option (OPT__sysroot_, sdkroot, 1, CL_DRIVER,
+			   &(*decoded_options)[*decoded_options_count - 1]);
+	}
+    }
+
   /* We will need to know the OS X version we're trying to build for here
      so that we can figure out the mechanism and source for the sysroot to
      be used.  */
diff --git a/gcc/config/darwin-protos.h b/gcc/config/darwin-protos.h
index e5614b627d7..afeca81f807 100644
--- a/gcc/config/darwin-protos.h
+++ b/gcc/config/darwin-protos.h
@@ -53,8 +53,6 @@ extern void darwin_set_default_type_attributes (tree);
 
 #endif /* TREE_CODE */
 
-extern void machopic_finish (FILE *);
-
 extern int machopic_reloc_rw_mask (void);
 extern section *machopic_select_section (tree, int, unsigned HOST_WIDE_INT);
 
diff --git a/gcc/config/darwin.c b/gcc/config/darwin.c
index b9862353843..a7610829f75 100644
--- a/gcc/config/darwin.c
+++ b/gcc/config/darwin.c
@@ -75,15 +75,9 @@ along with GCC; see the file COPYING3.  If not see
    setting the second word in the .non_lazy_symbol_pointer data
    structure to symbol.  See indirect_data for the code that handles
    the extra indirection, and machopic_output_indirection and its use
-   of MACHO_SYMBOL_STATIC for the code that handles @code{static}
+   of MACHO_SYMBOL_FLAG_STATIC for the code that handles @code{static}
    symbol indirection.  */
 
-/* For darwin >= 9  (OSX 10.5) the linker is capable of making the necessary
-   branch islands and we no longer need to emit darwin stubs.
-   However, if we are generating code for earlier systems (or for use in the 
-   kernel) the stubs might still be required, and this will be set true.  */
-int darwin_emit_branch_islands = false;
-
 typedef struct GTY(()) cdtor_record {
   rtx symbol;
   int priority;		/* [con/de]structor priority */
@@ -105,6 +99,10 @@ int generating_for_darwin_version ;
    for weak or single-definition items.  */
 static bool ld_uses_coal_sects = false;
 
+/* Very old (ld_classic) linkers need a symbol to mark the start of
+   each FDE.  */
+static bool ld_needs_eh_markers = false;
+
 /* Section names.  */
 section * darwin_sections[NUM_DARWIN_SECTIONS];
 
@@ -250,7 +248,7 @@ name_needs_quotes (const char *name)
 int
 machopic_symbol_defined_p (rtx sym_ref)
 {
-  if (SYMBOL_REF_FLAGS (sym_ref) & MACHO_SYMBOL_FLAG_DEFINED)
+  if (MACHO_SYMBOL_DEFINED_P (sym_ref))
     return true;
 
   /* If a symbol references local and is not an extern to this
@@ -259,7 +257,7 @@ machopic_symbol_defined_p (rtx sym_ref)
     {
       /* If the symbol references a variable and the variable is a
 	 common symbol, then this symbol is not defined.  */
-      if (SYMBOL_REF_FLAGS (sym_ref) & MACHO_SYMBOL_FLAG_VARIABLE)
+      if (MACHO_SYMBOL_VARIABLE_P (sym_ref))
 	{
 	  tree decl = SYMBOL_REF_DECL (sym_ref);
 	  if (!decl)
@@ -455,6 +453,13 @@ typedef struct GTY ((for_user)) machopic_indirection
   bool stub_p;
   /* True iff this stub or pointer has been referenced.  */
   bool used;
+  /* True iff a non-lazy symbol pointer should be emitted into the .data
+     section, rather than the non-lazy symbol pointers section.  The cases
+     for which this occurred seem to have been unintentional, and later
+     toolchains emit all of the indirections to the 'usual' section.  We
+     are keeping this in case it is necessary to preserve compatibility with
+     older toolchains.  */
+  bool nlsp_in_data_section;
 } machopic_indirection;
 
 struct indirection_hasher : ggc_ptr_hash<machopic_indirection>
@@ -489,7 +494,7 @@ indirection_hasher::equal (machopic_indirection *s, const char *k)
 /* Return the name of the non-lazy pointer (if STUB_P is false) or
    stub (if STUB_B is true) corresponding to the given name.
 
-  If we have a situation like:
+  PR71767 - If we have a situation like:
 
 global_weak_symbol:
   ....
@@ -498,36 +503,22 @@ Lnon_weak_local:
 
   ld64 will be unable to split this into two atoms (because the "L" makes
   the second symbol 'invisible').  This means that legitimate direct accesses
-  to the second symbol will appear to be non-allowed direct accesses to an
-  atom of type weak, global which are not allowed.
-
-  To avoid this, we make the indirections have a leading 'l' (lower-case L)
-  which has a special meaning: linker can see this and use it to determine
-  atoms, but it is not placed into the final symbol table.
+  to the second symbol will appear to be direct accesses to an atom of type
+  weak, global which are not allowed.
 
-  The implementation here is somewhat heavy-handed in that it will also mark
-  indirections to the __IMPORT,__pointers section the same way which is
-  really unnecessary, since ld64 _can_ split those into atoms as they are
-  fixed size.  FIXME: determine if this is a penalty worth extra code to
-  fix.
+  To avoid this, we make any data-section indirections have a leading 'l'
+  (lower-case L) which has a special meaning: linker can see this and use
+  it to determine  atoms, but it is not placed into the final symbol table.
 
+  Symbols in the non-lazy symbol pointers section (or stubs) do not have this
+  problem because ld64 already knows the size of each entry.
 */
 
 const char *
 machopic_indirection_name (rtx sym_ref, bool stub_p)
 {
-  char *buffer;
   const char *name = XSTR (sym_ref, 0);
-  size_t namelen = strlen (name);
-  machopic_indirection *p;
-  bool needs_quotes;
-  const char *suffix;
-  char L_or_l = 'L';
-  const char *prefix = user_label_prefix;
-  const char *quote = "";
-  tree id;
-
-  id = maybe_get_identifier (name);
+  tree id = maybe_get_identifier (name);
   if (id)
     {
       tree id_orig = id;
@@ -535,43 +526,47 @@ machopic_indirection_name (rtx sym_ref, bool stub_p)
       while (IDENTIFIER_TRANSPARENT_ALIAS (id))
 	id = TREE_CHAIN (id);
       if (id != id_orig)
-	{
-	  name = IDENTIFIER_POINTER (id);
-	  namelen = strlen (name);
-	}
+	name = IDENTIFIER_POINTER (id);
     }
 
+  const char *prefix = user_label_prefix;
+  /* If we are emitting the label 'verbatim' then omit the U_L_P and count
+     the name without the leading '*'.  */
   if (name[0] == '*')
     {
       prefix = "";
       ++name;
-      --namelen;
-    }
-
-  needs_quotes = name_needs_quotes (name);
-  if (needs_quotes)
-    {
-      quote = "\"";
     }
 
-  if (stub_p)
-    suffix = STUB_SUFFIX;
-  else
-    {
-      suffix = NON_LAZY_POINTER_SUFFIX;
-      /* Let the linker see this.  */
-      L_or_l = 'l';
-    }
-
-  buffer = XALLOCAVEC (char, 2  /* strlen ("&L") or ("&l") */
-		   + strlen (prefix)
-		   + namelen
-		   + strlen (suffix)
-		   + 2 * strlen (quote)
-		   + 1 /* '\0' */);
+  /* Here we are undoing a number of causes that placed some indirections
+     (apparently erroneously) into the .data section.  Specifically, some
+     symbols that are ABI mandated indirections and some hidden symbols
+     were being placed there - which cause difficulties with later
+     versions of ld64.  Iff (after these checks) some symbol still gets an
+     indirection in the data section, we want to adjust the indirection
+     name to be linker visible to deal with PR71767 (notes above).  */
+  bool nlsp_in_data_section =
+       ! MACHO_SYMBOL_MUST_INDIRECT_P (sym_ref)
+    && ! MACHO_SYMBOL_HIDDEN_VIS_P (sym_ref)
+    && (machopic_symbol_defined_p (sym_ref) || SYMBOL_REF_LOCAL_P (sym_ref))
+    && ! indirect_data (sym_ref);
+
+  const char *suffix = stub_p ? STUB_SUFFIX : NON_LAZY_POINTER_SUFFIX;
+  /* If the indirection is in the data section, let the linker see it.  */
+  char L_or_l = (!stub_p && nlsp_in_data_section) ? 'l' : 'L';
+  /* We have mangled symbols with spaces and punctuation which typically
+     need surrounding in quotes for the assembler to consume them.  */
+  const char *quote = name_needs_quotes (name) ? "\"" : "";
+  char *buffer = XALLOCAVEC (char, 2  /* strlen ("&L") or ("&l") */
+			     + strlen (prefix)
+			     + strlen (name)
+			     + strlen (suffix)
+			     + 2 * strlen (quote)
+			     + 1 /* '\0' */);
 
   /* Construct the name of the non-lazy pointer or stub.  */
-  sprintf (buffer, "&%s%c%s%s%s%s", quote, L_or_l, prefix, name, suffix, quote);
+  sprintf (buffer, "&%s%c%s%s%s%s", quote, L_or_l, prefix, name,
+	   suffix, quote);
 
   if (!machopic_indirections)
     machopic_indirections = hash_table<indirection_hasher>::create_ggc (37);
@@ -580,10 +575,9 @@ machopic_indirection_name (rtx sym_ref, bool stub_p)
     = machopic_indirections->find_slot_with_hash (buffer,
 						  htab_hash_string (buffer),
 						  INSERT);
+  machopic_indirection *p;
   if (*slot)
-    {
-      p = *slot;
-    }
+    p = *slot;
   else
     {
       p = ggc_alloc<machopic_indirection> ();
@@ -591,6 +585,7 @@ machopic_indirection_name (rtx sym_ref, bool stub_p)
       p->ptr_name = xstrdup (buffer);
       p->stub_p = stub_p;
       p->used = false;
+      p->nlsp_in_data_section = nlsp_in_data_section;
       *slot = p;
     }
 
@@ -666,7 +661,7 @@ machopic_indirect_data_reference (rtx orig, rtx reg)
 	   /* some other cpu -- writeme!  */
 	   gcc_unreachable ();
 	}
-      else if (defined)
+      else if (defined && ! MACHO_SYMBOL_MUST_INDIRECT_P (orig))
 	{
 	  rtx offset = NULL;
 	  if (DARWIN_PPC || HAVE_lo_sum)
@@ -708,6 +703,7 @@ machopic_indirect_data_reference (rtx orig, rtx reg)
 		  machopic_indirection_name (orig, /*stub_p=*/false)));
 
       SYMBOL_REF_DATA (ptr_ref) = SYMBOL_REF_DATA (orig);
+      SYMBOL_REF_FLAGS (ptr_ref) |= MACHO_SYMBOL_FLAG_INDIRECTION;
 
       ptr_ref = gen_const_mem (Pmode, ptr_ref);
       machopic_define_symbol (ptr_ref);
@@ -790,7 +786,7 @@ machopic_indirect_data_reference (rtx orig, rtx reg)
 rtx
 machopic_indirect_call_target (rtx target)
 {
-  if (! darwin_emit_branch_islands)
+  if (! darwin_symbol_stubs)
     return target;
 
   if (GET_CODE (target) != MEM)
@@ -798,8 +794,7 @@ machopic_indirect_call_target (rtx target)
 
   if (MACHOPIC_INDIRECT
       && GET_CODE (XEXP (target, 0)) == SYMBOL_REF
-      && !(SYMBOL_REF_FLAGS (XEXP (target, 0))
-	   & MACHO_SYMBOL_FLAG_DEFINED))
+      && ! MACHO_SYMBOL_DEFINED_P (XEXP (target, 0)))
     {
       rtx sym_ref = XEXP (target, 0);
       const char *stub_name = machopic_indirection_name (sym_ref,
@@ -808,6 +803,7 @@ machopic_indirect_call_target (rtx target)
 
       XEXP (target, 0) = gen_rtx_SYMBOL_REF (mode, stub_name);
       SYMBOL_REF_DATA (XEXP (target, 0)) = SYMBOL_REF_DATA (sym_ref);
+      SYMBOL_REF_FLAGS (XEXP (target, 0)) |= MACHO_SYMBOL_FLAG_INDIRECTION;
       MEM_READONLY_P (target) = 1;
       MEM_NOTRAP_P (target) = 1;
     }
@@ -844,7 +840,7 @@ machopic_legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)
 	{
 	  if (reg == 0)
 	    {
-	      gcc_assert (!reload_in_progress);
+	      gcc_assert (!lra_in_progress);
 	      reg = gen_reg_rtx (Pmode);
 	    }
 
@@ -928,7 +924,7 @@ machopic_legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)
 	      emit_use (gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM));
 #endif
 
-	      if (reload_in_progress)
+	      if (lra_in_progress)
 		df_set_regs_ever_live (REGNO (pic), true);
 	      pic_ref = gen_rtx_PLUS (Pmode, pic,
 				      machopic_gen_offset (XEXP (orig, 0)));
@@ -952,7 +948,7 @@ machopic_legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)
 
 	      if (reg == 0)
 		{
-		  gcc_assert (!reload_in_progress);
+		  gcc_assert (!lra_in_progress);
 		  reg = gen_reg_rtx (Pmode);
 		}
 
@@ -998,7 +994,7 @@ machopic_legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)
 #if 0
 		  emit_use (pic_offset_table_rtx);
 #endif
-		  if (reload_in_progress)
+		  if (lra_in_progress)
 		    df_set_regs_ever_live (REGNO (pic), true);
 		  pic_ref = gen_rtx_PLUS (Pmode,
 					  pic,
@@ -1069,129 +1065,160 @@ machopic_legitimize_pic_address (rtx orig, machine_mode mode, rtx reg)
   return pic_ref;
 }
 
-/* Output the stub or non-lazy pointer in *SLOT, if it has been used.
-   DATA is the FILE* for assembly output.  Called from
-   htab_traverse.  */
+/* Callbacks to output the stub or non-lazy pointers.
+   Each works on the item in *SLOT,if it has been used.
+   DATA is the FILE* for assembly output.
+   Called from htab_traverses, invoked from machopic_finish().  */
 
 int
-machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)
+machopic_output_data_section_indirection (machopic_indirection **slot,
+					  FILE *asm_out_file)
 {
   machopic_indirection *p = *slot;
-  rtx symbol;
-  const char *sym_name;
-  const char *ptr_name;
 
-  if (!p->used)
+  if (!p->used || !p->nlsp_in_data_section)
     return 1;
 
-  symbol = p->symbol;
-  sym_name = XSTR (symbol, 0);
-  ptr_name = p->ptr_name;
+  rtx symbol = p->symbol;
+  /* The original symbol name.  */
+  const char *sym_name = XSTR (symbol, 0);
+  /* The name of the indirection symbol.  */
+  const char *ptr_name = p->ptr_name;
 
-  if (p->stub_p)
-    {
-      char *sym;
-      char *stub;
-      tree id;
+  switch_to_section (data_section);
+  assemble_align (GET_MODE_ALIGNMENT (Pmode));
+  assemble_label (asm_out_file, ptr_name);
+  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, sym_name),
+		    GET_MODE_SIZE (Pmode),
+		    GET_MODE_ALIGNMENT (Pmode), 1);
 
-      id = maybe_get_identifier (sym_name);
-      if (id)
-	{
-	  tree id_orig = id;
+  return 1;
+}
 
-	  while (IDENTIFIER_TRANSPARENT_ALIAS (id))
-	    id = TREE_CHAIN (id);
-	  if (id != id_orig)
-	    sym_name = IDENTIFIER_POINTER (id);
-	}
+int
+machopic_output_stub_indirection (machopic_indirection **slot,
+				  FILE *asm_out_file)
+{
+  machopic_indirection *p = *slot;
 
-      sym = XALLOCAVEC (char, strlen (sym_name) + 2);
-      if (sym_name[0] == '*' || sym_name[0] == '&')
-	strcpy (sym, sym_name + 1);
-      else if (sym_name[0] == '-' || sym_name[0] == '+')
-	strcpy (sym, sym_name);
-      else
-	sprintf (sym, "%s%s", user_label_prefix, sym_name);
+  if (!p->used || !p->stub_p)
+    return 1;
 
-      stub = XALLOCAVEC (char, strlen (ptr_name) + 2);
-      if (ptr_name[0] == '*' || ptr_name[0] == '&')
-	strcpy (stub, ptr_name + 1);
-      else
-	sprintf (stub, "%s%s", user_label_prefix, ptr_name);
+  rtx symbol = p->symbol;
+  /* The original symbol name.  */
+  const char *sym_name = XSTR (symbol, 0);
+  /* The name of the stub symbol.  */
+  const char *ptr_name = p->ptr_name;
 
-      machopic_output_stub (asm_out_file, sym, stub);
-    }
-  else if (! indirect_data (symbol)
-	   && (machopic_symbol_defined_p (symbol)
-	       || SYMBOL_REF_LOCAL_P (symbol)))
+  tree id = maybe_get_identifier (sym_name);
+  if (id)
     {
-      switch_to_section (data_section);
-      assemble_align (GET_MODE_ALIGNMENT (Pmode));
-      assemble_label (asm_out_file, ptr_name);
-      assemble_integer (gen_rtx_SYMBOL_REF (Pmode, sym_name),
-			GET_MODE_SIZE (Pmode),
-			GET_MODE_ALIGNMENT (Pmode), 1);
+      tree id_orig = id;
+
+      while (IDENTIFIER_TRANSPARENT_ALIAS (id))
+	id = TREE_CHAIN (id);
+      if (id != id_orig)
+	sym_name = IDENTIFIER_POINTER (id);
     }
+
+  char *sym = XALLOCAVEC (char, strlen (sym_name) + 2);
+  if (sym_name[0] == '*' || sym_name[0] == '&')
+    strcpy (sym, sym_name + 1);
+  else if (sym_name[0] == '-' || sym_name[0] == '+')
+    strcpy (sym, sym_name);
   else
-    {
-      rtx init = const0_rtx;
+    sprintf (sym, "%s%s", user_label_prefix, sym_name);
+
+  char *stub = XALLOCAVEC (char, strlen (ptr_name) + 2);
+  if (ptr_name[0] == '*' || ptr_name[0] == '&')
+    strcpy (stub, ptr_name + 1);
+  else
+    sprintf (stub, "%s%s", user_label_prefix, ptr_name);
 
-      switch_to_section (darwin_sections[machopic_nl_symbol_ptr_section]);
+  machopic_output_stub (asm_out_file, sym, stub);
 
-      /* Mach-O symbols are passed around in code through indirect
-	 references and the original symbol_ref hasn't passed through
-	 the generic handling and reference-catching in
-	 output_operand, so we need to manually mark weak references
-	 as such.  */
-      if (SYMBOL_REF_WEAK (symbol))
+  return 1;
+}
+
+int
+machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)
+{
+  machopic_indirection *p = *slot;
+
+  if (!p->used || p->stub_p || p->nlsp_in_data_section)
+    return 1;
+
+  rtx symbol = p->symbol;
+  /* The original symbol name.  */
+  const char *sym_name = XSTR (symbol, 0);
+  /* The nonlazy-stub symbol name.  */
+  const char *ptr_name = p->ptr_name;
+
+  switch_to_section (darwin_sections[machopic_nl_symbol_ptr_section]);
+
+  /* Mach-O symbols are passed around in code through indirect references and
+     the original symbol_ref hasn't passed through the generic handling and
+     reference-catching in output_operand, so we need to manually mark weak
+     references as such.  */
+
+  if (SYMBOL_REF_WEAK (symbol))
+    {
+      tree decl = SYMBOL_REF_DECL (symbol);
+      gcc_checking_assert (DECL_P (decl));
+
+      if (decl != NULL_TREE
+	  && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)
+	  /* Handle only actual external-only definitions, not
+	     e.g. extern inline code or variables for which
+	     storage has been allocated.  */
+	  && !TREE_STATIC (decl))
 	{
-	  tree decl = SYMBOL_REF_DECL (symbol);
-	  gcc_assert (DECL_P (decl));
-
-	  if (decl != NULL_TREE
-	      && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)
-	      /* Handle only actual external-only definitions, not
-		 e.g. extern inline code or variables for which
-		 storage has been allocated.  */
-	      && !TREE_STATIC (decl))
-	    {
-	      fputs ("\t.weak_reference ", asm_out_file);
-	      assemble_name (asm_out_file, sym_name);
-	      fputc ('\n', asm_out_file);
-	    }
+	  fputs ("\t.weak_reference ", asm_out_file);
+	  assemble_name (asm_out_file, sym_name);
+	  fputc ('\n', asm_out_file);
 	}
+    }
 
-      assemble_name (asm_out_file, ptr_name);
-      fprintf (asm_out_file, ":\n");
+  assemble_name (asm_out_file, ptr_name);
+  fprintf (asm_out_file, ":\n");
 
-      fprintf (asm_out_file, "\t.indirect_symbol ");
-      assemble_name (asm_out_file, sym_name);
-      fprintf (asm_out_file, "\n");
+  fprintf (asm_out_file, "\t.indirect_symbol ");
+  assemble_name (asm_out_file, sym_name);
+  fprintf (asm_out_file, "\n");
 
-      /* Variables that are marked with MACHO_SYMBOL_STATIC need to
-	 have their symbol name instead of 0 in the second entry of
-	 the non-lazy symbol pointer data structure when they are
-	 defined.  This allows the runtime to rebind newer instances
-	 of the translation unit with the original instance of the
-	 symbol.  */
+  /* Variables that are marked with MACHO_SYMBOL_FLAG_STATIC need to
+     have their symbol name instead of 0 in the second entry of
+     the non-lazy symbol pointer data structure when they are
+     defined.  This allows the runtime to rebind newer instances
+     of the translation unit with the original instance of the
+     symbol.  */
 
-      if ((SYMBOL_REF_FLAGS (symbol) & MACHO_SYMBOL_STATIC)
-	  && machopic_symbol_defined_p (symbol))
-	init = gen_rtx_SYMBOL_REF (Pmode, sym_name);
+  rtx init = const0_rtx;
+  if (MACHO_SYMBOL_STATIC_P (symbol) && machopic_symbol_defined_p (symbol))
+    init = gen_rtx_SYMBOL_REF (Pmode, sym_name);
 
-      assemble_integer (init, GET_MODE_SIZE (Pmode),
-			GET_MODE_ALIGNMENT (Pmode), 1);
-    }
+  assemble_integer (init, GET_MODE_SIZE (Pmode),
+		    GET_MODE_ALIGNMENT (Pmode), 1);
 
   return 1;
 }
 
-void
+static void
 machopic_finish (FILE *asm_out_file)
 {
-  if (machopic_indirections)
-    machopic_indirections
-      ->traverse_noresize<FILE *, machopic_output_indirection> (asm_out_file);
+  if (!machopic_indirections)
+    return;
+
+  /* First output an symbol indirections that have been placed into .data
+     (we don't expect these now).  */
+  machopic_indirections->traverse_noresize
+    <FILE *, machopic_output_data_section_indirection> (asm_out_file);
+
+  machopic_indirections->traverse_noresize
+    <FILE *, machopic_output_stub_indirection> (asm_out_file);
+
+  machopic_indirections->traverse_noresize
+    <FILE *, machopic_output_indirection> (asm_out_file);
 }
 
 int
@@ -1206,25 +1233,51 @@ machopic_operand_p (rtx op)
 	    && XINT (XEXP (op, 0), 1) == UNSPEC_MACHOPIC_OFFSET);
 }
 
-/* This function records whether a given name corresponds to a defined
-   or undefined function or variable, for machopic_classify_ident to
-   use later.  */
+/* This function:
+   computes and caches a series of flags that characterise the symbol's
+   properties that affect Mach-O code gen (including accidental cases
+   from older toolchains).
+
+   TODO:
+   Here we also need to do enough analysis to determine if a symbol's
+   name needs to be made linker-visible.  This is more tricky - since
+   it depends on whether we've previously seen a global weak definition
+   in the same section.
+   */
 
 void
-darwin_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)
+darwin_encode_section_info (tree decl, rtx rtl, int first)
 {
-  rtx sym_ref;
+  /* Careful not to prod global register variables.  */
+  if (!MEM_P (rtl))
+    return;
 
-  /* Do the standard encoding things first.  */
+  /* Do the standard encoding things first; this sets:
+     SYMBOL_FLAG_FUNCTION,
+     SYMBOL_FLAG_LOCAL, (binds_local_p)
+     TLS_MODEL, SYMBOL_FLAG_SMALL
+     SYMBOL_FLAG_EXTERNAL.  */
   default_encode_section_info (decl, rtl, first);
 
-  if (TREE_CODE (decl) != FUNCTION_DECL && TREE_CODE (decl) != VAR_DECL)
+  if (! VAR_OR_FUNCTION_DECL_P (decl))
     return;
 
-  sym_ref = XEXP (rtl, 0);
-  if (TREE_CODE (decl) == VAR_DECL)
+  rtx sym_ref = XEXP (rtl, 0);
+  if (VAR_P (decl))
     SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_VARIABLE;
 
+  /* Only really common if there's no initialiser.  */
+  bool really_common_p = (DECL_COMMON (decl)
+			  && (DECL_INITIAL (decl) == NULL
+			      || (!in_lto_p
+				  && DECL_INITIAL (decl) == error_mark_node)));
+
+  /* For Darwin, if we have specified visibility and it's not the default
+     that's counted 'hidden'.  */
+  if (DECL_VISIBILITY_SPECIFIED (decl)
+      && DECL_VISIBILITY (decl) != VISIBILITY_DEFAULT)
+    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_HIDDEN_VIS;
+
   if (!DECL_EXTERNAL (decl)
       && (!TREE_PUBLIC (decl) || !DECL_WEAK (decl))
       && ! lookup_attribute ("weakref", DECL_ATTRIBUTES (decl))
@@ -1235,7 +1288,13 @@ darwin_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)
     SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_DEFINED;
 
   if (! TREE_PUBLIC (decl))
-    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_STATIC;
+    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_STATIC;
+
+  /* Short cut check for Darwin 'must indirect' rules.  */
+  if (really_common_p
+      || (DECL_WEAK (decl) && ! MACHO_SYMBOL_HIDDEN_VIS_P (sym_ref))
+      || lookup_attribute ("weakref", DECL_ATTRIBUTES (decl)))
+     SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_MUST_INDIRECT;
 }
 
 void
@@ -1252,12 +1311,13 @@ darwin_mark_decl_preserved (const char *name)
 }
 
 static section *
-darwin_rodata_section (int use_coal, bool zsize)
+darwin_rodata_section (int use_coal, bool zsize, int reloc)
 {
   return (use_coal
 	  ? darwin_sections[const_coal_section]
 	  : (zsize ? darwin_sections[zobj_const_section]
-		   : darwin_sections[const_section]));
+		   : reloc ? darwin_sections[const_data_section]
+			   : darwin_sections[const_section]));
 }
 
 static section *
@@ -1550,7 +1610,7 @@ machopic_select_section (tree decl,
 
     case SECCAT_RODATA:
     case SECCAT_SRODATA:
-      base_section = darwin_rodata_section (use_coal, zsize);
+      base_section = darwin_rodata_section (use_coal, zsize, reloc);
       break;
 
     case SECCAT_RODATA_MERGE_STR:
@@ -2086,11 +2146,11 @@ darwin_emit_unwind_label (FILE *file, tree decl, int for_eh, int empty)
   static int invok_count = 0;
   static tree last_fun_decl = NULL_TREE;
   
-  /* We use the linker to emit the .eh labels for Darwin 9 and above.  */
-  if (! for_eh || generating_for_darwin_version >= 9)
+  /* Modern linkers can produce distinct FDEs without compiler support.  */
+  if (! for_eh || ! ld_needs_eh_markers)
     return;
 
-  /* FIXME: This only works when the eh for all sections of a function is 
+  /* FIXME: This only works when the eh for all sections of a function are
      emitted at the same time.  If that changes, we would need to use a lookup
      table of some form to determine what to do.  Also, we should emit the
      unadorned label for the partition containing the public label for a
@@ -3148,17 +3208,19 @@ darwin_override_options (void)
 				: (generating_for_darwin_version >= 9) ? 1
 								       : 0);
 
-  /* Objective-C family ABI 2 is only valid for next/m64 at present.  */
   if (global_options_set.x_flag_objc_abi && flag_next_runtime)
     {
-      if (TARGET_64BIT && global_options.x_flag_objc_abi < 2)
-	error_at (UNKNOWN_LOCATION, "%<-fobjc-abi-version%> >= 2 must be"
-				    " used for %<-m64%> targets with"
-				    " %<-fnext-runtime%>");
-      if (!TARGET_64BIT && global_options.x_flag_objc_abi >= 2)
-	error_at (UNKNOWN_LOCATION, "%<-fobjc-abi-version%> >= 2 is not"
-				    " supported on %<-m32%> targets with"
-				    " %<-fnext-runtime%>");
+      if (TARGET_64BIT && global_options.x_flag_objc_abi != 2)
+	/* The Objective-C family ABI 2 is the only valid version NeXT/m64.  */
+	error_at (UNKNOWN_LOCATION,
+		  "%<-fobjc-abi-version%> 2 must be used for 64 bit targets"
+		  " with %<-fnext-runtime%>");
+      else if (!TARGET_64BIT && global_options.x_flag_objc_abi >= 2)
+	/* ABI versions 0 and 1 are the only valid versions NeXT/m32.  */
+	error_at (UNKNOWN_LOCATION,
+		  "%<-fobjc-abi-version%> %d is not supported for 32 bit"
+		  " targets with %<-fnext-runtime%>",
+		  global_options.x_flag_objc_abi);
     }
 
   /* Don't emit DWARF3/4 unless specifically selected.  This is a 
@@ -3261,11 +3323,44 @@ darwin_override_options (void)
       flag_pic = 2;
     }
 
-  /* It is assumed that branch island stubs are needed for earlier systems.  */
-  if (generating_for_darwin_version < 9)
-    darwin_emit_branch_islands = true;
-  else
-    emit_aligned_common = true; /* Later systems can support aligned common.  */
+  /* Linkers >= ld64-62.1 (at least) are capable of making the necessary PIC
+     indirections and we no longer need to emit pic symbol stubs.
+     However, if we are generating code for earlier ones (or for use in the
+     kernel) the stubs might still be required, and this will be set true.
+     If the user sets it on or off - then that takes precedence.
+
+     Linkers that don't need stubs, don't need the EH symbol markers either.
+  */
+
+  if (!global_options_set.x_darwin_symbol_stubs)
+    {
+      if (darwin_target_linker)
+	{
+	  if (strverscmp (darwin_target_linker, MIN_LD64_OMIT_STUBS) < 0)
+	    {
+	      darwin_symbol_stubs = true;
+	      ld_needs_eh_markers = true;
+	    }
+	}
+      else if (generating_for_darwin_version < 9)
+	{
+	  /* If we don't know the linker version and we're targeting an old
+	     system, we know no better than to assume the use of an earlier
+	     linker.  */
+	  darwin_symbol_stubs = true;
+	  ld_needs_eh_markers = true;
+	}
+    }
+  else if (DARWIN_X86 && darwin_symbol_stubs && TARGET_64BIT)
+    {
+      inform (input_location,
+	      "%<-msymbol-stubs%> is not required for 64b code (ignored)");
+      darwin_symbol_stubs = false;
+    }
+
+  if (generating_for_darwin_version >= 9)
+    /* Later systems can support aligned common.  */
+    emit_aligned_common = true;
 
   /* The c_dialect...() macros are not available to us here.  */
   darwin_running_cxx = (strstr (lang_hooks.name, "C++") != 0);
diff --git a/gcc/config/darwin.h b/gcc/config/darwin.h
index 0e253cb0dfa..be261e73a7b 100644
--- a/gcc/config/darwin.h
+++ b/gcc/config/darwin.h
@@ -126,6 +126,24 @@ extern GTY(()) int darwin_ms_struct;
   "%{gsplit-dwarf:%ngsplit-dwarf is not supported on this platform} \
      %<gsplit-dwarf"
 
+#if LD64_HAS_EXPORT_DYNAMIC
+#define DARWIN_RDYNAMIC "%{rdynamic:-export_dynamic}"
+#else
+#define DARWIN_RDYNAMIC "%{rdynamic:%nrdynamic is not supported}"
+#endif
+
+/* FIXME: we should check that the linker supports the -pie and -no_pie.
+   options.  */
+#define DARWIN_PIE_SPEC \
+"%{pie|fpie|fPIE:\
+   %{mdynamic-no-pic: \
+     %n'-mdynamic-no-pic' overrides '-pie', '-fpie' or '-fPIE'; \
+     :%:version-compare(>= 10.5 mmacosx-version-min= -pie) }} "
+
+#define DARWIN_NOPIE_SPEC \
+"%{no-pie|fno-pie|fno-PIE: \
+   %:version-compare(>= 10.7 mmacosx-version-min= -no_pie) }"
+
 #define DARWIN_CC1_SPEC							\
   "%{findirect-virtual-calls: -fapple-kext} %<findirect-virtual-calls " \
   "%{fterminated-vtables: -fapple-kext} %<fterminated-vtables "		\
@@ -156,20 +174,31 @@ extern GTY(()) int darwin_ms_struct;
 #define CPP_SPEC "%{static:%{!dynamic:-D__STATIC__}}%{!static:-D__DYNAMIC__}" \
 	" %{pthread:-D_REENTRANT}"
 
-/* This is mostly a clone of the standard LINK_COMMAND_SPEC, plus
-   precomp, libtool, and fat build additions.
+/* This is a fix for PR41260 by passing -no_compact_unwind on darwin10 and
+   later until the assembler, linker and libunwind are able to deal with the
+   output from GCC.
+
+   FIXME: we should check that the linker supports the option.
+*/
+
+#define DARWIN_NOCOMPACT_UNWIND \
+" %:version-compare(>= 10.6 mmacosx-version-min= -no_compact_unwind) "
+
+/* In Darwin linker specs we can put -lcrt0.o and ld will search the library
+   path for crt0.o or -lcrtx.a and it will search for for libcrtx.a.  As for
+   other ports, we can also put xxx.{o,a}%s and get the appropriate complete
+   startfile absolute directory.  This latter point is important when we want
+   to override ld's rule of .dylib being found ahead of .a and the user wants
+   the convenience library to be linked.  */
+
+/* The LINK_COMMAND spec is mostly a clone of the standard LINK_COMMAND_SPEC,
+   plus precomp, libtool, and fat build additions.
 
    In general, random Darwin linker flags should go into LINK_SPEC
    instead of LINK_COMMAND_SPEC.  The command spec is better for
    specifying the handling of options understood by generic Unix
    linkers, and for positional arguments like libraries.  */
 
-#if LD64_HAS_EXPORT_DYNAMIC
-#define DARWIN_EXPORT_DYNAMIC " %{rdynamic:-export_dynamic}"
-#else
-#define DARWIN_EXPORT_DYNAMIC " %{rdynamic: %nrdynamic is not supported}"
-#endif
-
 #define LINK_COMMAND_SPEC_A \
    "%{!fdump=*:%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
     %(linker)" \
@@ -190,10 +219,14 @@ extern GTY(()) int darwin_ms_struct;
       %{%:sanitize(address): -lasan } \
       %{%:sanitize(undefined): -lubsan } \
       %(link_ssp) \
-      " DARWIN_EXPORT_DYNAMIC " %<rdynamic \
       %(link_gcc_c_sequence) \
     }}}\
-    %{!nostdlib:%{!r:%{!nostartfiles:%E}}} %{T*} %{F*} }}}}}}}"
+    %{!nostdlib:%{!r:%{!nostartfiles:%E}}} %{T*} %{F*} "\
+    DARWIN_PIE_SPEC \
+    DARWIN_NOPIE_SPEC \
+    DARWIN_RDYNAMIC \
+    DARWIN_NOCOMPACT_UNWIND \
+    "}}}}}}} %<pie %<no-pie %<rdynamic "
 
 #define DSYMUTIL "\ndsymutil"
 
@@ -230,8 +263,6 @@ extern GTY(()) int darwin_ms_struct;
 #define STANDARD_STARTFILE_PREFIX_1 ""
 #define STANDARD_STARTFILE_PREFIX_2 ""
 
-#define DARWIN_PIE_SPEC "%{fpie|pie|fPIE:}"
-
 /* Please keep the random linker options in alphabetical order (modulo
    'Z' and 'no' prefixes). Note that options taking arguments may appear
    multiple times on a command line with different arguments each time,
@@ -295,7 +326,6 @@ extern GTY(()) int darwin_ms_struct;
      %:version-compare(< 10.5 mmacosx-version-min= -multiply_defined) \
      %:version-compare(< 10.5 mmacosx-version-min= suppress)}} \
    %{Zmultiplydefinedunused*:-multiply_defined_unused %*} \
-   " DARWIN_PIE_SPEC " \
    %{prebind} %{noprebind} %{nofixprebinding} %{prebind_all_twolevel_modules} \
    %{read_only_relocs} \
    %{sectcreate*} %{sectorder*} %{seg1addr*} %{segprot*} \
@@ -327,43 +357,42 @@ extern GTY(()) int darwin_ms_struct;
 
 /* Support -mmacosx-version-min by supplying different (stub) libgcc_s.dylib
    libraries to link against, and by not linking against libgcc_s on
-   earlier-than-10.3.9.
+   earlier-than-10.3.9.  If we need exceptions, prior to 10.3.9, then we have
+   to link the static eh lib, since there's no shared version on the system.
 
-   Note that by default, -lgcc_eh is not linked against!  This is
-   because in a future version of Darwin the EH frame information may
-   be in a new format, or the fallback routine might be changed; if
-   you want to explicitly link against the static version of those
-   routines, because you know you don't need to unwind through system
-   libraries, you need to explicitly say -static-libgcc.
+   Note that by default, except as above, -lgcc_eh is not linked against.
+   This is because,in general, we need to unwind through system libraries that
+   are linked with the shared unwinder in libunwind (or libgcc_s for 10.4/5).
 
-   If it is linked against, it has to be before -lgcc, because it may
+   The static version of the current libgcc unwinder (which differs from the
+   implementation in libunwind.dylib on systems Darwin10 [10.6]+) can be used
+   by specifying -static-libgcc.
+
+   If libgcc_eh is linked against, it has to be before -lgcc, because it might
    need symbols from -lgcc.  */
+
 #undef REAL_LIBGCC_SPEC
 #define REAL_LIBGCC_SPEC						   \
    "%{static-libgcc|static: -lgcc_eh -lgcc;				   \
-      shared-libgcc|fexceptions|fgnu-runtime:				   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)	   \
+      shared-libgcc|fexceptions|fobjc-exceptions|fgnu-runtime:		   \
+       %:version-compare(!> 10.3.9 mmacosx-version-min= -lgcc_eh)	   \
+       %:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
        %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_ext.10.4) \
        %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
        -lgcc ;								   \
       :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
        %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_ext.10.4) \
        %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
        -lgcc }"
 
-/* We specify crt0.o as -lcrt0.o so that ld will search the library path.
-
-   crt3.o provides __cxa_atexit on systems that don't have it.  Since
-   it's only used with C++, which requires passing -shared-libgcc, key
-   off that to avoid unnecessarily adding a destructor to every
-   powerpc program built.  */
+/* We specify crt0.o as -lcrt0.o so that ld will search the library path.  */
 
 #undef  STARTFILE_SPEC
 #define STARTFILE_SPEC							    \
-  "%{Zdynamiclib: %(darwin_dylib1) %{fgnu-tm: -lcrttms.o}}		    \
-   %{!Zdynamiclib:%{Zbundle:%{!static:					    \
+"%{Zdynamiclib: %(darwin_dylib1) %{fgnu-tm: -lcrttms.o}}		    \
+ %{!Zdynamiclib:%{Zbundle:%{!static:					    \
 	%:version-compare(< 10.6 mmacosx-version-min= -lbundle1.o)	    \
 	%{fgnu-tm: -lcrttms.o}}}					    \
      %{!Zbundle:%{pg:%{static:-lgcrt0.o}				    \
@@ -377,7 +406,7 @@ extern GTY(()) int darwin_ms_struct;
                                 %{!object:%{preload:-lcrt0.o}		    \
                                   %{!preload: %(darwin_crt1)		    \
 					      %(darwin_crt2)}}}}}}	    \
-  %{shared-libgcc:%:version-compare(< 10.5 mmacosx-version-min= crt3.o%s)}"
+ %(darwin_crt3)"
 
 /* We want a destructor last in the list.  */
 #define TM_DESTRUCTOR "%{fgnu-tm: -lcrttme.o}"
@@ -385,18 +414,30 @@ extern GTY(()) int darwin_ms_struct;
 
 #define DARWIN_EXTRA_SPECS						\
   { "darwin_crt1", DARWIN_CRT1_SPEC },					\
+  { "darwin_crt2", DARWIN_CRT2_SPEC },					\
+  { "darwin_crt3", DARWIN_CRT3_SPEC },					\
   { "darwin_dylib1", DARWIN_DYLIB1_SPEC },
 
-#define DARWIN_DYLIB1_SPEC						\
-  "%:version-compare(!> 10.5 mmacosx-version-min= -ldylib1.o)		\
-   %:version-compare(>< 10.5 10.6 mmacosx-version-min= -ldylib1.10.5.o)"
-
 #define DARWIN_CRT1_SPEC						\
   "%:version-compare(!> 10.5 mmacosx-version-min= -lcrt1.o)		\
    %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lcrt1.10.5.o)	\
    %:version-compare(>< 10.6 10.8 mmacosx-version-min= -lcrt1.10.6.o)	\
    %{fgnu-tm: -lcrttms.o}"
 
+#define DARWIN_CRT2_SPEC ""
+
+/* crt3.o provides __cxa_atexit on systems that don't have it (and a fix
+   up for faulty versions on 10.4).  Since it's only used with C++, which
+   requires passing -shared-libgcc, key off that to avoid unnecessarily
+   adding a destructor to every program built for 10.4 or earlier.  */
+
+#define DARWIN_CRT3_SPEC \
+"%{shared-libgcc:%:version-compare(< 10.5 mmacosx-version-min= crt3.o%s)}"
+
+#define DARWIN_DYLIB1_SPEC						\
+  "%:version-compare(!> 10.5 mmacosx-version-min= -ldylib1.o)		\
+   %:version-compare(>< 10.5 10.6 mmacosx-version-min= -ldylib1.10.5.o)"
+
 #ifdef HAVE_AS_MMACOSX_VERSION_MIN_OPTION
 /* Emit macosx version (but only major).  */
 #define ASM_MMACOSX_VERSION_MIN_SPEC \
@@ -762,21 +803,52 @@ extern GTY(()) section * darwin_sections[NUM_DARWIN_SECTIONS];
 #undef TARGET_ASM_MARK_DECL_PRESERVED
 #define TARGET_ASM_MARK_DECL_PRESERVED darwin_mark_decl_preserved
 
-/* Set on a symbol with SYMBOL_FLAG_FUNCTION or
-   MACHO_SYMBOL_FLAG_VARIABLE to indicate that the function or
-   variable has been defined in this translation unit.
-   When porting Mach-O to new architectures you need to make
-   sure these aren't clobbered by the backend.  */
+/* Any port using this header needs to define the first available
+   subtarget symbol bit: SYMBOL_FLAG_SUBT_DEP.  */
 
-#define MACHO_SYMBOL_FLAG_VARIABLE (SYMBOL_FLAG_MACH_DEP)
-#define MACHO_SYMBOL_FLAG_DEFINED ((SYMBOL_FLAG_MACH_DEP) << 1)
+/* Is a variable. */
+#define MACHO_SYMBOL_FLAG_VARIABLE (SYMBOL_FLAG_SUBT_DEP)
+#define MACHO_SYMBOL_VARIABLE_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_VARIABLE) != 0)
+
+/* Set on a symbol that must be indirected, even when there is a
+   definition in the TU.  The ABI mandates that common symbols are so
+   indirected, as are weak.  If 'fix-and-continue' is operational then
+   data symbols might also be.  */
+
+#define MACHO_SYMBOL_FLAG_MUST_INDIRECT ((SYMBOL_FLAG_SUBT_DEP) << 1)
+#define MACHO_SYMBOL_MUST_INDIRECT_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_MUST_INDIRECT) != 0)
+
+/* Set on a symbol with SYMBOL_FLAG_FUNCTION or MACHO_SYMBOL_FLAG_VARIABLE
+   to indicate that the function or variable is considered defined in this
+   translation unit.  */
+
+#define MACHO_SYMBOL_FLAG_DEFINED ((SYMBOL_FLAG_SUBT_DEP) << 2)
+#define MACHO_SYMBOL_DEFINED_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_DEFINED) != 0)
+
+/* Set on a symbol that has specified non-default visibility.  */
+
+#define MACHO_SYMBOL_FLAG_HIDDEN_VIS ((SYMBOL_FLAG_SUBT_DEP) << 3)
+#define MACHO_SYMBOL_HIDDEN_VIS_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_HIDDEN_VIS) != 0)
+
+/* Set on a symbol that is a pic stub or symbol indirection (i.e. the
+   L_xxxxx${stub,non_lazy_ptr,lazy_ptr}.  */
+
+#define MACHO_SYMBOL_FLAG_INDIRECTION ((SYMBOL_FLAG_SUBT_DEP) << 5)
+#define MACHO_SYMBOL_INDIRECTION_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_INDIRECTION) != 0)
 
 /* Set on a symbol to indicate when fix-and-continue style code
    generation is being used and the symbol refers to a static symbol
    that should be rebound from new instances of a translation unit to
    the original instance of the data.  */
 
-#define MACHO_SYMBOL_STATIC ((SYMBOL_FLAG_MACH_DEP) << 2)
+#define MACHO_SYMBOL_FLAG_STATIC ((SYMBOL_FLAG_SUBT_DEP) << 6)
+#define MACHO_SYMBOL_STATIC_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_STATIC) != 0)
 
 /* Symbolic names for various things we might know about a symbol.  */
 
@@ -969,8 +1041,12 @@ extern void darwin_driver_init (unsigned int *,struct cl_decoded_option **);
    _tested_ version known to support this so far.  */
 #define MIN_LD64_NO_COAL_SECTS "236.4"
 
+/* From at least version 62.1, ld64 can build symbol indirection stubs as
+   needed, and there is no need for the compiler to emit them.  */
+#define MIN_LD64_OMIT_STUBS "85.2"
+
 #ifndef LD64_VERSION
-#define LD64_VERSION "85.2"
+#define LD64_VERSION "62.1"
 #else
 #define DEF_LD64 LD64_VERSION
 #endif
diff --git a/gcc/config/darwin.opt b/gcc/config/darwin.opt
index 22667def0a1..7f5616cbe07 100644
--- a/gcc/config/darwin.opt
+++ b/gcc/config/darwin.opt
@@ -18,240 +18,382 @@
 ; along with GCC; see the file COPYING3.  If not see
 ; <http://www.gnu.org/licenses/>.
 
-; Various linker options have a -Z added so that they can get to specs
-; processing without interference.  Note that an option name with a
-; prefix that matches another option name, that also takes an
-; argument, being mapped to a -Z linker option, needs to be modified
-; so the prefix is different, otherwise a '*' after the shorter option
-; will match with the longer one.
+; We have a lot of Driver options, many of which are obsolete or very very
+; rarely used so, to keep this file easier to manage:
+
+; Please place all Non-driver options first (in alphabetical order), followed
+; by Driver-only options.
+
+; Non-driver options.
+
+dependency-file
+C ObjC C++ ObjC++ Separate Alias(MF) MissingArgError(missing filename after %qs)
+
+fapple-kext
+Target Report C++ Var(flag_apple_kext)
+Generate code for darwin loadable kernel extensions.
+
+iframework
+Target RejectNegative C ObjC C++ ObjC++ Joined Separate
+-iframework <dir>	Add <dir> to the end of the system framework include path.
+
+mconstant-cfstrings
+Target Report Var(darwin_constant_cfstrings) Init(1)
+Generate compile-time CFString objects.
+
+Wnonportable-cfstrings
+Target Report Var(darwin_warn_nonportable_cfstrings) Init(1) Warning
+Warn if constant CFString objects contain non-portable characters.
+
+; Use new-style pic stubs if this is true, x86 only so far.
+matt-stubs
+Target Report Var(darwin_macho_att_stub) Init(1)
+Generate AT&T-style stubs for Mach-O.
+
+mdynamic-no-pic
+Target Common Report Mask(MACHO_DYNAMIC_NO_PIC)
+Generate code suitable for executables (NOT shared libs).
+
+mfix-and-continue
+Target Report Var(darwin_fix_and_continue)
+Generate code suitable for fast turn around debugging.
+
+mkernel
+Target Report Var(flag_mkernel)
+Generate code for the kernel or loadable kernel extensions.
+
+; The Init here is for the convenience of GCC developers, so that cc1
+; and cc1plus don't crash if no -mmacosx-version-min is passed.  The
+; driver will always pass a -mmacosx-version-min, so in normal use the
+; Init is never used.
+mmacosx-version-min=
+Target RejectNegative Joined Report Var(darwin_macosx_version_min) Init(DEF_MIN_OSX_VERSION)
+The earliest MacOS X version on which this program will run.
+
+; Really, only relevant to PowerPC which has a 4 byte bool by default.
+mone-byte-bool
+Target RejectNegative Report Var(darwin_one_byte_bool)
+Set sizeof(bool) to 1.
+
+msymbol-stubs
+Target Report Var(darwin_symbol_stubs) Init(0)
+Force generation of external symbol indirection stubs.
+
+; Some code-gen may be improved / adjusted if the linker is sufficiently modern.
+mtarget-linker=
+Target RejectNegative Joined Report Alias(mtarget-linker)
+
+mtarget-linker
+Target RejectNegative Joined Separate Report Var(darwin_target_linker) Init(LD64_VERSION)
+The version of ld64 in use for this toolchain.
+
+; Driver options.
 
 all_load
-Driver Alias(Zall_load)
+Driver RejectNegative Alias(Zall_load)
+Loads all members of archive libraries
 
 allowable_client
-Driver Separate Alias(Zallowable_client)
+Driver RejectNegative Separate Alias(Zallowable_client)
+-allowable_client <name>	The output dylib is private to the client(s) named
 
 arch
 Driver RejectNegative Separate
+-arch <name>	Specify that the output file should be generated for architecture  \"name\"
 
 arch_errors_fatal
-Driver Alias(Zarch_errors_fatal)
+Driver RejectNegative Alias(Zarch_errors_fatal)
+Mismatches between file architecture and the \"-arch\" are errors instead of warnings
 
 asm_macosx_version_min=
 Driver RejectNegative Joined
+The earliest MacOS X version on which this program will run (formatted for the assembler)
 
 bind_at_load
-Driver Alias(Zbind_at_load)
+Driver RejectNegative Alias(Zbind_at_load)
+Produce an output file that will bind symbols on load, rather than lazily.
 
 bundle
-Driver Alias(Zbundle)
+Driver RejectNegative Alias(Zbundle)
+Produce a Mach-O bundle (file type MH_BUNDLE)
 
 bundle_loader
-Driver Separate Alias(Zbundle_loader)
+Driver RejectNegative Separate Alias(Zbundle_loader)
+-bundle_loader <executable>	Treat \"executable\" (that will be loading this bundle) as if it was one of the dynamic libraries the bundle is linked against for symbol resolution
 
-dead_strip
-Driver Alias(Zdead_strip)
+client_name
+Driver RejectNegative Separate
+-client_name <name>	Enable the executable being built to link against a private dylib (using allowable_client)
 
-dependency-file
-C ObjC C++ ObjC++ Separate Alias(MF) MissingArgError(missing filename after %qs)
+compatibility_version
+Driver RejectNegative Separate
+-compatibility_version <number>	Set the minimum version for the client interface.  Clients must record a greater number than this or the binding will fail at runtime
+
+current_version
+Driver RejectNegative Separate
+-current_version <number>	Set the current version for the library.
+
+dead_strip
+Driver RejectNegative Alias(Zdead_strip)
+Remove code and data that is unreachable from any exported symbol (including the entry point)
 
 dylib_file
 Driver Separate Alias(Zdylib_file)
 
 dylinker
-Driver
+Driver RejectNegative
+Produce a Mach-O dylinker (file type MH_DYLINKER), only used for building dyld.
+
+dylinker_install_name
+Driver RejectNegative Separate
+-dylinker_install_name <path>	Only used for building dyld.
 
 dynamic
-Driver Alias(Zdynamic)
+Driver RejectNegative Alias(Zdynamic)
+The default (and opposite of -static), implied by user mode executables, shared libraries and bundles.
 
 dynamiclib
-Driver Alias(Zdynamiclib)
+Driver RejectNegative Alias(Zdynamiclib)
+Produce a Mach-O shared library (file type MH_DYLIB), synonym for -shared
 
 exported_symbols_list
-Driver Separate Alias(Zexported_symbols_list)
+Driver RejectNegative Separate Alias(Zexported_symbols_list)
+-exported_symbols_list <filename>	Global symbols in \"filename\" will be exported from the linked output file, any symbols not mentioned will be treated as hidden.
 
 filelist
 Driver RejectNegative Separate
+Supply a list of objects to be linked from a file, rather than the command line
 
 findirect-virtual-calls
 Driver RejectNegative
+Used for generating code for some older kernel revisions.
 
 flat_namespace
 Driver RejectNegative Alias(Zflat_namespace)
+Ignore the normal two-level namespace; resolve symbols in command line order and do not record which library provided the resolved symbol.
 
 force_cpusubtype_ALL
 Driver RejectNegative Alias(Zforce_cpusubtype_ALL)
+For the assembler (and linker) permit any architecture sub-variant to be used without error.
 
 force_flat_namespace
 Driver RejectNegative Alias(Zforce_flat_namespace)
+Set the output object such that, on loading, dyld  will ignore any two-level information and resolve symbols in the discovery order for loaded libs.
 
 framework
 Driver RejectNegative Separate
+-framework <name>	The linker should search for the named framework in the framework search path.
 
 fterminated-vtables
 Driver RejectNegative
+Used for generating code for some older kernel revisions.
 
 gfull
 Driver RejectNegative
+Abbreviation for \"-g -fno-eliminate-unused-debug-symbols\"
 
 gused
 Driver RejectNegative
+Abbreviation for \"-g -feliminate-unused-debug-symbols\"
 
 headerpad_max_install_names
-Driver
+Driver RejectNegative
+Automatically adds space for longer path names in load commands (up to MAXPATHLEN)
 
 image_base
-Driver Separate Alias(Zimage_base)
+Driver RejectNegative Separate Alias(Zimage_base)
+-image_base <address>	Choose a base address for a dylib or bundle.
 
 init
-Driver Separate Alias(Zinit)
+Driver RejectNegative Separate Alias(Zinit)
+-init <symbol_name>	The symbol \"symbol_name\" will be used as the first initialiser for a dylib.
 
 install_name
-Driver Separate Alias(Zinstall_name)
+Driver RejectNegative Separate Alias(Zinstall_name)
+-install_name <name>	Set the install name for a dylib.
 
 keep_private_externs
-Driver
-
-mconstant-cfstrings
-Target Report Var(darwin_constant_cfstrings) Init(1)
-Generate compile-time CFString objects.
+Driver RejectNegative
+Usually \"private extern\" (hidden) symbols are made local when linking, this command suppresses that such that they remain exported.
 
 multi_module
 Driver RejectNegative Alias(Zmulti_module)
+(Obsolete after 10.4) Multi modules are ignored at runtime since MacOS 10.4
 
 multiply_defined
 Driver RejectNegative Separate Alias(Zmultiply_defined)
+(Obsolete after 10.4) -multiply_defined <treatment> Provided a mechanism for warning about symbols defined in multiple dylibs.
 
 multiply_defined_unused
 Driver RejectNegative Separate Alias(Zmultiplydefinedunused)
+(Obsolete after 10.4) -multiply_defined_unused <treatment>	Provided a mechanism for warning about symbols defined in the current executable also being defined in linked dylibs.
 
 no_dead_strip_inits_and_terms
-Driver Alias(Zno_dead_strip_inits_and_terms)
+Driver RejectNegative Alias(Zno_dead_strip_inits_and_terms)
+(Obsolete) The linker never dead strips these items, so the option is not needed.
 
 nofixprebinding
-Driver
+Driver RejectNegative
+(Obsolete after 10.3.9) Set MH_NOPREFIXBINDING, in an exectuable.
 
 nomultidefs
-Driver
+Driver RejectNegative
+(Obsolete after 10.4)	Set MH_NOMULTIDEFS in an umbrella framework.
 
 noprebind
-Driver
+Driver RejectNegative Negative(prebind)
+(Obsolete) LD_PREBIND is no longer supported.
 
 noseglinkedit
-Driver
+Driver RejectNegative Negative(seglinkedit)
+(Obsolete) This is the default.
 
 object
-Driver
+Driver RejectNegative
+
+pagezero_size
+Driver RejectNegative Separate
+-pagezero_size size	Allows setting the page 0 size to 4kb for certain special cases.
 
 prebind
-Driver
+Driver RejectNegative Negative(noprebind)
+(Obsolete) LD_PREBIND is no longer supported.
 
 prebind_all_twolevel_modules
-Driver
+Driver RejectNegative
+(Obsolete) LD_PREBIND is no longer supported.
 
 preload
-Driver
+Driver RejectNegative
+Produces a Mach-O file suitable for embedded/ROM use.
 
 private_bundle
-Driver
+Driver RejectNegative
+(Obsolete) Allowed linking to proceed with \"-flat_namespace\" when a linked bundle contained a symbol also exported from the main executable.
 
 pthread
-Driver
+Driver RejectNegative
 
 rdynamic
-Driver
+Driver RejectNegative
+Synonym for \"-export-dynamic\" for linker versions that support it.
+
+read_only_relocs
+Driver RejectNegative Separate
+-read_only_relocs <treatment>	This will allow relocs in read-only pages (not advisable).
+
+sectalign
+Driver RejectNegative Separate Args(3)
+-sectalign <segname> <sectname> <value>	Set section \"sectname\" in segment \"segname\" to have alignment \"value\" which must be an integral power of two expressed in hexadecimal form.
+
+sectcreate
+Driver RejectNegative Separate Args(3)
+-sectcreate <segname> <sectname> <file>	Create section \"sectname\" in segment \"segname\" from the contents of \"file\".
+
+sectobjectsymbols
+Driver RejectNegative Separate Args(2)
+(Obsolete) -sectobjectsymbols <segname> <sectname>	Setting a local symbol at the start of a section is no longer supported.
+
+sectorder
+Driver RejectNegative Separate Args(3)
+(Obsolete) -sectorder <segname> <sectname> orderfile	Replaced by a more general option \"-order_file\".
 
 seg_addr_table
-Driver Separate Alias(Zseg_addr_table)
+Driver RejectNegative Separate Alias(Zseg_addr_table)
+-seg_addr_table <file>	Specify the base addresses for dynamic libraries, \"file\" contains a line for each library.
 
+; This is only usable by the ld_classic linker.
 seg_addr_table_filename
-Driver Separate Alias(Zfn_seg_addr_table_filename)
+Driver RejectNegative Separate Alias(Zfn_seg_addr_table_filename)
+(Obsolete, ld_classic only) -seg_addr_table_filename <path>
+
+seg1addr
+Driver RejectNegative Separate
+Synonym for \"image_base\"
 
 segaddr
-Driver Separate Args(2) Alias(Zsegaddr)
+Driver RejectNegative Separate Args(2) Alias(Zsegaddr)
+-segaddr <name> <address>	Set the base address of segment \"name\" to \"address\" which must be aligned to a page boundary (currently 4kb).
+
+; This is only usable by the ld_classic linker.
+segcreate
+Driver RejectNegative Separate Args(3)
+(Obsolete, ld_classic only) -sectcreate segname sectname file
 
 seglinkedit
-Driver
+Driver RejectNegative Negative(noseglinkedit)
+(Obsolete) Object files with LINKEDIT sections are no longer supported.
+
+segprot
+Driver RejectNegative Separate Args(3)
+-segprot <segname> max_prot init_prot	The protection values are \"r\", \"w\", \"x\" or \"-\" the latter meaning \"no access\".
 
 segs_read_only_addr
-Driver Separate Alias(Zsegs_read_only_addr)
+Driver RejectNegative Separate Alias(Zsegs_read_only_addr)
+-segs_read_only_addr address 	Allows specifying the address of the read only portion of a dylib.
 
 segs_read_write_addr
-Driver Separate Alias(Zsegs_read_write_addr)
+Driver RejectNegative Separate Alias(Zsegs_read_write_addr)
+-segs_read_write_addr address 	Allows specifying the address of the read/write portion of a dylib.
 
 single_module
-Driver Alias(Zsingle_module)
+Driver RejectNegative Alias(Zsingle_module)
+(Obsolete)	This is the default.
+
+sub_library
+Driver RejectNegative Separate
+-sub_library <name>	Library named \"name\" will be re-exported (only useful for dylibs).
+
+sub_umbrella
+Driver RejectNegative Separate
+-sub_umbrella <name>	Framework named \"name\" will be re-exported (only useful for dylibs).
 
 twolevel_namespace
-Driver
+Driver RejectNegative
+This is the default
 
 twolevel_namespace_hints
-Driver
+Driver RejectNegative
+Specifies content that can speed up dynamic loading when the binaries are unchanged.
 
 umbrella
-Driver Separate Alias(Zumbrella)
+Driver RejectNegative Separate Alias(Zumbrella)
+-umbrella <framework>	The specified framework will be re-exported.
+
+undefined
+Driver RejectNegative Separate
+-undefined <treatment>	Specify the handling for undefined symbols (default is error).
 
 unexported_symbols_list
-Driver Separate Alias(Zunexported_symbols_list)
+Driver RejectNegative Separate Alias(Zunexported_symbols_list)
+-unexported_symbols_list <filename>	Don't export global symbols listed in filename.
 
 weak_reference_mismatches
-Driver Separate Alias(Zweak_reference_mismatches)
+Driver RejectNegative Separate Alias(Zweak_reference_mismatches)
+-weak_reference_mismatches <treatment>	Specifies what to do if a symbol import conflicts between file (weak in one and not in another) the default is to treat the symbol as non-weak.
 
 whatsloaded
-Driver
+Driver RejectNegative
+Logs the object files the linker loads
 
 whyload
-Driver
+Driver RejectNegative
+Logs which symbol(s) caused an object to be loaded.
+
+;(Obsolete, ignored)	Strip symbols starting with "L", this is the default.
+X
+Driver RejectNegative
 
 y
-Driver Joined
+Driver RejectNegative Joined
+(Obsolete, ignored)	Old support similar to whyload.
 
 Mach
-Driver
-
-Wnonportable-cfstrings
-Target Report Var(darwin_warn_nonportable_cfstrings) Init(1) Warning
-Warn if constant CFString objects contain non-portable characters.
-
-; Use new-style pic stubs if this is true, x86 only so far.
-matt-stubs
-Target Report Var(darwin_macho_att_stub) Init(1)
-Generate AT&T-style stubs for Mach-O.
-
-mdynamic-no-pic
-Target Common Report Mask(MACHO_DYNAMIC_NO_PIC)
-Generate code suitable for executables (NOT shared libs).
-
-mfix-and-continue
-Target Report Var(darwin_fix_and_continue)
-Generate code suitable for fast turn around debugging.
-
-; The Init here is for the convenience of GCC developers, so that cc1
-; and cc1plus don't crash if no -mmacosx-version-min is passed.  The
-; driver will always pass a -mmacosx-version-min, so in normal use the
-; Init is never used.
-mmacosx-version-min=
-Target Joined Report Var(darwin_macosx_version_min) Init(DEF_MIN_OSX_VERSION)
-The earliest MacOS X version on which this program will run.
-
-mone-byte-bool
-Target RejectNegative Report Var(darwin_one_byte_bool)
-Set sizeof(bool) to 1.
-
-fapple-kext
-Target Report C++ Var(flag_apple_kext)
-Generate code for darwin loadable kernel extensions.
-
-mkernel
-Target Report Var(flag_mkernel)
-Generate code for the kernel or loadable kernel extensions.
-
-iframework
-Target RejectNegative C ObjC C++ ObjC++ Joined Separate 
--iframework <dir>	Add <dir> to the end of the system framework include path.
+Driver RejectNegative
+(Obsolete and unhandled by ld64, ignored)	ld should produce an executable (only handled by ld_classic).
 
-X
-Driver
+;; These are not "real" options, but placeholders used to hide the real options
+;; from generic options processing... FIXME: they can be eliminated now.
 
 Zall_load
 Driver
@@ -343,62 +485,3 @@ Driver Separate
 Zweak_reference_mismatches
 Driver Separate
 
-client_name
-Driver Separate
-
-compatibility_version
-Driver Separate
-
-current_version
-Driver Separate
-
-dylinker_install_name
-Driver Separate
-
-pagezero_size
-Driver Separate
-
-read_only_relocs
-Driver Separate
-
-sectalign
-Driver Separate Args(3)
-
-sectcreate
-Driver Separate Args(3)
-
-sectobjectsymbols
-Driver Separate Args(2)
-
-sectorder
-Driver Separate Args(3)
-
-seg1addr
-Driver Separate
-
-segcreate
-Driver Separate Args(3)
-
-segprot
-Driver Separate Args(3)
-
-segs_read_only_addr
-Driver Separate
-
-segs_read_write_addr
-Driver Separate
-
-sub_library
-Driver Separate
-
-sub_umbrella
-Driver Separate
-
-; Certain aspects of code-gen may be improved / adjusted if the version of ld64
-; is sufficiently modern.
-mtarget-linker
-Target RejectNegative Joined Separate Report Var(darwin_target_linker) Init(LD64_VERSION)
-The version of ld64 in use for this toolchain.
-
-undefined
-Driver Separate
diff --git a/gcc/config/darwin10.h b/gcc/config/darwin10.h
index 07a2b465a04..a6d1eba6ebd 100644
--- a/gcc/config/darwin10.h
+++ b/gcc/config/darwin10.h
@@ -18,17 +18,12 @@ You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
-/* Fix PR41260 by passing -no_compact_unwind on darwin10 and later until
-   unwinder in libSystem is fixed to digest new epilog unwinding notes.
+/* Fix PR47558 by linking against libSystem ahead of libgcc_ext. */
 
-   Fix PR47558 by linking against libSystem ahead of libgcc_ext. */
 #undef  LINK_GCC_C_SEQUENCE_SPEC
 #define LINK_GCC_C_SEQUENCE_SPEC \
-"%:version-compare(>= 10.6 mmacosx-version-min= -no_compact_unwind) \
- %{!static:%{!static-libgcc: \
+"%{!static:%{!static-libgcc: \
     %:version-compare(>= 10.6 mmacosx-version-min= -lSystem) } } \
- %{fno-pic|fno-PIC|fno-pie|fno-PIE|fapple-kext|mkernel|static|mdynamic-no-pic: \
-   %:version-compare(>= 10.7 mmacosx-version-min= -no_pie) } \
  %{!nostdlib:%:version-compare(>< 10.6 10.7 mmacosx-version-min= -ld10-uwfef.o)} \
   %G %{!nolibc:%L}"
 
diff --git a/gcc/config/darwin9.h b/gcc/config/darwin9.h
index ca5c51718c8..1fd1604aed8 100644
--- a/gcc/config/darwin9.h
+++ b/gcc/config/darwin9.h
@@ -35,12 +35,6 @@ along with GCC; see the file COPYING3.  If not see
 /* Tell collect2 to run dsymutil for us as necessary.  */
 #define COLLECT_RUN_DSYMUTIL 1
 
-#undef DARWIN_PIE_SPEC
-#define DARWIN_PIE_SPEC \
-  "%{fpie|pie|fPIE: \
-     %{mdynamic-no-pic: %n'-mdynamic-no-pic' overrides '-pie', '-fpie' or '-fPIE'; \
-      :-pie}}"
-
 /* Only ask as for debug data if the debug style is stabs (since as doesn't
    yet generate dwarf.)  */
 
diff --git a/gcc/config/i386/avx2intrin.h b/gcc/config/i386/avx2intrin.h
index 7606efdbf79..372d77f84fe 100644
--- a/gcc/config/i386/avx2intrin.h
+++ b/gcc/config/i386/avx2intrin.h
@@ -258,7 +258,7 @@ extern __inline __m256i
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_cmpgt_epi8 (__m256i __A, __m256i __B)
 {
-  return (__m256i) ((__v32qi)__A > (__v32qi)__B);
+  return (__m256i) ((__v32qs)__A > (__v32qs)__B);
 }
 
 extern __inline __m256i
diff --git a/gcc/config/i386/avxintrin.h b/gcc/config/i386/avxintrin.h
index 29115a11a0d..3301451e4de 100644
--- a/gcc/config/i386/avxintrin.h
+++ b/gcc/config/i386/avxintrin.h
@@ -47,6 +47,7 @@ typedef unsigned int __v8su __attribute__ ((__vector_size__ (32)));
 typedef short __v16hi __attribute__ ((__vector_size__ (32)));
 typedef unsigned short __v16hu __attribute__ ((__vector_size__ (32)));
 typedef char __v32qi __attribute__ ((__vector_size__ (32)));
+typedef signed char __v32qs __attribute__ ((__vector_size__ (32)));
 typedef unsigned char __v32qu __attribute__ ((__vector_size__ (32)));
 
 /* The Intel API is flexible enough that we must allow aliasing with other
diff --git a/gcc/config/i386/darwin.h b/gcc/config/i386/darwin.h
index 1e96350fa71..bdb36f00959 100644
--- a/gcc/config/i386/darwin.h
+++ b/gcc/config/i386/darwin.h
@@ -90,14 +90,12 @@ along with GCC; see the file COPYING3.  If not see
 #undef WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE 32
 
-/* Generate branch islands stubs if this is true.  */
-extern int darwin_emit_branch_islands;
-
-#undef TARGET_MACHO_BRANCH_ISLANDS
-#define TARGET_MACHO_BRANCH_ISLANDS darwin_emit_branch_islands
+/* Generate pic symbol indirection stubs if this is true.  */
+#undef TARGET_MACHO_SYMBOL_STUBS
+#define TARGET_MACHO_SYMBOL_STUBS (darwin_symbol_stubs)
 
 /* For compatibility with OSX system tools, use the new style of pic stub
-   if this is set.  */
+   if this is set (default).  */
 #undef  MACHOPIC_ATT_STUB
 #define MACHOPIC_ATT_STUB (darwin_macho_att_stub)
 
@@ -245,7 +243,7 @@ extern int darwin_emit_branch_islands;
 #undef FUNCTION_PROFILER
 #define FUNCTION_PROFILER(FILE, LABELNO)				\
   do {									\
-    if (TARGET_MACHO_BRANCH_ISLANDS 					\
+    if (TARGET_MACHO_SYMBOL_STUBS 					\
 	&& MACHOPIC_INDIRECT && !TARGET_64BIT)				\
       {									\
 	const char *name = machopic_mcount_stub_name ();		\
@@ -326,10 +324,8 @@ extern int darwin_emit_branch_islands;
         }								\
     }
 
-/* This needs to move since i386 uses the first flag and other flags are
-   used in Mach-O.  */
-#undef MACHO_SYMBOL_FLAG_VARIABLE
-#define MACHO_SYMBOL_FLAG_VARIABLE ((SYMBOL_FLAG_MACH_DEP) << 3)
+/* First available SYMBOL flag bit for use by subtargets.  */
+#define SYMBOL_FLAG_SUBT_DEP (SYMBOL_FLAG_MACH_DEP << 5)
 
 #undef MACHOPIC_NL_SYMBOL_PTR_SECTION
 #define MACHOPIC_NL_SYMBOL_PTR_SECTION \
diff --git a/gcc/config/i386/emmintrin.h b/gcc/config/i386/emmintrin.h
index f9e7b33b0dd..1683d842c65 100644
--- a/gcc/config/i386/emmintrin.h
+++ b/gcc/config/i386/emmintrin.h
@@ -1308,7 +1308,7 @@ _mm_xor_si128 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpeq_epi8 (__m128i __A, __m128i __B)
 {
-  return (__m128i) ((__v16qs)__A == (__v16qs)__B);
+  return (__m128i) ((__v16qi)__A == (__v16qi)__B);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/i386/i386-builtin.def b/gcc/config/i386/i386-builtin.def
index 6580890edc0..5dedeb2d18b 100644
--- a/gcc/config/i386/i386-builtin.def
+++ b/gcc/config/i386/i386-builtin.def
@@ -818,11 +818,11 @@ BDESC (OPTION_MASK_ISA_SSE3, 0, CODE_FOR_sse3_hsubv2df3, "__builtin_ia32_hsubpd"
 
 /* SSSE3 */
 BDESC (OPTION_MASK_ISA_SSSE3, 0, CODE_FOR_absv16qi2, "__builtin_ia32_pabsb128", IX86_BUILTIN_PABSB128, UNKNOWN, (int) V16QI_FTYPE_V16QI)
-BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_absv8qi2, "__builtin_ia32_pabsb", IX86_BUILTIN_PABSB, UNKNOWN, (int) V8QI_FTYPE_V8QI)
+BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_ssse3_absv8qi2, "__builtin_ia32_pabsb", IX86_BUILTIN_PABSB, UNKNOWN, (int) V8QI_FTYPE_V8QI)
 BDESC (OPTION_MASK_ISA_SSSE3, 0, CODE_FOR_absv8hi2, "__builtin_ia32_pabsw128", IX86_BUILTIN_PABSW128, UNKNOWN, (int) V8HI_FTYPE_V8HI)
-BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_absv4hi2, "__builtin_ia32_pabsw", IX86_BUILTIN_PABSW, UNKNOWN, (int) V4HI_FTYPE_V4HI)
+BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_ssse3_absv4hi2, "__builtin_ia32_pabsw", IX86_BUILTIN_PABSW, UNKNOWN, (int) V4HI_FTYPE_V4HI)
 BDESC (OPTION_MASK_ISA_SSSE3, 0, CODE_FOR_absv4si2, "__builtin_ia32_pabsd128", IX86_BUILTIN_PABSD128, UNKNOWN, (int) V4SI_FTYPE_V4SI)
-BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_absv2si2, "__builtin_ia32_pabsd", IX86_BUILTIN_PABSD, UNKNOWN, (int) V2SI_FTYPE_V2SI)
+BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_ssse3_absv2si2, "__builtin_ia32_pabsd", IX86_BUILTIN_PABSD, UNKNOWN, (int) V2SI_FTYPE_V2SI)
 
 BDESC (OPTION_MASK_ISA_SSSE3, 0, CODE_FOR_ssse3_phaddwv8hi3, "__builtin_ia32_phaddw128", IX86_BUILTIN_PHADDW128, UNKNOWN, (int) V8HI_FTYPE_V8HI_V8HI)
 BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, 0, CODE_FOR_ssse3_phaddwv4hi3, "__builtin_ia32_phaddw", IX86_BUILTIN_PHADDW, UNKNOWN, (int) V4HI_FTYPE_V4HI_V4HI)
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 2b37296e537..73a3ef364b3 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -16960,7 +16960,7 @@ output_pic_addr_const (FILE *file, rtx x, int code)
       break;
 
     case SYMBOL_REF:
-      if (TARGET_64BIT || ! TARGET_MACHO_BRANCH_ISLANDS)
+      if (TARGET_64BIT || ! TARGET_MACHO_SYMBOL_STUBS)
 	output_addr_const (file, x);
       else
 	{
diff --git a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
index 2cb16d9fbf6..170bbdd7fbf 100644
--- a/gcc/config/i386/i386.h
+++ b/gcc/config/i386/i386.h
@@ -640,7 +640,7 @@ extern tree x86_mfence;
 /* Replace MACH-O, ifdefs by in-line tests, where possible. 
    (a) Macros defined in config/i386/darwin.h  */
 #define TARGET_MACHO 0
-#define TARGET_MACHO_BRANCH_ISLANDS 0
+#define TARGET_MACHO_SYMBOL_STUBS 0
 #define MACHOPIC_ATT_STUB 0
 /* (b) Macros defined in config/darwin.h  */
 #define MACHO_DYNAMIC_NO_PIC_P 0
diff --git a/gcc/config/i386/intelmic-mkoffload.c b/gcc/config/i386/intelmic-mkoffload.c
index 2a3e912ee74..0b12edc72c1 100644
--- a/gcc/config/i386/intelmic-mkoffload.c
+++ b/gcc/config/i386/intelmic-mkoffload.c
@@ -453,8 +453,6 @@ prepare_target_image (const char *target_compiler, int argc, char **argv)
   if (verbose)
     obstack_ptr_grow (&argv_obstack, "-v");
   obstack_ptr_grow (&argv_obstack, "-xlto");
-  obstack_ptr_grow (&argv_obstack, "-shared");
-  obstack_ptr_grow (&argv_obstack, "-fPIC");
   obstack_ptr_grow (&argv_obstack, opt1);
   for (int i = 1; i < argc; i++)
     {
@@ -466,6 +464,9 @@ prepare_target_image (const char *target_compiler, int argc, char **argv)
   if (!out_obj_filename)
     fatal_error (input_location, "output file not specified");
   obstack_ptr_grow (&argv_obstack, opt2);
+  /* NB: Put -fPIC and -shared the last to create shared library.  */
+  obstack_ptr_grow (&argv_obstack, "-fPIC");
+  obstack_ptr_grow (&argv_obstack, "-shared");
   obstack_ptr_grow (&argv_obstack, "-o");
   obstack_ptr_grow (&argv_obstack, target_so_filename);
   compile_for_target (&argv_obstack);
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index 46ec4602eb7..c1b7ce99125 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -2625,7 +2625,7 @@
 ;; Modes handled by reduc_sm{in,ax}* patterns.
 (define_mode_iterator REDUC_SSE_SMINMAX_MODE
   [(V4SF "TARGET_SSE") (V2DF "TARGET_SSE")
-   (V2DI "TARGET_SSE") (V4SI "TARGET_SSE") (V8HI "TARGET_SSE")
+   (V2DI "TARGET_SSE4_2") (V4SI "TARGET_SSE") (V8HI "TARGET_SSE")
    (V16QI "TARGET_SSE")])
 
 (define_expand "reduc_<code>_scal_<mode>"
@@ -16241,7 +16241,7 @@
     }
 })
 
-(define_insn "abs<mode>2"
+(define_insn "ssse3_abs<mode>2"
   [(set (match_operand:MMXMODEI 0 "register_operand" "=y")
 	(abs:MMXMODEI
 	  (match_operand:MMXMODEI 1 "nonimmediate_operand" "ym")))]
diff --git a/gcc/config/mips/mips.c b/gcc/config/mips/mips.c
index 2dfc7c73cce..d758fbf1be6 100644
--- a/gcc/config/mips/mips.c
+++ b/gcc/config/mips/mips.c
@@ -4849,7 +4849,7 @@ mips_split_move (rtx dest, rtx src, enum mips_split_type split_type, rtx insn_)
      can forward SRC for DEST.  This is most useful if the next insn is a
      simple store.   */
   rtx_insn *insn = (rtx_insn *)insn_;
-  struct mips_address_info addr;
+  struct mips_address_info addr = {};
   if (insn)
     {
       rtx_insn *next = next_nonnote_nondebug_insn_bb (insn);
@@ -4862,7 +4862,7 @@ mips_split_move (rtx dest, rtx src, enum mips_split_type split_type, rtx insn_)
 		{
 		  rtx tmp = XEXP (src, 0);
 		  mips_classify_address (&addr, tmp, GET_MODE (tmp), true);
-		  if (REGNO (addr.reg) != REGNO (dest))
+		  if (addr.reg && !reg_overlap_mentioned_p (dest, addr.reg))
 		    validate_change (next, &SET_SRC (set), src, false);
 		}
 	      else
diff --git a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
index 2ae1f7e0440..3cfb1a751e9 100644
--- a/gcc/config/mips/mips.md
+++ b/gcc/config/mips/mips.md
@@ -5836,8 +5836,8 @@
   "ISA_HAS_ROR"
 {
   if (CONST_INT_P (operands[2]))
-    gcc_assert (INTVAL (operands[2]) >= 0
-		&& INTVAL (operands[2]) < GET_MODE_BITSIZE (<MODE>mode));
+    operands[2] = GEN_INT (INTVAL (operands[2])
+                           & (GET_MODE_BITSIZE (<MODE>mode) - 1));
 
   return "<d>ror\t%0,%1,%2";
 }
@@ -7588,7 +7588,7 @@
 ;; __builtin_mips_get_fcsr: move the FCSR into operand 0.
 (define_expand "mips_get_fcsr"
   [(set (match_operand:SI 0 "register_operand")
-  	(unspec_volatile [(const_int 0)] UNSPEC_GET_FCSR))]
+       (unspec_volatile:SI [(const_int 0)] UNSPEC_GET_FCSR))]
   "TARGET_HARD_FLOAT_ABI"
 {
   if (TARGET_MIPS16)
@@ -7600,7 +7600,7 @@
 
 (define_insn "*mips_get_fcsr"
   [(set (match_operand:SI 0 "register_operand" "=d")
-  	(unspec_volatile [(const_int 0)] UNSPEC_GET_FCSR))]
+       (unspec_volatile:SI [(const_int 0)] UNSPEC_GET_FCSR))]
   "TARGET_HARD_FLOAT"
   "cfc1\t%0,$31")
 
diff --git a/gcc/config/pa/pa.c b/gcc/config/pa/pa.c
index 707ae5822c3..6d75f26e02f 100644
--- a/gcc/config/pa/pa.c
+++ b/gcc/config/pa/pa.c
@@ -7856,7 +7856,7 @@ pa_attr_length_call (rtx_insn *insn, int sibcall)
 
   /* 64-bit plabel sequence.  */
   else if (TARGET_64BIT && !local_call)
-    length += sibcall ? 28 : 24;
+    length += 24;
 
   /* non-pic long absolute branch sequence.  */
   else if ((TARGET_LONG_ABS_CALL || local_call) && !flag_pic)
@@ -7928,38 +7928,24 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)
 	  xoperands[0] = pa_get_deferred_plabel (call_dest);
 	  xoperands[1] = gen_label_rtx ();
 
-	  /* If this isn't a sibcall, we put the load of %r27 into the
-	     delay slot.  We can't do this in a sibcall as we don't
-	     have a second call-clobbered scratch register available.
-	     We don't need to do anything when generating fast indirect
-	     calls.  */
-	  if (seq_length != 0 && !sibcall)
+	  /* Put the load of %r27 into the delay slot.  We don't need to
+	     do anything when generating fast indirect calls.  */
+	  if (seq_length != 0)
 	    {
 	      final_scan_insn (NEXT_INSN (insn), asm_out_file,
 			       optimize, 0, NULL);
 
 	      /* Now delete the delay insn.  */
 	      SET_INSN_DELETED (NEXT_INSN (insn));
-	      seq_length = 0;
 	    }
 
 	  output_asm_insn ("addil LT'%0,%%r27", xoperands);
 	  output_asm_insn ("ldd RT'%0(%%r1),%%r1", xoperands);
 	  output_asm_insn ("ldd 0(%%r1),%%r1", xoperands);
-
-	  if (sibcall)
-	    {
-	      output_asm_insn ("ldd 24(%%r1),%%r27", xoperands);
-	      output_asm_insn ("ldd 16(%%r1),%%r1", xoperands);
-	      output_asm_insn ("bve (%%r1)", xoperands);
-	    }
-	  else
-	    {
-	      output_asm_insn ("ldd 16(%%r1),%%r2", xoperands);
-	      output_asm_insn ("bve,l (%%r2),%%r2", xoperands);
-	      output_asm_insn ("ldd 24(%%r1),%%r27", xoperands);
-	      seq_length = 1;
-	    }
+	  output_asm_insn ("ldd 16(%%r1),%%r2", xoperands);
+	  output_asm_insn ("bve,l (%%r2),%%r2", xoperands);
+	  output_asm_insn ("ldd 24(%%r1),%%r27", xoperands);
+	  seq_length = 1;
 	}
       else
 	{
@@ -8052,20 +8038,22 @@ pa_output_call (rtx_insn *insn, rtx call_dest, int sibcall)
 		    {
 		      output_asm_insn ("addil LT'%0,%%r19", xoperands);
 		      output_asm_insn ("ldw RT'%0(%%r1),%%r1", xoperands);
-		      output_asm_insn ("ldw 0(%%r1),%%r1", xoperands);
+		      output_asm_insn ("ldw 0(%%r1),%%r22", xoperands);
 		    }
 		  else
 		    {
 		      output_asm_insn ("addil LR'%0-$global$,%%r27",
 				       xoperands);
-		      output_asm_insn ("ldw RR'%0-$global$(%%r1),%%r1",
+		      output_asm_insn ("ldw RR'%0-$global$(%%r1),%%r22",
 				       xoperands);
 		    }
 
-		  output_asm_insn ("bb,>=,n %%r1,30,.+16", xoperands);
-		  output_asm_insn ("depi 0,31,2,%%r1", xoperands);
-		  output_asm_insn ("ldw 4(%%sr0,%%r1),%%r19", xoperands);
-		  output_asm_insn ("ldw 0(%%sr0,%%r1),%%r1", xoperands);
+		  output_asm_insn ("bb,>=,n %%r22,30,.+16", xoperands);
+		  output_asm_insn ("depi 0,31,2,%%r22", xoperands);
+		  /* Should this be an ordered load to ensure the target
+	             address is loaded before the global pointer?  */
+		  output_asm_insn ("ldw 0(%%r22),%%r1", xoperands);
+		  output_asm_insn ("ldw 4(%%r22),%%r19", xoperands);
 
 		  if (!sibcall && !TARGET_PA_20)
 		    {
@@ -8158,10 +8146,6 @@ pa_attr_length_indirect_call (rtx_insn *insn)
   if (TARGET_PORTABLE_RUNTIME)
     return 16;
 
-  /* Inline version of $$dyncall.  */
-  if ((TARGET_NO_SPACE_REGS || TARGET_PA_20) && !optimize_size)
-    return 20;
-
   if (!TARGET_LONG_CALLS
       && ((TARGET_PA_20 && !TARGET_SOM && distance < 7600000)
 	  || distance < MAX_PCREL17F_OFFSET))
@@ -8171,12 +8155,15 @@ pa_attr_length_indirect_call (rtx_insn *insn)
   if (!flag_pic)
     return 12;
 
-  /* Inline version of $$dyncall.  */
-  if (TARGET_NO_SPACE_REGS || TARGET_PA_20)
-    return 20;
-
+  /* Inline versions of $$dyncall.  */
   if (!optimize_size)
-    return 36;
+    {
+      if (TARGET_NO_SPACE_REGS)
+	return 28;
+
+      if (TARGET_PA_20)
+	return 32;
+    }
 
   /* Long PIC pc-relative call.  */
   return 20;
@@ -8214,22 +8201,6 @@ pa_output_indirect_call (rtx_insn *insn, rtx call_dest)
       return "blr %%r0,%%r2\n\tbv,n %%r0(%%r31)";
     }
 
-  /* Maybe emit a fast inline version of $$dyncall.  */
-  if ((TARGET_NO_SPACE_REGS || TARGET_PA_20) && !optimize_size)
-    {
-      output_asm_insn ("bb,>=,n %%r22,30,.+12\n\t"
-		       "ldw 2(%%r22),%%r19\n\t"
-		       "ldw -2(%%r22),%%r22", xoperands);
-      pa_output_arg_descriptor (insn);
-      if (TARGET_NO_SPACE_REGS)
-	{
-	  if (TARGET_PA_20)
-	    return "bve,l,n (%%r22),%%r2\n\tnop";
-	  return "ble 0(%%sr4,%%r22)\n\tcopy %%r31,%%r2";
-	}
-      return "bve,l (%%r22),%%r2\n\tstw %%r2,-24(%%sp)";
-    }
-
   /* Now the normal case -- we can reach $$dyncall directly or
      we're sure that we can get there via a long-branch stub. 
 
@@ -8258,35 +8229,40 @@ pa_output_indirect_call (rtx_insn *insn, rtx call_dest)
       return "ble R'$$dyncall(%%sr4,%%r2)\n\tcopy %%r31,%%r2";
     }
 
-  /* Maybe emit a fast inline version of $$dyncall.  The long PIC
-     pc-relative call sequence is five instructions.  The inline PA 2.0
-     version of $$dyncall is also five instructions.  The PA 1.X versions
-     are longer but still an overall win.  */
-  if (TARGET_NO_SPACE_REGS || TARGET_PA_20 || !optimize_size)
+  /* The long PIC pc-relative call sequence is five instructions.  So,
+     let's use an inline version of $$dyncall when the calling sequence
+     has a roughly similar number of instructions and we are not optimizing
+     for size.  We need two instructions to load the return pointer plus
+     the $$dyncall implementation.  */
+  if (!optimize_size)
     {
-      output_asm_insn ("bb,>=,n %%r22,30,.+12\n\t"
-		       "ldw 2(%%r22),%%r19\n\t"
-		       "ldw -2(%%r22),%%r22", xoperands);
       if (TARGET_NO_SPACE_REGS)
 	{
 	  pa_output_arg_descriptor (insn);
-	  if (TARGET_PA_20)
-	    return "bve,l,n (%%r22),%%r2\n\tnop";
-	  return "ble 0(%%sr4,%%r22)\n\tcopy %%r31,%%r2";
+	  output_asm_insn ("bl .+8,%%r2\n\t"
+			   "ldo 20(%%r2),%%r2\n\t"
+			   "extru,<> %%r22,30,1,%%r0\n\t"
+			   "bv,n %%r0(%%r22)\n\t"
+			   "ldw -2(%%r22),%%r21\n\t"
+			   "bv %%r0(%%r21)\n\t"
+			   "ldw 2(%%r22),%%r19", xoperands);
+	  return "";
 	}
       if (TARGET_PA_20)
 	{
 	  pa_output_arg_descriptor (insn);
-	  return "bve,l (%%r22),%%r2\n\tstw %%r2,-24(%%sp)";
+	  output_asm_insn ("bl .+8,%%r2\n\t"
+			   "ldo 24(%%r2),%%r2\n\t"
+			   "stw %%r2,-24(%%sp)\n\t"
+			   "extru,<> %r22,30,1,%%r0\n\t"
+			   "bve,n (%%r22)\n\t"
+			   "ldw -2(%%r22),%%r21\n\t"
+			   "bve (%%r21)\n\t"
+			   "ldw 2(%%r22),%%r19", xoperands);
+	  return "";
 	}
-      output_asm_insn ("bl .+8,%%r2\n\t"
-		       "ldo 16(%%r2),%%r2\n\t"
-		       "ldsid (%%r22),%%r1\n\t"
-		       "mtsp %%r1,%%sr0", xoperands);
-      pa_output_arg_descriptor (insn);
-      return "be 0(%%sr0,%%r22)\n\tstw %%r2,-24(%%sp)";
     }
- 
+
   /* We need a long PIC call to $$dyncall.  */
   xoperands[0] = gen_rtx_SYMBOL_REF (Pmode, "$$dyncall");
   xoperands[1] = gen_rtx_REG (Pmode, 2);
@@ -10048,7 +10024,7 @@ pa_modes_tieable_p (machine_mode mode1, machine_mode mode2)
 
 /* Length in units of the trampoline instruction code.  */
 
-#define TRAMPOLINE_CODE_SIZE (TARGET_64BIT ? 24 : (TARGET_PA_20 ? 32 : 40))
+#define TRAMPOLINE_CODE_SIZE (TARGET_64BIT ? 24 : (TARGET_PA_20 ? 36 : 48))
 
 
 /* Output assembler code for a block containing the constant parts
@@ -10069,27 +10045,46 @@ pa_asm_trampoline_template (FILE *f)
 {
   if (!TARGET_64BIT)
     {
-      fputs ("\tldw	36(%r22),%r21\n", f);
-      fputs ("\tbb,>=,n	%r21,30,.+16\n", f);
-      if (ASSEMBLER_DIALECT == 0)
-	fputs ("\tdepi	0,31,2,%r21\n", f);
-      else
-	fputs ("\tdepwi	0,31,2,%r21\n", f);
-      fputs ("\tldw	4(%r21),%r19\n", f);
-      fputs ("\tldw	0(%r21),%r21\n", f);
       if (TARGET_PA_20)
 	{
-	  fputs ("\tbve	(%r21)\n", f);
-	  fputs ("\tldw	40(%r22),%r29\n", f);
+	  fputs ("\tmfia	%r20\n", f);
+	  fputs ("\tldw		48(%r20),%r22\n", f);
+	  fputs ("\tcopy	%r22,%r21\n", f);
+	  fputs ("\tbb,>=,n	%r22,30,.+16\n", f);
+	  fputs ("\tdepwi	0,31,2,%r22\n", f);
+	  fputs ("\tldw		0(%r22),%r21\n", f);
+	  fputs ("\tldw		4(%r22),%r19\n", f);
+	  fputs ("\tbve		(%r21)\n", f);
+	  fputs ("\tldw		52(%r1),%r29\n", f);
+	  fputs ("\t.word	0\n", f);
 	  fputs ("\t.word	0\n", f);
 	  fputs ("\t.word	0\n", f);
 	}
       else
 	{
+	  if (ASSEMBLER_DIALECT == 0)
+	    {
+	      fputs ("\tbl	.+8,%r20\n", f);
+	      fputs ("\tdepi	0,31,2,%r20\n", f);
+	    }
+	  else
+	    {
+	      fputs ("\tb,l	.+8,%r20\n", f);
+	      fputs ("\tdepwi	0,31,2,%r20\n", f);
+	    }
+	  fputs ("\tldw		40(%r20),%r22\n", f);
+	  fputs ("\tcopy	%r22,%r21\n", f);
+	  fputs ("\tbb,>=,n	%r22,30,.+16\n", f);
+	  if (ASSEMBLER_DIALECT == 0)
+	    fputs ("\tdepi	0,31,2,%r22\n", f);
+	  else
+	    fputs ("\tdepwi	0,31,2,%r22\n", f);
+	  fputs ("\tldw		0(%r22),%r21\n", f);
+	  fputs ("\tldw		4(%r22),%r19\n", f);
 	  fputs ("\tldsid	(%r21),%r1\n", f);
 	  fputs ("\tmtsp	%r1,%sr0\n", f);
-	  fputs ("\tbe	0(%sr0,%r21)\n", f);
-	  fputs ("\tldw	40(%r22),%r29\n", f);
+	  fputs ("\tbe		0(%sr0,%r21)\n", f);
+	  fputs ("\tldw		44(%r20),%r29\n", f);
 	}
       fputs ("\t.word	0\n", f);
       fputs ("\t.word	0\n", f);
@@ -10103,11 +10098,11 @@ pa_asm_trampoline_template (FILE *f)
       fputs ("\t.dword 0\n", f);
       fputs ("\t.dword 0\n", f);
       fputs ("\tmfia	%r31\n", f);
-      fputs ("\tldd	24(%r31),%r1\n", f);
-      fputs ("\tldd	24(%r1),%r27\n", f);
-      fputs ("\tldd	16(%r1),%r1\n", f);
-      fputs ("\tbve	(%r1)\n", f);
+      fputs ("\tldd	24(%r31),%r27\n", f);
       fputs ("\tldd	32(%r31),%r31\n", f);
+      fputs ("\tldd	16(%r27),%r1\n", f);
+      fputs ("\tbve	(%r1)\n", f);
+      fputs ("\tldd	24(%r27),%r27\n", f);
       fputs ("\t.dword 0  ; fptr\n", f);
       fputs ("\t.dword 0  ; static link\n", f);
     }
@@ -10117,10 +10112,10 @@ pa_asm_trampoline_template (FILE *f)
    FNADDR is an RTX for the address of the function's pure code.
    CXT is an RTX for the static chain value for the function.
 
-   Move the function address to the trampoline template at offset 36.
-   Move the static chain value to trampoline template at offset 40.
-   Move the trampoline address to trampoline template at offset 44.
-   Move r19 to trampoline template at offset 48.  The latter two
+   Move the function address to the trampoline template at offset 48.
+   Move the static chain value to trampoline template at offset 52.
+   Move the trampoline address to trampoline template at offset 56.
+   Move r19 to trampoline template at offset 60.  The latter two
    words create a plabel for the indirect call to the trampoline.
 
    A similar sequence is used for the 64-bit port but the plabel is
@@ -10146,15 +10141,15 @@ pa_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)
 
   if (!TARGET_64BIT)
     {
-      tmp = adjust_address (m_tramp, Pmode, 36);
+      tmp = adjust_address (m_tramp, Pmode, 48);
       emit_move_insn (tmp, fnaddr);
-      tmp = adjust_address (m_tramp, Pmode, 40);
+      tmp = adjust_address (m_tramp, Pmode, 52);
       emit_move_insn (tmp, chain_value);
 
       /* Create a fat pointer for the trampoline.  */
-      tmp = adjust_address (m_tramp, Pmode, 44);
+      tmp = adjust_address (m_tramp, Pmode, 56);
       emit_move_insn (tmp, r_tramp);
-      tmp = adjust_address (m_tramp, Pmode, 48);
+      tmp = adjust_address (m_tramp, Pmode, 60);
       emit_move_insn (tmp, gen_rtx_REG (Pmode, 19));
 
       /* fdc and fic only use registers for the address to flush,
@@ -10206,20 +10201,20 @@ pa_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)
     }
 
 #ifdef HAVE_ENABLE_EXECUTE_STACK
-  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, "__enable_execute_stack"),
+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, "__enable_execute_stack"),
 		     LCT_NORMAL, VOIDmode, XEXP (m_tramp, 0), Pmode);
 #endif
 }
 
 /* Perform any machine-specific adjustment in the address of the trampoline.
    ADDR contains the address that was passed to pa_trampoline_init.
-   Adjust the trampoline address to point to the plabel at offset 44.  */
+   Adjust the trampoline address to point to the plabel at offset 56.  */
 
 static rtx
 pa_trampoline_adjust_address (rtx addr)
 {
   if (!TARGET_64BIT)
-    addr = memory_address (Pmode, plus_constant (Pmode, addr, 46));
+    addr = memory_address (Pmode, plus_constant (Pmode, addr, 58));
   return addr;
 }
 
diff --git a/gcc/config/pa/pa.h b/gcc/config/pa/pa.h
index 561efa51882..24739e56f97 100644
--- a/gcc/config/pa/pa.h
+++ b/gcc/config/pa/pa.h
@@ -689,7 +689,7 @@ extern int may_call_alloca;
 
 /* Length in units of the trampoline for entering a nested function.  */
 
-#define TRAMPOLINE_SIZE (TARGET_64BIT ? 72 : 52)
+#define TRAMPOLINE_SIZE (TARGET_64BIT ? 72 : 64)
 
 /* Alignment required by the trampoline.  */
 
@@ -1293,13 +1293,12 @@ do {									     \
 #endif
 
 /* The maximum offset in bytes for a PA 1.X pc-relative call to the
-   head of the preceding stub table.  The selected offsets have been
-   chosen so that approximately one call stub is allocated for every
-   86.7 instructions.  A long branch stub is two instructions when
-   not generating PIC code.  For HP-UX and ELF targets, PIC stubs are
-   seven and four instructions, respectively.  */  
-#define MAX_PCREL17F_OFFSET \
-  (flag_pic ? (TARGET_HPUX ? 198164 : 221312) : 240000)
+   head of the preceding stub table.  A long branch stub is two or three
+   instructions for non-PIC and PIC, respectively.  Import stubs are
+   seven and five instructions for HP-UX and ELF targets, respectively.
+   The default stub group size for ELF targets is 217856 bytes.
+   FIXME: We need an option to set the maximum offset.  */  
+#define MAX_PCREL17F_OFFSET (TARGET_HPUX ? 198164 : 217856)
 
 #define NEED_INDICATE_EXEC_STACK 0
 
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
index 84630ad536d..e273cddc01d 100644
--- a/gcc/config/pa/pa.md
+++ b/gcc/config/pa/pa.md
@@ -10091,23 +10091,55 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
    (set_attr "length" "4,16")])
 
 ;; PA 2.0 hardware supports out-of-order execution of loads and stores, so
-;; we need a memory barrier to enforce program order for memory references.
-;; Since we want PA 1.x code to be PA 2.0 compatible, we also need the
-;; barrier when generating PA 1.x code.
+;; we need memory barriers to enforce program order for memory references
+;; when the TLB and PSW O bits are not set.  We assume all PA 2.0 systems
+;; are weakly ordered since neither HP-UX or Linux set the PSW O bit.  Since
+;; we want PA 1.x code to be PA 2.0 compatible, we also need barriers when
+;; generating PA 1.x code even though all PA 1.x systems are strongly ordered.
+
+;; When barriers are needed, we use a strongly ordered ldcw instruction as
+;; the barrier.  Most PA 2.0 targets are cache coherent.  In that case, we
+;; can use the coherent cache control hint and avoid aligning the ldcw
+;; address.  In spite of its description, it is not clear that the sync
+;; instruction works as a barrier.
 
 (define_expand "memory_barrier"
-  [(set (match_dup 0)
-        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]
+  [(parallel
+     [(set (match_dup 0) (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))
+      (clobber (match_dup 1))])]
   ""
 {
-  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  /* We don't need a barrier if the target uses ordered memory references.  */
+  if (TARGET_ORDERED)
+    FAIL;
+  operands[1] = gen_reg_rtx (Pmode);
+  operands[0] = gen_rtx_MEM (BLKmode, operands[1]);
   MEM_VOLATILE_P (operands[0]) = 1;
 })
 
-(define_insn "*memory_barrier"
+(define_insn "*memory_barrier_coherent"
   [(set (match_operand:BLK 0 "" "")
-        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]
-  ""
-  "sync"
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))
+   (clobber (match_operand 1 "pmode_register_operand" "=r"))]
+  "TARGET_PA_20 && TARGET_COHERENT_LDCW"
+  "ldcw,co 0(%%sp),%1"
   [(set_attr "type" "binary")
    (set_attr "length" "4")])
+
+(define_insn "*memory_barrier_64"
+  [(set (match_operand:BLK 0 "" "")
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))
+    (clobber (match_operand 1 "pmode_register_operand" "=&r"))]
+  "TARGET_64BIT"
+  "ldo 15(%%sp),%1\n\tdepd %%r0,63,3,%1\n\tldcw 0(%1),%1"
+  [(set_attr "type" "binary")
+   (set_attr "length" "12")])
+
+(define_insn "*memory_barrier_32"
+  [(set (match_operand:BLK 0 "" "")
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))
+    (clobber (match_operand 1 "pmode_register_operand" "=&r"))]
+  ""
+  "ldo 15(%%sp),%1\n\t{dep|depw} %%r0,31,3,%1\n\tldcw 0(%1),%1"
+  [(set_attr "type" "binary")
+   (set_attr "length" "12")])
diff --git a/gcc/config/pa/pa.opt b/gcc/config/pa/pa.opt
index b32b3d8abc0..4cb81109933 100644
--- a/gcc/config/pa/pa.opt
+++ b/gcc/config/pa/pa.opt
@@ -45,6 +45,10 @@ mcaller-copies
 Target Report Mask(CALLER_COPIES)
 Caller copies function arguments passed by hidden reference.
 
+mcoherent-ldcw
+Target Report Var(TARGET_COHERENT_LDCW) Init(1)
+Use ldcw/ldcd coherent cache-control hint.
+
 mdisable-fpregs
 Target Report Mask(DISABLE_FPREGS)
 Disable FP regs.
@@ -90,6 +94,10 @@ mno-space-regs
 Target RejectNegative Report Mask(NO_SPACE_REGS)
 Disable space regs.
 
+mordered
+Target Report Var(TARGET_ORDERED) Init(0)
+Assume memory references are ordered and barriers are not needed.
+
 mpa-risc-1-0
 Target RejectNegative
 Generate PA1.0 code.
diff --git a/gcc/config/riscv/riscv-protos.h b/gcc/config/riscv/riscv-protos.h
index 8b510f87df8..5b0bbdd7cb4 100644
--- a/gcc/config/riscv/riscv-protos.h
+++ b/gcc/config/riscv/riscv-protos.h
@@ -44,10 +44,10 @@ extern int riscv_const_insns (rtx);
 extern int riscv_split_const_insns (rtx);
 extern int riscv_load_store_insns (rtx, rtx_insn *);
 extern rtx riscv_emit_move (rtx, rtx);
-extern bool riscv_split_symbol (rtx, rtx, machine_mode, rtx *);
+extern bool riscv_split_symbol (rtx, rtx, machine_mode, rtx *, bool);
 extern bool riscv_split_symbol_type (enum riscv_symbol_type);
 extern rtx riscv_unspec_address (rtx, enum riscv_symbol_type);
-extern void riscv_move_integer (rtx, rtx, HOST_WIDE_INT);
+extern void riscv_move_integer (rtx, rtx, HOST_WIDE_INT, bool);
 extern bool riscv_legitimize_move (machine_mode, rtx, rtx);
 extern rtx riscv_subword (rtx, bool);
 extern bool riscv_split_64bit_move_p (rtx, rtx);
diff --git a/gcc/config/riscv/riscv.c b/gcc/config/riscv/riscv.c
index 35219956c80..5cb295d3abb 100644
--- a/gcc/config/riscv/riscv.c
+++ b/gcc/config/riscv/riscv.c
@@ -508,8 +508,8 @@ riscv_split_integer (HOST_WIDE_INT val, machine_mode mode)
   unsigned HOST_WIDE_INT hival = sext_hwi ((val - loval) >> 32, 32);
   rtx hi = gen_reg_rtx (mode), lo = gen_reg_rtx (mode);
 
-  riscv_move_integer (hi, hi, hival);
-  riscv_move_integer (lo, lo, loval);
+  riscv_move_integer (hi, hi, hival, FALSE);
+  riscv_move_integer (lo, lo, loval, FALSE);
 
   hi = gen_rtx_fmt_ee (ASHIFT, mode, hi, GEN_INT (32));
   hi = force_reg (mode, hi);
@@ -1021,9 +1021,12 @@ riscv_force_binary (machine_mode mode, enum rtx_code code, rtx x, rtx y)
    are allowed, copy it into a new register, otherwise use DEST.  */
 
 static rtx
-riscv_force_temporary (rtx dest, rtx value)
+riscv_force_temporary (rtx dest, rtx value, bool in_splitter)
 {
-  if (can_create_pseudo_p ())
+  /* We can't call gen_reg_rtx from a splitter, because this might realloc
+     the regno_reg_rtx array, which would invalidate reg rtx pointers in the
+     combine undo buffer.  */
+  if (can_create_pseudo_p () && !in_splitter)
     return force_reg (Pmode, value);
   else
     {
@@ -1082,7 +1085,7 @@ static rtx
 riscv_unspec_offset_high (rtx temp, rtx addr, enum riscv_symbol_type symbol_type)
 {
   addr = gen_rtx_HIGH (Pmode, riscv_unspec_address (addr, symbol_type));
-  return riscv_force_temporary (temp, addr);
+  return riscv_force_temporary (temp, addr, FALSE);
 }
 
 /* Load an entry from the GOT for a TLS GD access.  */
@@ -1130,7 +1133,8 @@ static rtx riscv_tls_add_tp_le (rtx dest, rtx base, rtx sym)
    is guaranteed to be a legitimate address for mode MODE.  */
 
 bool
-riscv_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)
+riscv_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out,
+		    bool in_splitter)
 {
   enum riscv_symbol_type symbol_type;
 
@@ -1146,7 +1150,7 @@ riscv_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)
       case SYMBOL_ABSOLUTE:
 	{
 	  rtx high = gen_rtx_HIGH (Pmode, copy_rtx (addr));
-	  high = riscv_force_temporary (temp, high);
+	  high = riscv_force_temporary (temp, high, in_splitter);
 	  *low_out = gen_rtx_LO_SUM (Pmode, high, addr);
 	}
 	break;
@@ -1205,8 +1209,9 @@ riscv_add_offset (rtx temp, rtx reg, HOST_WIDE_INT offset)
 	 overflow, so we need to force a sign-extension check.  */
       high = gen_int_mode (CONST_HIGH_PART (offset), Pmode);
       offset = CONST_LOW_PART (offset);
-      high = riscv_force_temporary (temp, high);
-      reg = riscv_force_temporary (temp, gen_rtx_PLUS (Pmode, high, reg));
+      high = riscv_force_temporary (temp, high, FALSE);
+      reg = riscv_force_temporary (temp, gen_rtx_PLUS (Pmode, high, reg),
+				   FALSE);
     }
   return plus_constant (Pmode, reg, offset);
 }
@@ -1315,7 +1320,7 @@ riscv_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,
     return riscv_legitimize_tls_address (x);
 
   /* See if the address can split into a high part and a LO_SUM.  */
-  if (riscv_split_symbol (NULL, x, mode, &addr))
+  if (riscv_split_symbol (NULL, x, mode, &addr, FALSE))
     return riscv_force_address (addr, mode);
 
   /* Handle BASE + OFFSET using riscv_add_offset.  */
@@ -1337,17 +1342,23 @@ riscv_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,
 /* Load VALUE into DEST.  TEMP is as for riscv_force_temporary.  */
 
 void
-riscv_move_integer (rtx temp, rtx dest, HOST_WIDE_INT value)
+riscv_move_integer (rtx temp, rtx dest, HOST_WIDE_INT value,
+		    bool in_splitter)
 {
   struct riscv_integer_op codes[RISCV_MAX_INTEGER_OPS];
   machine_mode mode;
   int i, num_ops;
   rtx x;
 
+  /* We can't call gen_reg_rtx from a splitter, because this might realloc
+     the regno_reg_rtx array, which would invalidate reg rtx pointers in the
+     combine undo buffer.  */
+  bool can_create_pseudo = can_create_pseudo_p () && ! in_splitter;
+
   mode = GET_MODE (dest);
   num_ops = riscv_build_integer (codes, value, mode);
 
-  if (can_create_pseudo_p () && num_ops > 2 /* not a simple constant */
+  if (can_create_pseudo && num_ops > 2 /* not a simple constant */
       && num_ops >= riscv_split_integer_cost (value))
     x = riscv_split_integer (value, mode);
   else
@@ -1357,7 +1368,7 @@ riscv_move_integer (rtx temp, rtx dest, HOST_WIDE_INT value)
 
       for (i = 1; i < num_ops; i++)
 	{
-	  if (!can_create_pseudo_p ())
+	  if (!can_create_pseudo)
 	    x = riscv_emit_set (temp, x);
 	  else
 	    x = force_reg (mode, x);
@@ -1381,12 +1392,12 @@ riscv_legitimize_const_move (machine_mode mode, rtx dest, rtx src)
   /* Split moves of big integers into smaller pieces.  */
   if (splittable_const_int_operand (src, mode))
     {
-      riscv_move_integer (dest, dest, INTVAL (src));
+      riscv_move_integer (dest, dest, INTVAL (src), FALSE);
       return;
     }
 
   /* Split moves of symbolic constants into high/low pairs.  */
-  if (riscv_split_symbol (dest, src, MAX_MACHINE_MODE, &src))
+  if (riscv_split_symbol (dest, src, MAX_MACHINE_MODE, &src, FALSE))
     {
       riscv_emit_set (dest, src);
       return;
@@ -1407,7 +1418,7 @@ riscv_legitimize_const_move (machine_mode mode, rtx dest, rtx src)
   if (offset != const0_rtx
       && (targetm.cannot_force_const_mem (mode, src) || can_create_pseudo_p ()))
     {
-      base = riscv_force_temporary (dest, base);
+      base = riscv_force_temporary (dest, base, FALSE);
       riscv_emit_move (dest, riscv_add_offset (NULL, base, INTVAL (offset)));
       return;
     }
@@ -1416,7 +1427,7 @@ riscv_legitimize_const_move (machine_mode mode, rtx dest, rtx src)
 
   /* When using explicit relocs, constant pool references are sometimes
      not legitimate addresses.  */
-  riscv_split_symbol (dest, XEXP (src, 0), mode, &XEXP (src, 0));
+  riscv_split_symbol (dest, XEXP (src, 0), mode, &XEXP (src, 0), FALSE);
   riscv_emit_move (dest, src);
 }
 
diff --git a/gcc/config/riscv/riscv.md b/gcc/config/riscv/riscv.md
index a8bac170e72..e40535c9e40 100644
--- a/gcc/config/riscv/riscv.md
+++ b/gcc/config/riscv/riscv.md
@@ -1051,7 +1051,9 @@
   "@
    #
    lwu\t%0,%1"
-  "&& reload_completed && REG_P (operands[1])"
+  "&& reload_completed
+   && REG_P (operands[1])
+   && !paradoxical_subreg_p (operands[0])"
   [(set (match_dup 0)
 	(ashift:DI (match_dup 1) (const_int 32)))
    (set (match_dup 0)
@@ -1068,7 +1070,9 @@
   "@
    #
    lhu\t%0,%1"
-  "&& reload_completed && REG_P (operands[1])"
+  "&& reload_completed
+   && REG_P (operands[1])
+   && !paradoxical_subreg_p (operands[0])"
   [(set (match_dup 0)
 	(ashift:GPR (match_dup 1) (match_dup 2)))
    (set (match_dup 0)
@@ -1117,7 +1121,9 @@
   "@
    #
    l<SHORT:size>\t%0,%1"
-  "&& reload_completed && REG_P (operands[1])"
+  "&& reload_completed
+   && REG_P (operands[1])
+   && !paradoxical_subreg_p (operands[0])"
   [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 2)))
    (set (match_dup 0) (ashiftrt:SI (match_dup 0) (match_dup 2)))]
 {
@@ -1278,7 +1284,7 @@
   ""
   [(const_int 0)]
 {
-  riscv_move_integer (operands[2], operands[0], INTVAL (operands[1]));
+  riscv_move_integer (operands[2], operands[0], INTVAL (operands[1]), TRUE);
   DONE;
 })
 
@@ -1287,11 +1293,11 @@
   [(set (match_operand:P 0 "register_operand")
 	(match_operand:P 1))
    (clobber (match_operand:P 2 "register_operand"))]
-  "riscv_split_symbol (operands[2], operands[1], MAX_MACHINE_MODE, NULL)"
+  "riscv_split_symbol (operands[2], operands[1], MAX_MACHINE_MODE, NULL, TRUE)"
   [(set (match_dup 0) (match_dup 3))]
 {
   riscv_split_symbol (operands[2], operands[1],
-		     MAX_MACHINE_MODE, &operands[3]);
+		      MAX_MACHINE_MODE, &operands[3], TRUE);
 })
 
 ;; 64-bit integer moves
@@ -1765,15 +1771,20 @@
 ;; Handle AND with 2^N-1 for N from 12 to XLEN.  This can be split into
 ;; two logical shifts.  Otherwise it requires 3 instructions: lui,
 ;; xor/addi/srli, and.
+
+;; Generating a temporary for the shift output gives better combiner results;
+;; and also fixes a problem where op0 could be a paradoxical reg and shifting
+;; by amounts larger than the size of the SUBREG_REG doesn't work.
 (define_split
   [(set (match_operand:GPR 0 "register_operand")
 	(and:GPR (match_operand:GPR 1 "register_operand")
-		 (match_operand:GPR 2 "p2m1_shift_operand")))]
+		 (match_operand:GPR 2 "p2m1_shift_operand")))
+   (clobber (match_operand:GPR 3 "register_operand"))]
   ""
- [(set (match_dup 0)
+ [(set (match_dup 3)
        (ashift:GPR (match_dup 1) (match_dup 2)))
   (set (match_dup 0)
-       (lshiftrt:GPR (match_dup 0) (match_dup 2)))]
+       (lshiftrt:GPR (match_dup 3) (match_dup 2)))]
 {
   /* Op2 is a VOIDmode constant, so get the mode size from op1.  */
   operands[2] = GEN_INT (GET_MODE_BITSIZE (GET_MODE (operands[1]))
@@ -1785,12 +1796,13 @@
 (define_split
   [(set (match_operand:DI 0 "register_operand")
 	(and:DI (match_operand:DI 1 "register_operand")
-		(match_operand:DI 2 "high_mask_shift_operand")))]
+		(match_operand:DI 2 "high_mask_shift_operand")))
+   (clobber (match_operand:DI 3 "register_operand"))]
   "TARGET_64BIT"
-  [(set (match_dup 0)
+  [(set (match_dup 3)
 	(lshiftrt:DI (match_dup 1) (match_dup 2)))
    (set (match_dup 0)
-	(ashift:DI (match_dup 0) (match_dup 2)))]
+	(ashift:DI (match_dup 3) (match_dup 2)))]
 {
   operands[2] = GEN_INT (ctz_hwi (INTVAL (operands[2])));
 })
diff --git a/gcc/config/rs6000/altivec.md b/gcc/config/rs6000/altivec.md
index 4a1150e0994..654d756647c 100644
--- a/gcc/config/rs6000/altivec.md
+++ b/gcc/config/rs6000/altivec.md
@@ -80,9 +80,6 @@
    UNSPEC_VUPKHPX
    UNSPEC_VUPKLPX
    UNSPEC_CONVERT_4F32_8I16
-   UNSPEC_DARN
-   UNSPEC_DARN_32
-   UNSPEC_DARN_RAW
    UNSPEC_DST
    UNSPEC_DSTT
    UNSPEC_DSTST
@@ -161,9 +158,6 @@
    UNSPEC_BCDADD
    UNSPEC_BCDSUB
    UNSPEC_BCD_OVERFLOW
-   UNSPEC_CMPRB
-   UNSPEC_CMPRB2
-   UNSPEC_CMPEQB
    UNSPEC_VRLMI
    UNSPEC_VRLNM
 ])
@@ -566,7 +560,7 @@
   [(set_attr "type" "vecsimple")])
 
 ;;
-(define_insn "altivec_vavgu<VI_char>"
+(define_insn "uavg<mode>3_ceil"
   [(set (match_operand:VI 0 "register_operand" "=v")
         (unspec:VI [(match_operand:VI 1 "register_operand" "v")
                     (match_operand:VI 2 "register_operand" "v")]
@@ -575,7 +569,7 @@
   "vavgu<VI_char> %0,%1,%2"
   [(set_attr "type" "vecsimple")])
 
-(define_insn "altivec_vavgs<VI_char>"
+(define_insn "avg<mode>3_ceil"
   [(set (match_operand:VI 0 "register_operand" "=v")
         (unspec:VI [(match_operand:VI 1 "register_operand" "v")
                     (match_operand:VI 2 "register_operand" "v")]
@@ -4101,223 +4095,6 @@
   "bcd<bcd_add_sub>. %0,%1,%2,%3"
   [(set_attr "type" "vecsimple")])
 
-(define_insn "darn_32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (unspec:SI [(const_int 0)] UNSPEC_DARN_32))]
-  "TARGET_P9_MISC"
-  "darn %0,0"
-  [(set_attr "type" "integer")])
-
-(define_insn "darn_raw"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (unspec:DI [(const_int 0)] UNSPEC_DARN_RAW))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-  "darn %0,2"
-  [(set_attr "type" "integer")])
-
-(define_insn "darn"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (unspec:DI [(const_int 0)] UNSPEC_DARN))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-  "darn %0,1"
-  [(set_attr "type" "integer")])
-
-;; Test byte within range.
-;;
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the range specified by operand 2.
-;; The bytes of operand 2 are organized as xx:xx:hi:lo.
-;;
-;; Return in target register operand 0 a value of 1 if lo <= vv and
-;; vv <= hi.  Otherwise, set register operand 0 to 0.
-;;
-;; Though the instructions to which this expansion maps operate on
-;; 64-bit registers, the current implementation only operates on
-;; SI-mode operands as the high-order bits provide no information
-;; that is not already available in the low-order bits.  To avoid the
-;; costs of data widening operations, future enhancements might allow
-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
-(define_expand "cmprb"
-  [(set (match_dup 3)
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB))
-   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	(if_then_else:SI (lt (match_dup 3)
-			     (const_int 0))
-			 (const_int -1)
-			 (if_then_else (gt (match_dup 3)
-					   (const_int 0))
-				       (const_int 1)
-				       (const_int 0))))]
-  "TARGET_P9_MISC"
-{
-  operands[3] = gen_reg_rtx (CCmode);
-})
-
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the range specified by operand 2.
-;; The bytes of operand 2 are organized as xx:xx:hi:lo.
-;;
-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
-;; lo <= vv and vv <= hi.  Otherwise, set the GT bit to 0.  The other
-;; 3 bits of the target CR register are all set to 0.
-(define_insn "*cmprb_internal"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB))]
-  "TARGET_P9_MISC"
-  "cmprb %0,0,%1,%2"
-  [(set_attr "type" "logical")])
-
-;; Set operand 0 register to -1 if the LT bit (0x8) of condition
-;; register operand 1 is on.  Otherwise, set operand 0 register to 1
-;; if the GT bit (0x4) of condition register operand 1 is on.
-;; Otherwise, set operand 0 to 0.  Note that the result stored into
-;; register operand 0 is non-zero iff either the LT or GT bits are on
-;; within condition register operand 1.
-(define_insn "setb_signed"
-   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	 (if_then_else:SI (lt (match_operand:CC 1 "cc_reg_operand" "y")
-			      (const_int 0))
-			  (const_int -1)
-			  (if_then_else (gt (match_dup 1)
-					    (const_int 0))
-					(const_int 1)
-					(const_int 0))))]
-  "TARGET_P9_MISC"
-  "setb %0,%1"
-  [(set_attr "type" "logical")])
-
-(define_insn "setb_unsigned"
-   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	 (if_then_else:SI (ltu (match_operand:CCUNS 1 "cc_reg_operand" "y")
-			      (const_int 0))
-			  (const_int -1)
-			  (if_then_else (gtu (match_dup 1)
-					    (const_int 0))
-					(const_int 1)
-					(const_int 0))))]
-  "TARGET_P9_MISC"
-  "setb %0,%1"
-  [(set_attr "type" "logical")])
-
-;; Test byte within two ranges.
-;;
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the range specified by operand 2.
-;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
-;;
-;; Return in target register operand 0 a value of 1 if (lo_1 <= vv and
-;; vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).  Otherwise, set register
-;; operand 0 to 0.
-;;
-;; Though the instructions to which this expansion maps operate on
-;; 64-bit registers, the current implementation only operates on
-;; SI-mode operands as the high-order bits provide no information
-;; that is not already available in the low-order bits.  To avoid the
-;; costs of data widening operations, future enhancements might allow
-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
-(define_expand "cmprb2"
-  [(set (match_dup 3)
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB2))
-   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	(if_then_else:SI (lt (match_dup 3)
-			     (const_int 0))
-			 (const_int -1)
-			 (if_then_else (gt (match_dup 3)
-					   (const_int 0))
-				       (const_int 1)
-				       (const_int 0))))]
-  "TARGET_P9_MISC"
-{
-  operands[3] = gen_reg_rtx (CCmode);
-})
-
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the ranges specified by operand 2.
-;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
-;;
-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
-;; (lo_1 <= vv and vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).
-;; Otherwise, set the GT bit to 0.  The other 3 bits of the target
-;; CR register are all set to 0.
-(define_insn "*cmprb2_internal"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB2))]
-  "TARGET_P9_MISC"
-  "cmprb %0,1,%1,%2"
-  [(set_attr "type" "logical")])
-
-;; Test byte membership within set of 8 bytes.
-;;
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the set specified by operand 2.
-;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
-;;
-;; Return in target register operand 0 a value of 1 if vv equals one
-;; of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise, set
-;; register operand 0 to 0.  Note that the 8 byte values held within
-;; operand 2 need not be unique.
-;;
-;; Though the instructions to which this expansion maps operate on
-;; 64-bit registers, the current implementation requires that operands
-;; 0 and 1 have mode SI as the high-order bits provide no information
-;; that is not already available in the low-order bits.  To avoid the
-;; costs of data widening operations, future enhancements might allow
-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
-(define_expand "cmpeqb"
-  [(set (match_dup 3)
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:DI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPEQB))
-   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	(if_then_else:SI (lt (match_dup 3)
-			     (const_int 0))
-			 (const_int -1)
-			 (if_then_else (gt (match_dup 3)
-					   (const_int 0))
-				       (const_int 1)
-				       (const_int 0))))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-{
-  operands[3] = gen_reg_rtx (CCmode);
-})
-
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the set specified by operand 2.
-;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
-;;
-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if vv
-;; equals one of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise,
-;; set the GT bit to zero.  The other 3 bits of the target CR register
-;; are all set to 0.
-(define_insn "*cmpeqb_internal"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	 (unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		     (match_operand:DI 2 "gpc_reg_operand" "r")]
-	  UNSPEC_CMPEQB))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-  "cmpeqb %0,%1,%2"
-  [(set_attr "type" "logical")])
-
 (define_expand "bcd<bcd_add_sub>_<code>"
   [(parallel [(set (reg:CCFP CR6_REGNO)
 		   (compare:CCFP
diff --git a/gcc/config/rs6000/darwin.h b/gcc/config/rs6000/darwin.h
index d3a59f42c37..e36de59ca25 100644
--- a/gcc/config/rs6000/darwin.h
+++ b/gcc/config/rs6000/darwin.h
@@ -53,19 +53,28 @@
 #define TARGET_OS_CPP_BUILTINS()			\
   do							\
     {							\
-      if (!TARGET_64BIT) builtin_define ("__ppc__");	\
-      if (!TARGET_64BIT) builtin_define ("__PPC__");	\
-      if (TARGET_64BIT) builtin_define ("__ppc64__");	\
-      if (TARGET_64BIT) builtin_define ("__PPC64__");	\
       builtin_define ("__POWERPC__");			\
+      builtin_define ("__PPC__");			\
+      if (TARGET_64BIT)					\
+	{						\
+	  builtin_define ("__ppc64__");			\
+	  builtin_define ("__PPC64__");			\
+	  builtin_define ("__powerpc64__");		\
+	  builtin_assert ("cpu=powerpc64");		\
+	  builtin_assert ("machine=powerpc64");		\
+	}						\
+      else						\
+	{						\
+	  builtin_define ("__ppc__");			\
+	  builtin_define_std ("PPC");			\
+	  builtin_assert ("cpu=powerpc");		\
+	  builtin_assert ("machine=powerpc");		\
+	}						\
       builtin_define ("__NATURAL_ALIGNMENT__");		\
       darwin_cpp_builtins (pfile);			\
     }							\
   while (0)
 
-/* Generate branch islands stubs if this is true.  */
-extern int darwin_emit_branch_islands;
-
 #define SUBTARGET_OVERRIDE_OPTIONS darwin_rs6000_override_options ()
 
 #define C_COMMON_OVERRIDE_OPTIONS do {					\
@@ -127,9 +136,30 @@ extern int darwin_emit_branch_islands;
    %:version-compare(>< 10.5 10.7 mmacosx-version-min= -lcrt1.10.5.o)	\
    %{fgnu-tm: -lcrttms.o}"
 
-/* crt2.o is at least partially required for 10.3.x and earlier.  */
+/* crt2.o is at least partially required for 10.3.x and earlier.
+   It deals with registration of the unwind frames, where this is not
+   automatically provided by the system.  So we need it for any case that
+   might use exceptions.  */
+#undef DARWIN_CRT2_SPEC
 #define DARWIN_CRT2_SPEC \
-  "%{!m64:%:version-compare(!> 10.4 mmacosx-version-min= crt2.o%s)}"
+"%{!m64:%{shared-libgcc|static-libstdc++|fexceptions|fobjc-exceptions|fgnu-runtime: \
+   %:version-compare(!> 10.4 mmacosx-version-min= crt2.o%s) \
+  }}"
+
+/* crt3 deals with providing cxa_atexit on earlier systems (or fixing it up,
+   for broken versions).  It's only needed for c++ code, so we can make it
+   conditional on shared-libgcc since that's forced on for c++.  */
+#undef DARWIN_CRT3_SPEC
+#define DARWIN_CRT3_SPEC \
+"%{!m64:%{shared-libgcc|static-libstdc++:							\
+   %:version-compare(>< 10.4 10.5 mmacosx-version-min= crt3.o%s) \
+   %:version-compare(!> 10.4 mmacosx-version-min= crt3_2.o%s) \
+  }}"
+
+/* The PPC regs save/restore functions are leaves and could, conceivably
+   be used by the tm destructor.  */
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC TM_DESTRUCTOR " -lef_ppc"
 
 #undef SUBTARGET_EXTRA_SPECS
 #define SUBTARGET_EXTRA_SPECS			\
@@ -279,9 +309,9 @@ extern int darwin_emit_branch_islands;
 /* This is supported in cctools 465 and later.  The macro test
    above prevents using it in earlier build environments.  */
 #define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP)          \
-  if ((LOG) != 0)                                             \
+  if ((LOG) > 0)                                             \
     {                                                         \
-      if ((MAX_SKIP) == 0)                                    \
+      if ((MAX_SKIP) <= 0)                                    \
         fprintf ((FILE), "\t.p2align %d\n", (LOG));           \
       else                                                    \
         fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP)); \
@@ -456,6 +486,9 @@ do {									\
    this will need to be modified similar to the x86 case.  */
 #define TARGET_FOLD_BUILTIN SUBTARGET_FOLD_BUILTIN
 
+/* First available SYMBOL flag bit for use by subtargets.  */
+#define SYMBOL_FLAG_SUBT_DEP (SYMBOL_FLAG_MACH_DEP)
+
 /* Use standard DWARF numbering for DWARF debugging information.  */
 #define RS6000_USE_DWARF_NUMBERING
 
diff --git a/gcc/config/rs6000/darwin.md b/gcc/config/rs6000/darwin.md
index 471058dd417..a1a46a9e7ea 100644
--- a/gcc/config/rs6000/darwin.md
+++ b/gcc/config/rs6000/darwin.md
@@ -122,33 +122,6 @@ You should have received a copy of the GNU General Public License
   [(set_attr "type" "store")])
 
 ;; 64-bit MachO load/store support
-(define_insn "movdi_low"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,*!d")
-        (mem:DI (lo_sum:DI (match_operand:DI 1 "gpc_reg_operand" "b,b")
-                           (match_operand 2 "" ""))))]
-  "TARGET_MACHO && TARGET_64BIT"
-  "@
-   ld %0,lo16(%2)(%1)
-   lfd %0,lo16(%2)(%1)"
-  [(set_attr "type" "load")])
-
-(define_insn "movsi_low_st"
-  [(set (mem:SI (lo_sum:SI (match_operand:SI 1 "gpc_reg_operand" "b")
-                           (match_operand 2 "" "")))
-	(match_operand:SI 0 "gpc_reg_operand" "r"))]
-  "TARGET_MACHO && ! TARGET_64BIT"
-  "stw %0,lo16(%2)(%1)"
-  [(set_attr "type" "store")])
-
-(define_insn "movdi_low_st"
-  [(set (mem:DI (lo_sum:DI (match_operand:DI 1 "gpc_reg_operand" "b,b")
-                           (match_operand 2 "" "")))
-	(match_operand:DI 0 "gpc_reg_operand" "r,*!d"))]
-  "TARGET_MACHO && TARGET_64BIT"
-  "@
-   std %0,lo16(%2)(%1)
-   stfd %0,lo16(%2)(%1)"
-  [(set_attr "type" "store")])
 
 ;; Mach-O PIC trickery.
 (define_expand "macho_high"
diff --git a/gcc/config/rs6000/rs6000-builtin.def b/gcc/config/rs6000/rs6000-builtin.def
index 0a2bdb79e15..0feee7cafca 100644
--- a/gcc/config/rs6000/rs6000-builtin.def
+++ b/gcc/config/rs6000/rs6000-builtin.def
@@ -1002,12 +1002,12 @@ BU_ALTIVEC_2 (VADDUWS,	      "vadduws",	CONST,	altivec_vadduws)
 BU_ALTIVEC_2 (VADDSWS,	      "vaddsws",	CONST,	altivec_vaddsws)
 BU_ALTIVEC_2 (VAND,	      "vand",		CONST,	andv4si3)
 BU_ALTIVEC_2 (VANDC,	      "vandc",		CONST,	andcv4si3)
-BU_ALTIVEC_2 (VAVGUB,	      "vavgub",		CONST,	altivec_vavgub)
-BU_ALTIVEC_2 (VAVGSB,	      "vavgsb",		CONST,	altivec_vavgsb)
-BU_ALTIVEC_2 (VAVGUH,	      "vavguh",		CONST,	altivec_vavguh)
-BU_ALTIVEC_2 (VAVGSH,	      "vavgsh",		CONST,	altivec_vavgsh)
-BU_ALTIVEC_2 (VAVGUW,	      "vavguw",		CONST,	altivec_vavguw)
-BU_ALTIVEC_2 (VAVGSW,	      "vavgsw",		CONST,	altivec_vavgsw)
+BU_ALTIVEC_2 (VAVGUB,	      "vavgub",		CONST,	uavgv16qi3_ceil)
+BU_ALTIVEC_2 (VAVGSB,	      "vavgsb",		CONST,	avgv16qi3_ceil)
+BU_ALTIVEC_2 (VAVGUH,	      "vavguh",		CONST,	uavgv8hi3_ceil)
+BU_ALTIVEC_2 (VAVGSH,	      "vavgsh",		CONST,	avgv8hi3_ceil)
+BU_ALTIVEC_2 (VAVGUW,	      "vavguw",		CONST,	uavgv4si3_ceil)
+BU_ALTIVEC_2 (VAVGSW,	      "vavgsw",		CONST,	avgv4si3_ceil)
 BU_ALTIVEC_2 (VCFUX,	      "vcfux",		CONST,	altivec_vcfux)
 BU_ALTIVEC_2 (VCFSX,	      "vcfsx",		CONST,	altivec_vcfsx)
 BU_ALTIVEC_2 (VCMPBFP,	      "vcmpbfp",	CONST,	altivec_vcmpbfp)
@@ -1177,26 +1177,26 @@ BU_ALTIVEC_X (MTVSCR,		"mtvscr",	    MISC)
 BU_ALTIVEC_X (MFVSCR,		"mfvscr",	    MISC)
 BU_ALTIVEC_X (DSSALL,		"dssall",	    MISC)
 BU_ALTIVEC_X (DSS,		"dss",		    MISC)
-BU_ALTIVEC_X (LVSL,		"lvsl",		    MEM)
-BU_ALTIVEC_X (LVSR,		"lvsr",		    MEM)
-BU_ALTIVEC_X (LVEBX,		"lvebx",	    MEM)
-BU_ALTIVEC_X (LVEHX,		"lvehx",	    MEM)
-BU_ALTIVEC_X (LVEWX,		"lvewx",	    MEM)
-BU_ALTIVEC_X (LVXL,		"lvxl",		    MEM)
-BU_ALTIVEC_X (LVXL_V2DF,	"lvxl_v2df",	    MEM)
-BU_ALTIVEC_X (LVXL_V2DI,	"lvxl_v2di",	    MEM)
-BU_ALTIVEC_X (LVXL_V4SF,	"lvxl_v4sf",	    MEM)
-BU_ALTIVEC_X (LVXL_V4SI,	"lvxl_v4si",	    MEM)
-BU_ALTIVEC_X (LVXL_V8HI,	"lvxl_v8hi",	    MEM)
-BU_ALTIVEC_X (LVXL_V16QI,	"lvxl_v16qi",	    MEM)
-BU_ALTIVEC_X (LVX,		"lvx",		    MEM)
-BU_ALTIVEC_X (LVX_V1TI,		"lvx_v1ti",	    MEM)
-BU_ALTIVEC_X (LVX_V2DF,		"lvx_v2df",	    MEM)
-BU_ALTIVEC_X (LVX_V2DI,		"lvx_v2di",	    MEM)
-BU_ALTIVEC_X (LVX_V4SF,		"lvx_v4sf",	    MEM)
-BU_ALTIVEC_X (LVX_V4SI,		"lvx_v4si",	    MEM)
-BU_ALTIVEC_X (LVX_V8HI,		"lvx_v8hi",	    MEM)
-BU_ALTIVEC_X (LVX_V16QI,	"lvx_v16qi",	    MEM)
+BU_ALTIVEC_X (LVSL,		"lvsl",		    PURE)
+BU_ALTIVEC_X (LVSR,		"lvsr",		    PURE)
+BU_ALTIVEC_X (LVEBX,		"lvebx",	    PURE)
+BU_ALTIVEC_X (LVEHX,		"lvehx",	    PURE)
+BU_ALTIVEC_X (LVEWX,		"lvewx",	    PURE)
+BU_ALTIVEC_X (LVXL,		"lvxl",		    PURE)
+BU_ALTIVEC_X (LVXL_V2DF,	"lvxl_v2df",	    PURE)
+BU_ALTIVEC_X (LVXL_V2DI,	"lvxl_v2di",	    PURE)
+BU_ALTIVEC_X (LVXL_V4SF,	"lvxl_v4sf",	    PURE)
+BU_ALTIVEC_X (LVXL_V4SI,	"lvxl_v4si",	    PURE)
+BU_ALTIVEC_X (LVXL_V8HI,	"lvxl_v8hi",	    PURE)
+BU_ALTIVEC_X (LVXL_V16QI,	"lvxl_v16qi",	    PURE)
+BU_ALTIVEC_X (LVX,		"lvx",		    PURE)
+BU_ALTIVEC_X (LVX_V1TI,		"lvx_v1ti",	    PURE)
+BU_ALTIVEC_X (LVX_V2DF,		"lvx_v2df",	    PURE)
+BU_ALTIVEC_X (LVX_V2DI,		"lvx_v2di",	    PURE)
+BU_ALTIVEC_X (LVX_V4SF,		"lvx_v4sf",	    PURE)
+BU_ALTIVEC_X (LVX_V4SI,		"lvx_v4si",	    PURE)
+BU_ALTIVEC_X (LVX_V8HI,		"lvx_v8hi",	    PURE)
+BU_ALTIVEC_X (LVX_V16QI,	"lvx_v16qi",	    PURE)
 BU_ALTIVEC_X (STVX,		"stvx",		    MEM)
 BU_ALTIVEC_X (STVX_V2DF,	"stvx_v2df",	    MEM)
 BU_ALTIVEC_X (STVX_V2DI,	"stvx_v2di",	    MEM)
@@ -1204,10 +1204,10 @@ BU_ALTIVEC_X (STVX_V4SF,	"stvx_v4sf",	    MEM)
 BU_ALTIVEC_X (STVX_V4SI,	"stvx_v4si",	    MEM)
 BU_ALTIVEC_X (STVX_V8HI,	"stvx_v8hi",	    MEM)
 BU_ALTIVEC_X (STVX_V16QI,	"stvx_v16qi",	    MEM)
-BU_ALTIVEC_C (LVLX,		"lvlx",		    MEM)
-BU_ALTIVEC_C (LVLXL,		"lvlxl",	    MEM)
-BU_ALTIVEC_C (LVRX,		"lvrx",		    MEM)
-BU_ALTIVEC_C (LVRXL,		"lvrxl",	    MEM)
+BU_ALTIVEC_C (LVLX,		"lvlx",		    PURE)
+BU_ALTIVEC_C (LVLXL,		"lvlxl",	    PURE)
+BU_ALTIVEC_C (LVRX,		"lvrx",		    PURE)
+BU_ALTIVEC_C (LVRXL,		"lvrxl",	    PURE)
 BU_ALTIVEC_X (STVEBX,		"stvebx",	    MEM)
 BU_ALTIVEC_X (STVEHX,		"stvehx",	    MEM)
 BU_ALTIVEC_X (STVEWX,		"stvewx",	    MEM)
@@ -1718,15 +1718,15 @@ BU_VSX_P (XVCMPGEDP_P,	      "xvcmpgedp_p",	CONST,	vector_ge_v2df_p)
 BU_VSX_P (XVCMPGTDP_P,	      "xvcmpgtdp_p",	CONST,	vector_gt_v2df_p)
 
 /* VSX builtins that are handled as special cases.  */
-BU_VSX_X (LXSDX,	      "lxsdx",		MEM)
-BU_VSX_X (LXVD2X_V1TI,	      "lxvd2x_v1ti",	MEM)
-BU_VSX_X (LXVD2X_V2DF,	      "lxvd2x_v2df",	MEM)
-BU_VSX_X (LXVD2X_V2DI,	      "lxvd2x_v2di",	MEM)
-BU_VSX_X (LXVDSX,	      "lxvdsx",		MEM)
-BU_VSX_X (LXVW4X_V4SF,	      "lxvw4x_v4sf",	MEM)
-BU_VSX_X (LXVW4X_V4SI,        "lxvw4x_v4si",	MEM)
-BU_VSX_X (LXVW4X_V8HI,        "lxvw4x_v8hi",	MEM)
-BU_VSX_X (LXVW4X_V16QI,	      "lxvw4x_v16qi",	MEM)
+BU_VSX_X (LXSDX,	      "lxsdx",		PURE)
+BU_VSX_X (LXVD2X_V1TI,	      "lxvd2x_v1ti",	PURE)
+BU_VSX_X (LXVD2X_V2DF,	      "lxvd2x_v2df",	PURE)
+BU_VSX_X (LXVD2X_V2DI,	      "lxvd2x_v2di",	PURE)
+BU_VSX_X (LXVDSX,	      "lxvdsx",		PURE)
+BU_VSX_X (LXVW4X_V4SF,	      "lxvw4x_v4sf",	PURE)
+BU_VSX_X (LXVW4X_V4SI,	      "lxvw4x_v4si",	PURE)
+BU_VSX_X (LXVW4X_V8HI,	      "lxvw4x_v8hi",	PURE)
+BU_VSX_X (LXVW4X_V16QI,	      "lxvw4x_v16qi",	PURE)
 BU_VSX_X (STXSDX,	      "stxsdx",		MEM)
 BU_VSX_X (STXVD2X_V1TI,	      "stxvd2x_v1ti",	MEM)
 BU_VSX_X (STXVD2X_V2DF,	      "stxvd2x_v2df",	MEM)
@@ -1735,13 +1735,13 @@ BU_VSX_X (STXVW4X_V4SF,	      "stxvw4x_v4sf",	MEM)
 BU_VSX_X (STXVW4X_V4SI,	      "stxvw4x_v4si",	MEM)
 BU_VSX_X (STXVW4X_V8HI,	      "stxvw4x_v8hi",	MEM)
 BU_VSX_X (STXVW4X_V16QI,      "stxvw4x_v16qi",	MEM)
-BU_VSX_X (LD_ELEMREV_V1TI,    "ld_elemrev_v1ti",  MEM)
-BU_VSX_X (LD_ELEMREV_V2DF,    "ld_elemrev_v2df",  MEM)
-BU_VSX_X (LD_ELEMREV_V2DI,    "ld_elemrev_v2di",  MEM)
-BU_VSX_X (LD_ELEMREV_V4SF,    "ld_elemrev_v4sf",  MEM)
-BU_VSX_X (LD_ELEMREV_V4SI,    "ld_elemrev_v4si",  MEM)
-BU_VSX_X (LD_ELEMREV_V8HI,    "ld_elemrev_v8hi",  MEM)
-BU_VSX_X (LD_ELEMREV_V16QI,   "ld_elemrev_v16qi", MEM)
+BU_VSX_X (LD_ELEMREV_V1TI,    "ld_elemrev_v1ti",  PURE)
+BU_VSX_X (LD_ELEMREV_V2DF,    "ld_elemrev_v2df",  PURE)
+BU_VSX_X (LD_ELEMREV_V2DI,    "ld_elemrev_v2di",  PURE)
+BU_VSX_X (LD_ELEMREV_V4SF,    "ld_elemrev_v4sf",  PURE)
+BU_VSX_X (LD_ELEMREV_V4SI,    "ld_elemrev_v4si",  PURE)
+BU_VSX_X (LD_ELEMREV_V8HI,    "ld_elemrev_v8hi",  PURE)
+BU_VSX_X (LD_ELEMREV_V16QI,   "ld_elemrev_v16qi", PURE)
 BU_VSX_X (ST_ELEMREV_V1TI,    "st_elemrev_v1ti",  MEM)
 BU_VSX_X (ST_ELEMREV_V2DF,    "st_elemrev_v2df",  MEM)
 BU_VSX_X (ST_ELEMREV_V2DI,    "st_elemrev_v2di",  MEM)
diff --git a/gcc/config/rs6000/rs6000-p8swap.c b/gcc/config/rs6000/rs6000-p8swap.c
index c3b98315503..d30e5dec980 100644
--- a/gcc/config/rs6000/rs6000-p8swap.c
+++ b/gcc/config/rs6000/rs6000-p8swap.c
@@ -791,6 +791,11 @@ rtx_is_swappable_p (rtx op, unsigned int *special)
 	  case UNSPEC_REDUC_PLUS:
 	  case UNSPEC_REDUC:
 	    return 1;
+	  case UNSPEC_VPMSUM:
+	    /* vpmsumd is not swappable, but vpmsum[bhw] are.  */
+	    if (GET_MODE (op) == V2DImode)
+	      return 0;
+	    break;
 	  }
       }
 
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index cb8d737976b..a670096145b 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -7671,6 +7671,104 @@ address_offset (rtx op)
   return NULL_RTX;
 }
 
+/* This tests that a lo_sum {constant, symbol, symbol+offset} is valid for
+   the mode.  If we can't find (or don't know) the alignment of the symbol
+   we assume (optimistically) that it's sufficiently aligned [??? maybe we
+   should be pessimistic].  Offsets are validated in the same way as for
+   reg + offset.  */
+static bool
+darwin_rs6000_legitimate_lo_sum_const_p (rtx x, machine_mode mode)
+{
+  /* We should not get here with this.  */
+  gcc_checking_assert (! mode_supports_dq_form (mode));
+
+  if (GET_CODE (x) == CONST)
+    x = XEXP (x, 0);
+
+  if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_MACHOPIC_OFFSET)
+    x =  XVECEXP (x, 0, 0);
+
+  rtx sym = NULL_RTX;
+  unsigned HOST_WIDE_INT offset = 0;
+
+  if (GET_CODE (x) == PLUS)
+    {
+      sym = XEXP (x, 0);
+      if (! SYMBOL_REF_P (sym))
+	return false;
+      if (!CONST_INT_P (XEXP (x, 1)))
+	return false;
+      offset = INTVAL (XEXP (x, 1));
+    }
+  else if (SYMBOL_REF_P (x))
+    sym = x;
+  else if (CONST_INT_P (x))
+    offset = INTVAL (x);
+  else if (GET_CODE (x) == LABEL_REF)
+    offset = 0; // We assume code labels are Pmode aligned
+  else
+    return false; // not sure what we have here.
+
+  /* If we don't know the alignment of the thing to which the symbol refers,
+     we assume optimistically it is "enough".
+     ??? maybe we should be pessimistic instead.  */
+  unsigned align = 0;
+
+  if (sym)
+    {
+      tree decl = SYMBOL_REF_DECL (sym);
+#if TARGET_MACHO
+      if (MACHO_SYMBOL_INDIRECTION_P (sym))
+      /* The decl in an indirection symbol is the original one, which might
+	 be less aligned than the indirection.  Our indirections are always
+	 pointer-aligned.  */
+	;
+      else
+#endif
+      if (decl && DECL_ALIGN (decl))
+	align = DECL_ALIGN_UNIT (decl);
+   }
+
+  unsigned int extra = 0;
+  switch (mode)
+    {
+    case E_DFmode:
+    case E_DDmode:
+    case E_DImode:
+      /* If we are using VSX scalar loads, restrict ourselves to reg+reg
+	 addressing.  */
+      if (VECTOR_MEM_VSX_P (mode))
+	return false;
+
+      if (!TARGET_POWERPC64)
+	extra = 4;
+      else if ((offset & 3) || (align & 3))
+	return false;
+      break;
+
+    case E_TFmode:
+    case E_IFmode:
+    case E_KFmode:
+    case E_TDmode:
+    case E_TImode:
+    case E_PTImode:
+      extra = 8;
+      if (!TARGET_POWERPC64)
+	extra = 12;
+      else if ((offset & 3) || (align & 3))
+	return false;
+      break;
+
+    default:
+      break;
+    }
+
+  /* We only care if the access(es) would cause a change to the high part.  */
+  offset = ((offset & 0xffff) ^ 0x8000) - 0x8000;
+  return IN_RANGE (offset, -(HOST_WIDE_INT_1 << 15),
+                            (HOST_WIDE_INT_1 << 15) - 1 - extra);
+}
+
 /* Return true if the MEM operand is a memory operand suitable for use
    with a (full width, possibly multiple) gpr load/store.  On
    powerpc64 this means the offset must be divisible by 4.
@@ -7705,7 +7803,13 @@ mem_operand_gpr (rtx op, machine_mode mode)
       && legitimate_indirect_address_p (XEXP (addr, 0), false))
     return true;
 
-  /* Don't allow non-offsettable addresses.  See PRs 83969 and 84279.  */
+  /* We need to look through Mach-O PIC unspecs to determine if a lo_sum is
+     really OK.  Doing this early avoids teaching all the other machinery
+     about them.  */
+  if (TARGET_MACHO && GET_CODE (addr) == LO_SUM)
+    return darwin_rs6000_legitimate_lo_sum_const_p (XEXP (addr, 1), mode);
+
+  /* Only allow offsettable addresses.  See PRs 83969 and 84279.  */
   if (!rs6000_offsettable_memref_p (op, mode, false))
     return false;
 
@@ -21330,7 +21434,7 @@ print_operand (FILE *file, rtx x, int code)
 	{
 	  const char *name = XSTR (x, 0);
 #if TARGET_MACHO
-	  if (darwin_emit_branch_islands
+	  if (darwin_symbol_stubs
 	      && MACHOPIC_INDIRECT
 	      && machopic_classify_symbol (x) == MACHOPIC_UNDEFINED_FUNCTION)
 	    name = machopic_indirection_name (x, /*stub_p=*/true);
@@ -25729,10 +25833,14 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, rtx copy_reg, int copy_off)
 						    stack_limit_rtx,
 						    GEN_INT (size)));
 
-	  emit_insn (gen_elf_high (tmp_reg, toload));
-	  emit_insn (gen_elf_low (tmp_reg, tmp_reg, toload));
-	  emit_insn (gen_cond_trap (LTU, stack_reg, tmp_reg,
-				    const0_rtx));
+	  /* We cannot use r0 with elf_low.  Lamely solve this problem by
+	     moving registers around.  */
+	  rtx r11_reg = gen_rtx_REG (Pmode, 11);
+	  emit_move_insn (tmp_reg, r11_reg);
+	  emit_insn (gen_elf_high (r11_reg, toload));
+	  emit_insn (gen_elf_low (r11_reg, r11_reg, toload));
+	  emit_insn (gen_cond_trap (LTU, stack_reg, r11_reg, const0_rtx));
+	  emit_move_insn (r11_reg, tmp_reg);
 	}
       else
 	warning (0, "stack limit expression is not supported");
@@ -37762,25 +37870,31 @@ rs6000_can_inline_p (tree caller, tree callee)
   tree caller_tree = DECL_FUNCTION_SPECIFIC_TARGET (caller);
   tree callee_tree = DECL_FUNCTION_SPECIFIC_TARGET (callee);
 
-  /* If callee has no option attributes, then it is ok to inline.  */
+  /* If the callee has no option attributes, then it is ok to inline.  */
   if (!callee_tree)
     ret = true;
 
-  /* If caller has no option attributes, but callee does then it is not ok to
-     inline.  */
-  else if (!caller_tree)
-    ret = false;
-
   else
     {
-      struct cl_target_option *caller_opts = TREE_TARGET_OPTION (caller_tree);
+      HOST_WIDE_INT caller_isa;
       struct cl_target_option *callee_opts = TREE_TARGET_OPTION (callee_tree);
+      HOST_WIDE_INT callee_isa = callee_opts->x_rs6000_isa_flags;
+      HOST_WIDE_INT explicit_isa = callee_opts->x_rs6000_isa_flags_explicit;
 
-      /* Callee's options should a subset of the caller's, i.e. a vsx function
-	 can inline an altivec function but a non-vsx function can't inline a
-	 vsx function.  */
-      if ((caller_opts->x_rs6000_isa_flags & callee_opts->x_rs6000_isa_flags)
-	  == callee_opts->x_rs6000_isa_flags)
+      /* If the caller has option attributes, then use them.
+	 Otherwise, use the command line options.  */
+      if (caller_tree)
+	caller_isa = TREE_TARGET_OPTION (caller_tree)->x_rs6000_isa_flags;
+      else
+	caller_isa = rs6000_isa_flags;
+
+      /* The callee's options must be a subset of the caller's options, i.e.
+	 a vsx function may inline an altivec function, but a no-vsx function
+	 must not inline a vsx function.  However, for those options that the
+	 callee has explicitly enabled or disabled, then we must enforce that
+	 the callee's and caller's options match exactly; see PR70010.  */
+      if (((caller_isa & callee_isa) == callee_isa)
+	  && (caller_isa & explicit_isa) == (callee_isa & explicit_isa))
 	ret = true;
     }
 
@@ -38273,7 +38387,8 @@ rs6000_call_darwin_1 (rtx value, rtx func_desc, rtx tlsarg,
   if ((cookie_val & CALL_LONG) != 0
       && GET_CODE (func_desc) == SYMBOL_REF)
     {
-      if (darwin_emit_branch_islands && TARGET_32BIT)
+      /* FIXME: the longcall opt should not hang off picsymbol stubs.  */
+      if (darwin_symbol_stubs && TARGET_32BIT)
 	make_island = true; /* Do nothing yet, retain the CALL_LONG flag.  */
       else
 	{
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index ad80592765d..b3469a17f27 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -137,6 +137,9 @@
    UNSPEC_LSQ
    UNSPEC_FUSION_GPR
    UNSPEC_STACK_CHECK
+   UNSPEC_CMPRB
+   UNSPEC_CMPRB2
+   UNSPEC_CMPEQB
    UNSPEC_ADD_ROUND_TO_ODD
    UNSPEC_SUB_ROUND_TO_ODD
    UNSPEC_MUL_ROUND_TO_ODD
@@ -164,6 +167,9 @@
    UNSPECV_EH_RR		; eh_reg_restore
    UNSPECV_ISYNC		; isync instruction
    UNSPECV_MFTB			; move from time base
+   UNSPECV_DARN			; darn 1 (deliver a random number)
+   UNSPECV_DARN_32		; darn 2
+   UNSPECV_DARN_RAW		; darn 0
    UNSPECV_NLGR			; non-local goto receiver
    UNSPECV_MFFS			; Move from FPSCR
    UNSPECV_MFFSL		; Move from FPSCR light instruction version
@@ -6818,13 +6824,6 @@
 ;; do the load 16-bits at a time.  We could do this by loading from memory,
 ;; and this is even supposed to be faster, but it is simpler not to get
 ;; integers in the TOC.
-(define_insn "movsi_low"
-  [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
-        (mem:SI (lo_sum:SI (match_operand:SI 1 "gpc_reg_operand" "b")
-                           (match_operand 2 "" ""))))]
-  "TARGET_MACHO && ! TARGET_64BIT"
-  "lwz %0,lo16(%2)(%1)"
-  [(set_attr "type" "load")])
 
 ;;		MR           LA           LWZ          LFIWZX       LXSIWZX
 ;;		STW          STFIWX       STXSIWX      LI           LIS
@@ -14322,7 +14321,225 @@
    "xscmpuqp %0,%1,%2"
   [(set_attr "type" "veccmp")
    (set_attr "size" "128")])
+
+;; Miscellaneous ISA 3.0 (power9) instructions
+
+(define_insn "darn_32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (unspec_volatile:SI [(const_int 0)] UNSPECV_DARN_32))]
+  "TARGET_P9_MISC"
+  "darn %0,0"
+  [(set_attr "type" "integer")])
 
+(define_insn "darn_raw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (unspec_volatile:DI [(const_int 0)] UNSPECV_DARN_RAW))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "darn %0,2"
+  [(set_attr "type" "integer")])
+
+(define_insn "darn"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (unspec_volatile:DI [(const_int 0)] UNSPECV_DARN))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "darn %0,1"
+  [(set_attr "type" "integer")])
+
+;; Test byte within range.
+;;
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the range specified by operand 2.
+;; The bytes of operand 2 are organized as xx:xx:hi:lo.
+;;
+;; Return in target register operand 0 a value of 1 if lo <= vv and
+;; vv <= hi.  Otherwise, set register operand 0 to 0.
+;;
+;; Though the instructions to which this expansion maps operate on
+;; 64-bit registers, the current implementation only operates on
+;; SI-mode operands as the high-order bits provide no information
+;; that is not already available in the low-order bits.  To avoid the
+;; costs of data widening operations, future enhancements might allow
+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
+(define_expand "cmprb"
+  [(set (match_dup 3)
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB))
+   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	(if_then_else:SI (lt (match_dup 3)
+			     (const_int 0))
+			 (const_int -1)
+			 (if_then_else (gt (match_dup 3)
+					   (const_int 0))
+				       (const_int 1)
+				       (const_int 0))))]
+  "TARGET_P9_MISC"
+{
+  operands[3] = gen_reg_rtx (CCmode);
+})
+
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the range specified by operand 2.
+;; The bytes of operand 2 are organized as xx:xx:hi:lo.
+;;
+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
+;; lo <= vv and vv <= hi.  Otherwise, set the GT bit to 0.  The other
+;; 3 bits of the target CR register are all set to 0.
+(define_insn "*cmprb_internal"
+  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB))]
+  "TARGET_P9_MISC"
+  "cmprb %0,0,%1,%2"
+  [(set_attr "type" "logical")])
+
+;; Set operand 0 register to -1 if the LT bit (0x8) of condition
+;; register operand 1 is on.  Otherwise, set operand 0 register to 1
+;; if the GT bit (0x4) of condition register operand 1 is on.
+;; Otherwise, set operand 0 to 0.  Note that the result stored into
+;; register operand 0 is non-zero iff either the LT or GT bits are on
+;; within condition register operand 1.
+(define_insn "setb_signed"
+   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	 (if_then_else:SI (lt (match_operand:CC 1 "cc_reg_operand" "y")
+			      (const_int 0))
+			  (const_int -1)
+			  (if_then_else (gt (match_dup 1)
+					    (const_int 0))
+					(const_int 1)
+					(const_int 0))))]
+  "TARGET_P9_MISC"
+  "setb %0,%1"
+  [(set_attr "type" "logical")])
+
+(define_insn "setb_unsigned"
+   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	 (if_then_else:SI (ltu (match_operand:CCUNS 1 "cc_reg_operand" "y")
+			      (const_int 0))
+			  (const_int -1)
+			  (if_then_else (gtu (match_dup 1)
+					    (const_int 0))
+					(const_int 1)
+					(const_int 0))))]
+  "TARGET_P9_MISC"
+  "setb %0,%1"
+  [(set_attr "type" "logical")])
+
+;; Test byte within two ranges.
+;;
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the range specified by operand 2.
+;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
+;;
+;; Return in target register operand 0 a value of 1 if (lo_1 <= vv and
+;; vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).  Otherwise, set register
+;; operand 0 to 0.
+;;
+;; Though the instructions to which this expansion maps operate on
+;; 64-bit registers, the current implementation only operates on
+;; SI-mode operands as the high-order bits provide no information
+;; that is not already available in the low-order bits.  To avoid the
+;; costs of data widening operations, future enhancements might allow
+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
+(define_expand "cmprb2"
+  [(set (match_dup 3)
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB2))
+   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	(if_then_else:SI (lt (match_dup 3)
+			     (const_int 0))
+			 (const_int -1)
+			 (if_then_else (gt (match_dup 3)
+					   (const_int 0))
+				       (const_int 1)
+				       (const_int 0))))]
+  "TARGET_P9_MISC"
+{
+  operands[3] = gen_reg_rtx (CCmode);
+})
+
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the ranges specified by operand 2.
+;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
+;;
+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
+;; (lo_1 <= vv and vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).
+;; Otherwise, set the GT bit to 0.  The other 3 bits of the target
+;; CR register are all set to 0.
+(define_insn "*cmprb2_internal"
+  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB2))]
+  "TARGET_P9_MISC"
+  "cmprb %0,1,%1,%2"
+  [(set_attr "type" "logical")])
+
+;; Test byte membership within set of 8 bytes.
+;;
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the set specified by operand 2.
+;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
+;;
+;; Return in target register operand 0 a value of 1 if vv equals one
+;; of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise, set
+;; register operand 0 to 0.  Note that the 8 byte values held within
+;; operand 2 need not be unique.
+;;
+;; Though the instructions to which this expansion maps operate on
+;; 64-bit registers, the current implementation requires that operands
+;; 0 and 1 have mode SI as the high-order bits provide no information
+;; that is not already available in the low-order bits.  To avoid the
+;; costs of data widening operations, future enhancements might allow
+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
+(define_expand "cmpeqb"
+  [(set (match_dup 3)
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:DI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPEQB))
+   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	(if_then_else:SI (lt (match_dup 3)
+			     (const_int 0))
+			 (const_int -1)
+			 (if_then_else (gt (match_dup 3)
+					   (const_int 0))
+				       (const_int 1)
+				       (const_int 0))))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+{
+  operands[3] = gen_reg_rtx (CCmode);
+})
+
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the set specified by operand 2.
+;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
+;;
+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if vv
+;; equals one of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise,
+;; set the GT bit to zero.  The other 3 bits of the target CR register
+;; are all set to 0.
+(define_insn "*cmpeqb_internal"
+  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	 (unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		     (match_operand:DI 2 "gpc_reg_operand" "r")]
+	  UNSPEC_CMPEQB))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "cmpeqb %0,%1,%2"
+  [(set_attr "type" "logical")])
 
 
 (include "sync.md")
diff --git a/gcc/config/s390/8561.md b/gcc/config/s390/8561.md
index e5a345f4dba..2442349271b 100644
--- a/gcc/config/s390/8561.md
+++ b/gcc/config/s390/8561.md
@@ -1,4 +1,4 @@
-;; Scheduling description for arch13.
+;; Scheduling description for z15.
 ;;   Copyright (C) 2019 Free Software Foundation, Inc.
 ;;   Contributed by Robin Dapp (rdapp@linux.ibm.com)
 ;; This file is part of GCC.
@@ -17,12 +17,12 @@
 ;; along with GCC; see the file COPYING3.  If not see
 ;; <http://www.gnu.org/licenses/>.
 
-(define_attr "arch13_unit_fpd" ""
+(define_attr "z15_unit_fpd" ""
 (cond [(eq_attr "mnemonic" "ddb,ddbr,deb,debr,dxbr,sqdb,sqdbr,sqeb,\
 sqebr,sqxbr,vfddb,vfdsb,vfsqdb,vfsqsb,wfddb,wfdsb,wfdxb,wfsqdb,wfsqxb")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_unit_fxa" ""
+(define_attr "z15_unit_fxa" ""
 (cond [(eq_attr "mnemonic" "a,afi,ag,agf,agfi,agfr,agh,aghi,aghik,\
 agr,agrk,ah,ahi,ahik,ahy,al,alc,alcg,alcgr,alcr,alfi,alg,algf,algfi,algfr,\
 alghsik,algr,algrk,alhsik,alr,alrk,aly,ar,ark,ay,bras,brasl,etnd,exrl,flogr,\
@@ -39,7 +39,7 @@ slgrk,sll,sllg,sllk,slr,slrk,sly,sr,sra,srag,srak,srk,srl,srlg,srlk,sy,x,xg,\
 xgr,xgrk,xihf,xilf,xr,xrk,xy")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_unit_fxb" ""
+(define_attr "z15_unit_fxb" ""
 (cond [(eq_attr "mnemonic" "agsi,algsi,alsi,asi,b,bc,bcr,bi,br,brcl,\
 c,cfi,cg,cgf,cgfi,cgfr,cgfrl,cgh,cghi,cghrl,cghsi,cgit,cgr,cgrl,cgrt,ch,\
 chi,chrl,chsi,chy,cit,cl,clfhsi,clfi,clfit,clg,clgf,clgfi,clgfr,clgfrl,\
@@ -52,11 +52,11 @@ tmhl,tml,tmlh,tmll,tmy,vlgvb,vlgvf,vlgvg,vlgvh,vlr,vlvgb,vlvgf,vlvgg,vlvgh,\
 vlvgp,vst,vstef,vsteg,vstl,vstrl,vstrlr,xi,xiy")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_unit_fxd" ""
+(define_attr "z15_unit_fxd" ""
 (cond [(eq_attr "mnemonic" "dlgr,dlr,dr,dsgfr,dsgr")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_unit_lsu" ""
+(define_attr "z15_unit_lsu" ""
 (cond [(eq_attr "mnemonic" "a,adb,aeb,ag,agf,agh,agsi,ah,ahy,al,alc,\
 alcg,alg,algf,algsi,alsi,aly,asi,ay,c,cdb,ceb,cg,cgf,cgfrl,cgh,cghrl,cghsi,\
 cgrl,ch,chrl,chsi,chy,cl,clc,clfhsi,clg,clgf,clgfrl,clghrl,clghsi,clgrl,\
@@ -73,7 +73,7 @@ vllezf,vllezg,vllezh,vllezlf,vlrepb,vlrepf,vlrepg,vlreph,vlrl,vlrlr,vst,\
 vstef,vsteg,vstl,vstrl,vstrlr,x,xg,xi,xiy,xy")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_unit_vfu" ""
+(define_attr "z15_unit_vfu" ""
 (cond [(eq_attr "mnemonic" "adb,adbr,adtr,aeb,aebr,axbr,axtr,cdb,\
 cdbr,cdtr,ceb,cebr,cpsdr,cxbr,cxtr,ddtr,dxtr,fidbr,fidbra,fidtr,fiebr,\
 fiebra,fixbr,fixbra,fixtr,lcdbr,lcebr,lcxbr,ldeb,ldebr,ldetr,le,ledbr,ledtr,\
@@ -115,7 +115,7 @@ wflpxb,wfmadb,wfmasb,wfmaxb,wfmaxxb,wfmdb,wfminxb,wfmsb,wfmsdb,wfmssb,wfmsxb,\
 wfmxb,wfnmaxb,wfnmsxb,wfsdb,wfssb,wfsxb,wldeb,wledb")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_cracked" ""
+(define_attr "z15_cracked" ""
 (cond [(eq_attr "mnemonic" "bas,basr,cdfbr,cdftr,cdgbr,cdgtr,cdlfbr,\
 cdlftr,cdlgbr,cdlgtr,cefbr,cegbr,celfbr,celgbr,cfdbr,cfebr,cfxbr,cgdbr,cgdtr,\
 cgebr,cgxbr,cgxtr,chhsi,clfdbr,clfdtr,clfebr,clfxbr,clfxtr,clgdbr,clgdtr,\
@@ -123,13 +123,13 @@ clgebr,clgxbr,clgxtr,cs,csg,csy,d,efpc,ex,lcgfr,lngfr,lpgfr,lpq,lxr,lzxr,\
 rxsbg,stpq,vgef,vgeg,vscef,vsceg,vsteb,vsteh")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_expanded" ""
+(define_attr "z15_expanded" ""
 (cond [(eq_attr "mnemonic" "cds,cdsg,cdsy,cxfbr,cxftr,cxgbr,cxgtr,\
 cxlfbr,cxlftr,cxlgbr,cxlgtr,dl,dlg,dsg,dsgf,lam,lm,lmg,lmy,sldl,srda,srdl,\
 stam,stm,stmg,stmy,tbegin,tbeginc")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_groupalone" ""
+(define_attr "z15_groupalone" ""
 (cond [(eq_attr "mnemonic" "alc,alcg,alcgr,alcr,axbr,axtr,clc,cxbr,\
 cxtr,dlgr,dlr,dr,dsgfr,dsgr,dxbr,dxtr,fixbr,fixbra,fixtr,flogr,lcxbr,lnxbr,\
 lpxbr,ltxbr,ltxtr,lxdb,lxdbr,lxdtr,lxeb,lxebr,m,madb,maeb,maebr,mfy,mg,mgrk,\
@@ -137,11 +137,11 @@ ml,mlg,mlgr,mlr,mr,msdb,mseb,msebr,mvc,mxbr,mxtr,nc,oc,ppa,sfpc,slb,slbg,\
 slbgr,slbr,sqxbr,sxbr,sxtr,tabort,tcxb,tdcxt,tend,xc")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_endgroup" ""
+(define_attr "z15_endgroup" ""
 (cond [(eq_attr "mnemonic" "bras,brasl,exrl,ipm")
  (const_int 1)] (const_int 0)))
 
-(define_attr "arch13_groupoftwo" ""
+(define_attr "z15_groupoftwo" ""
 (cond [(eq_attr "mnemonic" "vacccq,vacq,vfmadb,vfmasb,vfmsdb,vfmssb,\
 vfnmadb,vfnmasb,vfnmsdb,vfnmssb,vgfmab,vgfmaf,vgfmag,vgfmah,vmaeb,vmaef,vmaeh,\
 vmahb,vmahf,vmahh,vmalb,vmaleb,vmalef,vmaleh,vmalf,vmalhb,vmalhf,vmalhh,\
@@ -149,8 +149,8 @@ vmalhw,vmalob,vmalof,vmaloh,vmaob,vmaof,vmaoh,vmslg,vperm,vsbcbiq,vsbiq,vsel,\
 wfmadb,wfmasb,wfmaxb,wfmsdb,wfmssb,wfmsxb,wfnmaxb,wfnmsxb")
  (const_int 1)] (const_int 0)))
 
-(define_insn_reservation "arch13_0" 0
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_0" 0
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "a,afi,ag,agfi,aghi,aghik,agr,agrk,ahi,ahik,al,\
 alfi,alg,algf,algfi,algfr,alghsik,algr,algrk,alhsik,alr,alrk,aly,ar,ark,ay,\
 b,bc,bcr,bi,br,bras,brasl,brcl,c,cfi,cg,cgfi,cghi,cghsi,cgit,cgr,cgrl,\
@@ -168,8 +168,8 @@ sllk,slr,slrk,sly,sr,sra,srag,srak,srda,srdl,srk,srl,srlg,srlk,sy,tm,tmh,\
 tmhh,tmhl,tml,tmlh,tmll,tmy,vlr,vlvgb,vlvgf,vlvgg,vlvgh,x,xg,xgr,xgrk,xihf,\
 xilf,xr,xrk,xy")) "nothing")
 
-(define_insn_reservation "arch13_1" 1
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_1" 1
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "agf,agfr,agh,agsi,ah,ahy,algsi,alsi,asi,cgf,\
 cgfr,cgfrl,cgh,cghrl,ch,chrl,chy,clm,clmy,cpsdr,laa,laag,lan,lang,lao,laog,\
 lax,laxg,le,ler,ley,loc,locg,locghi,locgr,lochi,locr,mvghi,mvhhi,mvhi,mvi,\
@@ -196,8 +196,8 @@ wfcedb,wfcesb,wfcexb,wfchdb,wfchedb,wfchesb,wfchexb,wfchsb,wfchxb,wflcdb,\
 wflcsb,wflcxb,wflndb,wflnsb,wflnxb,wflpdb,wflpsb,wflpxb,wfmaxxb,wfminxb,xi,\
 xiy")) "nothing")
 
-(define_insn_reservation "arch13_2" 2
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_2" 2
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cdb,cdbr,ceb,cebr,ear,ipm,l,lcbb,lcdbr,lcebr,ld,\
 lde,ldy,lg,lgdr,lgrl,llc,llgc,llgf,llgfrl,llgh,llghrl,llgt,llh,llhrl,lm,\
 lmg,lmy,lndbr,lnebr,lpdbr,lpebr,lrl,ltdbr,ltebr,ly,popcnt,sar,tcdb,tceb,\
@@ -208,8 +208,8 @@ vistrh,vlgvb,vlgvf,vlgvg,vlgvh,vllezb,vllezf,vllezg,vllezh,vllezlf,vlrepb,\
 vlrepf,vlrepg,vlreph,vlrl,vlvgp,vpklsfs,vpklsgs,vpklshs,vpksfs,vpksgs,vpkshs,\
 wfcdb,wfcexbs,wfchexbs,wfchxbs,wfcsb")) "nothing")
 
-(define_insn_reservation "arch13_3" 3
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_3" 3
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cds,cdsy,mgh,mghi,mh,mhi,mhy,std,stdy,ste,stey,\
 vcksm,vfeezbs,vfeezfs,vfeezhs,vgfmab,vgfmaf,vgfmag,vgfmah,vgfmb,vgfmf,vgfmg,\
 vgfmh,vistrbs,vistrfs,vistrhs,vl,vlbb,vll,vlrlr,vmaeb,vmaef,vmaeh,vmahb,\
@@ -218,14 +218,14 @@ vmalob,vmalof,vmaloh,vmaob,vmaof,vmaoh,vmeb,vmef,vmeh,vmhb,vmhf,vmhh,vmlb,\
 vmleb,vmlef,vmleh,vmlf,vmlhb,vmlhf,vmlhh,vmlhw,vmlob,vmlof,vmloh,vmob,vmof,\
 vmoh,vsumb,vsumgf,vsumgh,vsumh,vsumqf,vsumqg,vtm")) "nothing")
 
-(define_insn_reservation "arch13_4" 4
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_4" 4
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "bas,basr,chhsi,clc,ex,lam,lcgfr,lngfr,lpgfr,lxr,\
 lzxr,ms,msfi,msgf,msgfi,msgfr,msr,msy,mvc,nc,oc,ppa,rxsbg,tabort,tbegin,\
 tbeginc,tend,vst,vstef,vsteg,vstl,vstrl,vstrlr,xc")) "nothing")
 
-(define_insn_reservation "arch13_5" 5
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_5" 5
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "adb,adbr,aeb,aebr,alc,alcg,alcgr,alcr,cs,csg,\
 csy,fidbr,fidbra,fiebr,fiebra,ldeb,ldebr,ledbr,madbr,mdb,mdbr,meeb,meebr,\
 msdbr,msrkc,sdb,sdbr,seb,sebr,slb,slbg,slbgr,slbr,stm,stmg,stmy,vfadb,vfasb,\
@@ -233,53 +233,53 @@ vfidb,vfisb,vfmadb,vfmasb,vfmdb,vfmsb,vfmsdb,vfmssb,vfnmadb,vfnmasb,vfnmsdb,\
 vfnmssb,vfsdb,vfssb,vldeb,vledb,vmslg,wfadb,wfasb,wfidb,wfisb,wflld,wfmadb,\
 wfmasb,wfmdb,wfmsb,wfmsdb,wfmssb,wfsdb,wfssb,wldeb,wledb")) "nothing")
 
-(define_insn_reservation "arch13_6" 6
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_6" 6
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "msg,msgr,sfpc")) "nothing")
 
-(define_insn_reservation "arch13_7" 7
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_7" 7
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "adtr,cdtr,fidtr,ldetr,ltdtr,msgrkc,sdtr,tdcdt,\
 tdcet,vgef,vgeg")) "nothing")
 
-(define_insn_reservation "arch13_8" 8
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_8" 8
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cdsg,flogr,lpq,stpq,vsteb,vsteh")) "nothing")
 
-(define_insn_reservation "arch13_9" 9
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_9" 9
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cdfbr,cdgbr,cdlfbr,cdlgbr,cefbr,cegbr,celfbr,\
 celgbr,cxfbr,cxgbr,cxlfbr,cxlgbr,m,madb,maeb,maebr,mfy,ml,mlr,mr,msdb,mseb,\
 msebr,stam,wfaxb,wfixb,wfsxb")) "nothing")
 
-(define_insn_reservation "arch13_10" 10
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_10" 10
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "lxdb,lxdbr,lxeb,lxebr,vscef,vsceg")) "nothing")
 
-(define_insn_reservation "arch13_11" 11
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_11" 11
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cfdbr,cfebr,cgdbr,cgebr,clfdbr,clfebr,clgdbr,\
 clgebr,mg,mgrk,mlg,mlgr")) "nothing")
 
-(define_insn_reservation "arch13_12" 12
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_12" 12
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cxbr,cxftr,cxlftr,cxtr,tcxb,tdcxt")) "nothing")
 
-(define_insn_reservation "arch13_13" 13
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_13" 13
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "axbr,axtr,fixbr,fixbra,fixtr,lcxbr,lnxbr,lpxbr,\
 ltxbr,ltxtr,lxdtr,sxbr,sxtr")) "nothing")
 
-(define_insn_reservation "arch13_14" 14
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_14" 14
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cfxbr,cgxbr,clfxbr,clgxbr,ledtr")) "nothing")
 
-(define_insn_reservation "arch13_16" 16
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_16" 16
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cdftr,cdlftr")) "nothing")
 
-(define_insn_reservation "arch13_20" 20
-  (and (eq_attr "cpu" "arch13")
+(define_insn_reservation "z15_20" 20
+  (and (eq_attr "cpu" "z15")
 (eq_attr "mnemonic" "cdgtr,cdlgtr,cgdtr,cgxtr,clfdtr,clfxtr,clgdtr,\
 clgxtr,cxgtr,cxlgtr,d,ddb,ddbr,ddtr,deb,debr,dl,dlg,dlgr,dlr,dr,dsg,dsgf,\
 dsgfr,dsgr,dxbr,dxtr,efpc,mdtr,mxbr,mxtr,sqdb,sqdbr,sqeb,sqebr,sqxbr,vfddb,\
diff --git a/gcc/config/s390/driver-native.c b/gcc/config/s390/driver-native.c
index a386d633a87..6bc7d590668 100644
--- a/gcc/config/s390/driver-native.c
+++ b/gcc/config/s390/driver-native.c
@@ -121,10 +121,10 @@ s390_host_detect_local_cpu (int argc, const char **argv)
 	      break;
 	    case 0x8561:
 	    case 0x8562:
-	      cpu = "arch13";
+	      cpu = "z15";
 	      break;
 	    default:
-	      cpu = "arch13";
+	      cpu = "z15";
 	      break;
 	    }
 	}
diff --git a/gcc/config/s390/s390-builtins.def b/gcc/config/s390/s390-builtins.def
index fbf7d9f50e8..3f39b9d3b88 100644
--- a/gcc/config/s390/s390-builtins.def
+++ b/gcc/config/s390/s390-builtins.def
@@ -281,7 +281,7 @@
 #define B_HTM   (1 << 1)  /* Builtins requiring the transactional execution facility.  */
 #define B_VX    (1 << 2)  /* Builtins requiring the z13 vector extensions.  */
 #define B_VXE   (1 << 3)  /* Builtins requiring the z14 vector extensions.  */
-#define B_VXE2  (1 << 4)  /* Builtins requiring the arch13 vector extensions.  */
+#define B_VXE2  (1 << 4)  /* Builtins requiring the z15 vector extensions.  */
 #define B_DEP   (1 << 5)  /* Builtin has been deprecated and a warning should be issued.  */
 
 /* B_DEF defines a standard (not overloaded) builtin
diff --git a/gcc/config/s390/s390-c.c b/gcc/config/s390/s390-c.c
index 97debdc3905..c2f9b507011 100644
--- a/gcc/config/s390/s390-c.c
+++ b/gcc/config/s390/s390-c.c
@@ -905,6 +905,12 @@ s390_resolve_overloaded_builtin (location_t loc,
       return error_mark_node;
     }
 
+  if (!TARGET_VXE2 && (ob_flags & B_VXE2))
+    {
+      error_at (loc, "%qF requires z15 or higher", ob_fndecl);
+      return error_mark_node;
+    }
+
   ob_fcode -= S390_BUILTIN_MAX;
 
   for (b_arg_chain = TYPE_ARG_TYPES (TREE_TYPE (ob_fndecl));
@@ -983,6 +989,15 @@ s390_resolve_overloaded_builtin (location_t loc,
       return error_mark_node;
     }
 
+
+  if (!TARGET_VXE2
+      && bflags_overloaded_builtin_var[last_match_index] & B_VXE2)
+    {
+      error_at (loc, "%qs matching variant requires z15 or higher",
+		IDENTIFIER_POINTER (DECL_NAME (ob_fndecl)));
+      return error_mark_node;
+    }
+
   if (bflags_overloaded_builtin_var[last_match_index] & B_DEP)
     warning_at (loc, 0, "%qs matching variant is deprecated.",
 		IDENTIFIER_POINTER (DECL_NAME (ob_fndecl)));
diff --git a/gcc/config/s390/s390-opts.h b/gcc/config/s390/s390-opts.h
index ab41cb883f3..502edea719b 100644
--- a/gcc/config/s390/s390-opts.h
+++ b/gcc/config/s390/s390-opts.h
@@ -37,7 +37,7 @@ enum processor_type
   PROCESSOR_2827_ZEC12,
   PROCESSOR_2964_Z13,
   PROCESSOR_3906_Z14,
-  PROCESSOR_8561_ARCH13,
+  PROCESSOR_8561_Z15,
   PROCESSOR_NATIVE,
   PROCESSOR_max
 };
diff --git a/gcc/config/s390/s390.c b/gcc/config/s390/s390.c
index fc4571d0d0c..db3f94978ec 100644
--- a/gcc/config/s390/s390.c
+++ b/gcc/config/s390/s390.c
@@ -337,7 +337,7 @@ const struct s390_processor processor_table[] =
   { "zEC12",  "zEC12",  PROCESSOR_2827_ZEC12,  &zEC12_cost,  10 },
   { "z13",    "z13",    PROCESSOR_2964_Z13,    &zEC12_cost,  11 },
   { "z14",    "arch12", PROCESSOR_3906_Z14,    &zEC12_cost,  12 },
-  { "arch13", "",       PROCESSOR_8561_ARCH13, &zEC12_cost,  13 },
+  { "z15",    "arch13", PROCESSOR_8561_Z15,    &zEC12_cost,  13 },
   { "native", "",       PROCESSOR_NATIVE,      NULL,         0  }
 };
 
@@ -811,6 +811,12 @@ s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,
 	  error ("Builtin %qF requires z14 or higher.", fndecl);
 	  return const0_rtx;
 	}
+
+      if ((bflags & B_VXE2) && !TARGET_VXE2)
+	{
+	  error ("Builtin %qF requires z15 or higher.", fndecl);
+	  return const0_rtx;
+	}
     }
   if (fcode >= S390_OVERLOADED_BUILTIN_VAR_OFFSET
       && fcode < S390_ALL_BUILTIN_MAX)
@@ -1782,7 +1788,7 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,
       if (*code == EQ)
 	new_code = reversed_comparison_code_parts (GET_CODE (*op0),
 						   XEXP (*op0, 0),
-						   XEXP (*op1, 0), NULL);
+						   XEXP (*op0, 1), NULL);
       else
 	new_code = GET_CODE (*op0);
 
@@ -1795,7 +1801,7 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,
     }
 
   /* ~a==b -> ~(a^b)==0   ~a!=b -> ~(a^b)!=0 */
-  if (TARGET_ARCH13
+  if (TARGET_Z15
       && (*code == EQ || *code == NE)
       && (GET_MODE (*op0) == DImode || GET_MODE (*op0) == SImode)
       && GET_CODE (*op0) == NOT)
@@ -1807,7 +1813,7 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,
     }
 
   /* a&b == -1 -> ~a|~b == 0    a|b == -1 -> ~a&~b == 0  */
-  if (TARGET_ARCH13
+  if (TARGET_Z15
       && (*code == EQ || *code == NE)
       && (GET_CODE (*op0) == AND || GET_CODE (*op0) == IOR)
       && (GET_MODE (*op0) == DImode || GET_MODE (*op0) == SImode)
@@ -3529,7 +3535,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,
 
 	/* It is a real IF-THEN-ELSE.  An additional move will be
 	   needed to implement that.  */
-	if (!TARGET_ARCH13
+	if (!TARGET_Z15
 	    && reload_completed
 	    && !rtx_equal_p (dst, then)
 	    && !rtx_equal_p (dst, els))
@@ -3551,7 +3557,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,
     case IOR:
 
       /* nnrk, nngrk */
-      if (TARGET_ARCH13
+      if (TARGET_Z15
 	  && (mode == SImode || mode == DImode)
 	  && GET_CODE (XEXP (x, 0)) == NOT
 	  && GET_CODE (XEXP (x, 1)) == NOT)
@@ -3598,7 +3604,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,
 
     case AND:
       /* nork, nogrk */
-      if (TARGET_ARCH13
+      if (TARGET_Z15
 	  && (mode == SImode || mode == DImode)
 	  && GET_CODE (XEXP (x, 0)) == NOT
 	  && GET_CODE (XEXP (x, 1)) == NOT)
@@ -3770,7 +3776,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,
       *total = COSTS_N_INSNS (1);
 
       /* nxrk, nxgrk ~(a^b)==0 */
-      if (TARGET_ARCH13
+      if (TARGET_Z15
 	  && GET_CODE (XEXP (x, 0)) == NOT
 	  && XEXP (x, 1) == const0_rtx
 	  && GET_CODE (XEXP (XEXP (x, 0), 0)) == XOR
@@ -3785,7 +3791,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,
 	}
 
       /* nnrk, nngrk, nork, nogrk */
-      if (TARGET_ARCH13
+      if (TARGET_Z15
 	  && (GET_CODE (XEXP (x, 0)) == AND || GET_CODE (XEXP (x, 0)) == IOR)
 	  && XEXP (x, 1) == const0_rtx
 	  && (GET_MODE (XEXP (x, 0)) == SImode || GET_MODE (XEXP (x, 0)) == DImode)
@@ -14440,16 +14446,16 @@ s390_get_sched_attrmask (rtx_insn *insn)
       if (get_attr_z14_groupoftwo (insn))
 	mask |= S390_SCHED_ATTR_MASK_GROUPOFTWO;
       break;
-    case PROCESSOR_8561_ARCH13:
-      if (get_attr_arch13_cracked (insn))
+    case PROCESSOR_8561_Z15:
+      if (get_attr_z15_cracked (insn))
 	mask |= S390_SCHED_ATTR_MASK_CRACKED;
-      if (get_attr_arch13_expanded (insn))
+      if (get_attr_z15_expanded (insn))
 	mask |= S390_SCHED_ATTR_MASK_EXPANDED;
-      if (get_attr_arch13_endgroup (insn))
+      if (get_attr_z15_endgroup (insn))
 	mask |= S390_SCHED_ATTR_MASK_ENDGROUP;
-      if (get_attr_arch13_groupalone (insn))
+      if (get_attr_z15_groupalone (insn))
 	mask |= S390_SCHED_ATTR_MASK_GROUPALONE;
-      if (get_attr_arch13_groupoftwo (insn))
+      if (get_attr_z15_groupoftwo (insn))
 	mask |= S390_SCHED_ATTR_MASK_GROUPOFTWO;
       break;
     default:
@@ -14487,15 +14493,15 @@ s390_get_unit_mask (rtx_insn *insn, int *units)
       if (get_attr_z14_unit_vfu (insn))
 	mask |= 1 << 3;
       break;
-    case PROCESSOR_8561_ARCH13:
+    case PROCESSOR_8561_Z15:
       *units = 4;
-      if (get_attr_arch13_unit_lsu (insn))
+      if (get_attr_z15_unit_lsu (insn))
 	mask |= 1 << 0;
-      if (get_attr_arch13_unit_fxa (insn))
+      if (get_attr_z15_unit_fxa (insn))
 	mask |= 1 << 1;
-      if (get_attr_arch13_unit_fxb (insn))
+      if (get_attr_z15_unit_fxb (insn))
 	mask |= 1 << 2;
-      if (get_attr_arch13_unit_vfu (insn))
+      if (get_attr_z15_unit_vfu (insn))
 	mask |= 1 << 3;
       break;
     default:
@@ -14511,7 +14517,7 @@ s390_is_fpd (rtx_insn *insn)
     return false;
 
   return get_attr_z13_unit_fpd (insn) || get_attr_z14_unit_fpd (insn)
-    || get_attr_arch13_unit_fpd (insn);
+    || get_attr_z15_unit_fpd (insn);
 }
 
 static bool
@@ -14521,7 +14527,7 @@ s390_is_fxd (rtx_insn *insn)
     return false;
 
   return get_attr_z13_unit_fxd (insn) || get_attr_z14_unit_fxd (insn)
-    || get_attr_arch13_unit_fxd (insn);
+    || get_attr_z15_unit_fxd (insn);
 }
 
 /* Returns TRUE if INSN is a long-running instruction.  */
@@ -15968,13 +15974,19 @@ s390_support_vector_misalignment (machine_mode mode ATTRIBUTE_UNUSED,
 static HOST_WIDE_INT
 s390_vector_alignment (const_tree type)
 {
+  tree size = TYPE_SIZE (type);
+
   if (!TARGET_VX_ABI)
     return default_vector_alignment (type);
 
   if (TYPE_USER_ALIGN (type))
     return TYPE_ALIGN (type);
 
-  return MIN (64, tree_to_shwi (TYPE_SIZE (type)));
+  if (tree_fits_uhwi_p (size)
+      && tree_to_uhwi (size) < BIGGEST_ALIGNMENT)
+    return tree_to_uhwi (size);
+
+  return BIGGEST_ALIGNMENT;
 }
 
 /* Implement TARGET_CONSTANT_ALIGNMENT.  Alignment on even addresses for
diff --git a/gcc/config/s390/s390.h b/gcc/config/s390/s390.h
index 969f58a2ba0..f7023d985f1 100644
--- a/gcc/config/s390/s390.h
+++ b/gcc/config/s390/s390.h
@@ -41,12 +41,12 @@ enum processor_flags
   PF_Z14 = 2048,
   PF_VXE = 4096,
   PF_VXE2 = 8192,
-  PF_ARCH13 = 16384
+  PF_Z15 = 16384
 };
 
 /* This is necessary to avoid a warning about comparing different enum
    types.  */
-#define s390_tune_attr ((enum attr_cpu)(s390_tune > PROCESSOR_8561_ARCH13 ? PROCESSOR_8561_ARCH13 : s390_tune ))
+#define s390_tune_attr ((enum attr_cpu)(s390_tune > PROCESSOR_8561_Z15 ? PROCESSOR_8561_Z15 : s390_tune ))
 
 /* These flags indicate that the generated code should run on a cpu
    providing the respective hardware facility regardless of the
@@ -100,10 +100,10 @@ enum processor_flags
 	(s390_arch_flags & PF_VXE)
 #define TARGET_CPU_VXE_P(opts) \
 	(opts->x_s390_arch_flags & PF_VXE)
-#define TARGET_CPU_ARCH13 \
-	(s390_arch_flags & PF_ARCH13)
-#define TARGET_CPU_ARCH13_P(opts) \
-	(opts->x_s390_arch_flags & PF_ARCH13)
+#define TARGET_CPU_Z15 \
+	(s390_arch_flags & PF_Z15)
+#define TARGET_CPU_Z15_P(opts) \
+	(opts->x_s390_arch_flags & PF_Z15)
 #define TARGET_CPU_VXE2 \
 	(s390_arch_flags & PF_VXE2)
 #define TARGET_CPU_VXE2_P(opts) \
@@ -160,9 +160,9 @@ enum processor_flags
 	(TARGET_VX && TARGET_CPU_VXE)
 #define TARGET_VXE_P(opts)						\
 	(TARGET_VX_P (opts) && TARGET_CPU_VXE_P (opts))
-#define TARGET_ARCH13 (TARGET_ZARCH && TARGET_CPU_ARCH13)
-#define TARGET_ARCH13_P(opts)						\
-	(TARGET_ZARCH_P (opts->x_target_flags) && TARGET_CPU_ARCH13_P (opts))
+#define TARGET_Z15 (TARGET_ZARCH && TARGET_CPU_Z15)
+#define TARGET_Z15_P(opts)						\
+	(TARGET_ZARCH_P (opts->x_target_flags) && TARGET_CPU_Z15_P (opts))
 #define TARGET_VXE2					\
 	(TARGET_VX && TARGET_CPU_VXE2)
 #define TARGET_VXE2_P(opts)						\
diff --git a/gcc/config/s390/s390.md b/gcc/config/s390/s390.md
index 714d8b00a80..5a3496ac92e 100644
--- a/gcc/config/s390/s390.md
+++ b/gcc/config/s390/s390.md
@@ -513,11 +513,11 @@
 ;; Processor type.  This attribute must exactly match the processor_type
 ;; enumeration in s390.h.
 
-(define_attr "cpu" "z900,z990,z9_109,z9_ec,z10,z196,zEC12,z13,z14,arch13"
+(define_attr "cpu" "z900,z990,z9_109,z9_ec,z10,z196,zEC12,z13,z14,z15"
   (const (symbol_ref "s390_tune_attr")))
 
 (define_attr "cpu_facility"
-  "standard,ieee,zarch,cpu_zarch,longdisp,extimm,dfp,z10,z196,zEC12,vx,z13,z14,vxe,arch13,vxe2"
+  "standard,ieee,zarch,cpu_zarch,longdisp,extimm,dfp,z10,z196,zEC12,vx,z13,z14,vxe,z15,vxe2"
   (const_string "standard"))
 
 (define_attr "enabled" ""
@@ -575,8 +575,8 @@
 	      (match_test "TARGET_VXE"))
 	 (const_int 1)
 
-	 (and (eq_attr "cpu_facility" "arch13")
-	      (match_test "TARGET_ARCH13"))
+	 (and (eq_attr "cpu_facility" "z15")
+	      (match_test "TARGET_Z15"))
 	 (const_int 1)
 
          (and (eq_attr "cpu_facility" "vxe2")
@@ -613,7 +613,7 @@
 ;; Pipeline description for z14
 (include "3906.md")
 
-;; Pipeline description for arch13
+;; Pipeline description for z15
 (include "8561.md")
 
 ;; Predicates
@@ -642,7 +642,7 @@
 (define_mode_iterator DD_DF [DF DD])
 (define_mode_iterator TD_TF [TF TD])
 
-; 32 bit int<->fp conversion instructions are available since VXE2 (arch13).
+; 32 bit int<->fp conversion instructions are available since VXE2 (z15).
 (define_mode_iterator VX_CONV_BFP [DF (SF "TARGET_VXE2")])
 (define_mode_iterator VX_CONV_INT [DI (SI "TARGET_VXE2")])
 
@@ -6749,7 +6749,7 @@
    stoc<g>%C1\t%3,%0
    stoc<g>%D1\t%4,%0"
   [(set_attr "op_type" "RRF,RRF,RRF,RSY,RSY,RIE,RIE,RSY,RSY")
-   (set_attr "cpu_facility" "*,*,arch13,*,*,z13,z13,*,*")])
+   (set_attr "cpu_facility" "*,*,z15,*,*,z13,z13,*,*")])
 
 ;;
 ;;- Multiply instructions.
@@ -7568,7 +7568,7 @@
 	(and:GPR (not:GPR (match_operand:GPR 1 "nonimmediate_operand" ""))
 		 (match_operand:GPR 2 "general_operand" "")))
    (clobber (reg:CC CC_REGNUM))]
-  "!TARGET_ARCH13
+  "!TARGET_Z15
    && ! reload_completed
    && (GET_CODE (operands[0]) != MEM
       /* Ensure that s390_logical_operator_ok_p will succeed even
@@ -7925,7 +7925,7 @@
    (set (match_operand:GPR 0 "register_operand" "=d")
 	(ANDOR:GPR (not:GPR (match_dup 1))
 		   (match_dup 2)))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "<ANDOR:noxa>c<GPR:g>rk\t%0,%2,%1"
   [(set_attr "op_type" "RRF")])
 
@@ -7937,7 +7937,7 @@
 		    (match_operand:GPR 2 "register_operand" "d"))
 	 (const_int 0)))
    (clobber (match_scratch:GPR 0 "=d"))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "<ANDOR:noxa>c<GPR:g>rk\t%0,%2,%1"
   [(set_attr "op_type" "RRF")])
 
@@ -7947,7 +7947,7 @@
 	(ANDOR:GPR (not:GPR (match_operand:GPR 1 "register_operand" "d"))
 		   (match_operand:GPR 2 "register_operand" "d")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARCH13"
+  "TARGET_Z15"
   "<ANDOR:noxa>c<GPR:g>rk\t%0,%2,%1"
   [(set_attr "op_type" "RRF")])
 
@@ -7965,7 +7965,7 @@
    (set (match_operand:GPR 0 "register_operand" "=d")
 	(ANDOR:GPR (not:GPR (match_dup 1))
 		   (not:GPR (match_dup 2))))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "n<ANDOR:inv_no><GPR:g>rk\t%0,%1,%2"
   [(set_attr "op_type" "RRF")])
 
@@ -7977,7 +7977,7 @@
 		    (not:GPR (match_operand:GPR 2 "register_operand" "d")))
 	 (const_int 0)))
    (clobber (match_scratch:GPR 0 "=d"))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "n<ANDOR:inv_no><GPR:g>rk\t%0,%1,%2"
   [(set_attr "op_type" "RRF")])
 
@@ -7987,7 +7987,7 @@
 	(ANDOR:GPR (not:GPR (match_operand:GPR 1 "register_operand" "d"))
 		   (not:GPR (match_operand:GPR 2 "register_operand" "d"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARCH13"
+  "TARGET_Z15"
   "n<ANDOR:inv_no><GPR:g>rk\t%0,%1,%2"
   [(set_attr "op_type" "RRF")])
 
@@ -8371,7 +8371,7 @@
    (set (match_operand:GPR 0 "register_operand" "=d")
 	(xor:GPR (not:GPR (match_dup 1))
 		    (match_dup 2)))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "nx<GPR:g>rk\t%0,%1,%2"
   [(set_attr "op_type" "RRF")])
 
@@ -8383,7 +8383,7 @@
 			   (match_operand:GPR 2 "register_operand" "d")))
 	 (const_int 0)))
    (clobber (match_scratch:GPR 0 "=d"))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "nx<GPR:g>rk\t%0,%1,%2"
   [(set_attr "op_type" "RRF")])
 
@@ -8393,7 +8393,7 @@
 	(not:GPR (xor:GPR (match_operand:GPR 1 "register_operand" "d")
 			  (match_operand:GPR 2 "register_operand" "d"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARCH13"
+  "TARGET_Z15"
   "nx<GPR:g>rk\t%0,%1,%2"
   [(set_attr "op_type" "RRF")])
 
@@ -11351,34 +11351,34 @@
 ; Population count instruction
 ;
 
-(define_insn "*popcountdi_arch13_cc"
+(define_insn "*popcountdi_z15_cc"
   [(set (reg CC_REGNUM)
 	(compare (popcount:DI (match_operand:DI 1 "register_operand" "d"))
 		 (const_int 0)))
    (set (match_operand:DI 0 "register_operand" "=d")
 	(match_dup 1))]
-  "TARGET_ARCH13 && s390_match_ccmode (insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode (insn, CCTmode)"
   "popcnt\t%0,%1,8"
   [(set_attr "op_type" "RRF")])
 
-(define_insn "*popcountdi_arch13_cconly"
+(define_insn "*popcountdi_z15_cconly"
   [(set (reg CC_REGNUM)
 	(compare (popcount:DI (match_operand:DI 1 "register_operand" "d"))
 		 (const_int 0)))
    (clobber (match_scratch:DI 0 "=d"))]
-  "TARGET_ARCH13 && s390_match_ccmode(insn, CCTmode)"
+  "TARGET_Z15 && s390_match_ccmode(insn, CCTmode)"
   "popcnt\t%0,%1,8"
   [(set_attr "op_type" "RRF")])
 
-(define_insn "*popcountdi_arch13"
+(define_insn "*popcountdi_z15"
   [(set (match_operand:DI 0 "register_operand" "=d")
 	(popcount:DI (match_operand:DI 1 "register_operand" "d")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARCH13"
+  "TARGET_Z15"
   "popcnt\t%0,%1,8"
   [(set_attr "op_type" "RRF")])
 
-; The pre-arch13 popcount instruction counts the bits of op1 in 8 byte
+; The pre-z15 popcount instruction counts the bits of op1 in 8 byte
 ; portions and stores the result in the corresponding bytes in op0.
 (define_insn "*popcount<mode>_z196"
   [(set (match_operand:INT 0 "register_operand" "=d")
@@ -11422,7 +11422,7 @@
      (clobber (reg:CC CC_REGNUM))])]
   "TARGET_Z196"
 {
-  if (!TARGET_ARCH13)
+  if (!TARGET_Z15)
     {
       emit_insn (gen_popcountdi2_z196 (operands[0], operands[1]));
       DONE;
@@ -11453,7 +11453,7 @@
 
 ; popcount always counts on the full 64 bit. With the z196 version
 ; counting bits per byte we just ignore the upper 4 bytes.  With the
-; arch13 version we have to zero out the upper 32 bits first.
+; z15 version we have to zero out the upper 32 bits first.
 (define_expand "popcountsi2"
   [(set (match_dup 2)
 	(zero_extend:DI (match_operand:SI 1 "register_operand")))
@@ -11463,7 +11463,7 @@
 	(subreg:SI (match_dup 3) 4))]
   "TARGET_Z196"
 {
-  if (!TARGET_ARCH13)
+  if (!TARGET_Z15)
     {
       emit_insn (gen_popcountsi2_z196 (operands[0], operands[1]));
       DONE;
@@ -11501,7 +11501,7 @@
 	(subreg:HI (match_dup 3) 6))]
   "TARGET_Z196"
 {
-  if (!TARGET_ARCH13)
+  if (!TARGET_Z15)
     {
       emit_insn (gen_popcounthi2_z196 (operands[0], operands[1]));
       DONE;
@@ -11516,7 +11516,7 @@
 ; For popcount on a single byte the old z196 style popcount
 ; instruction is ideal.  Since it anyway does a byte-wise popcount we
 ; just use it instead of zero extending the QImode input to DImode and
-; using the arch13 popcount variant.
+; using the z15 popcount variant.
 (define_expand "popcountqi2"
   [; popcnt op0, op1
    (parallel [(set (match_operand:QI 0 "register_operand" "")
diff --git a/gcc/config/s390/s390.opt b/gcc/config/s390/s390.opt
index 639f1679a56..6a6e1f75736 100644
--- a/gcc/config/s390/s390.opt
+++ b/gcc/config/s390/s390.opt
@@ -110,7 +110,10 @@ EnumValue
 Enum(processor_type) String(arch12) Value(PROCESSOR_3906_Z14)
 
 EnumValue
-Enum(processor_type) String(arch13) Value(PROCESSOR_8561_ARCH13)
+Enum(processor_type) String(z15) Value(PROCESSOR_8561_Z15)
+
+EnumValue
+Enum(processor_type) String(arch13) Value(PROCESSOR_8561_Z15)
 
 EnumValue
 Enum(processor_type) String(native) Value(PROCESSOR_NATIVE) DriverOnly
diff --git a/gcc/config/s390/vector.md b/gcc/config/s390/vector.md
index 140ef474a92..21cc76534b1 100644
--- a/gcc/config/s390/vector.md
+++ b/gcc/config/s390/vector.md
@@ -70,7 +70,7 @@
 
 (define_mode_iterator V_128_NOSINGLE [V16QI V8HI V4SI V4SF V2DI V2DF])
 
-; 32 bit int<->fp vector conversion instructions are available since VXE2 (arch13).
+; 32 bit int<->fp vector conversion instructions are available since VXE2 (z15).
 (define_mode_iterator VX_VEC_CONV_BFP [V2DF (V4SF "TARGET_VXE2")])
 (define_mode_iterator VX_VEC_CONV_INT [V2DI (V4SI "TARGET_VXE2")])
 
diff --git a/gcc/config/s390/vx-builtins.md b/gcc/config/s390/vx-builtins.md
index 3020bc94d3e..5ec3fb4fe58 100644
--- a/gcc/config/s390/vx-builtins.md
+++ b/gcc/config/s390/vx-builtins.md
@@ -2147,7 +2147,7 @@
   "<vw>fmax<sdx>b\t%v0,%v1,%v2,%b3"
   [(set_attr "op_type" "VRR")])
 
-; The element reversal builtins introduced with arch13 have been made
+; The element reversal builtins introduced with z15 have been made
 ; available also for older CPUs down to z13.
 (define_expand "eltswap<mode>"
   [(set (match_operand:VEC_HW                 0 "nonimmediate_operand" "")
@@ -2181,8 +2181,8 @@
    vster<bhfgq>\t%v1,%v0"
   [(set_attr "op_type" "*,VRX,VRX")])
 
-; arch13 has instructions for doing element reversal from mem to reg
-; or the other way around.  For reg to reg or on pre arch13 machines
+; z15 has instructions for doing element reversal from mem to reg
+; or the other way around.  For reg to reg or on pre z15 machines
 ; we have to emulate it with vector permute.
 (define_insn_and_split "*eltswap<mode>_emu"
   [(set (match_operand:VEC_HW                 0 "nonimmediate_operand" "=vR")
diff --git a/gcc/config/sh/sh.c b/gcc/config/sh/sh.c
index 8dc79a764df..11440988f1a 100644
--- a/gcc/config/sh/sh.c
+++ b/gcc/config/sh/sh.c
@@ -664,6 +664,9 @@ static const struct attribute_spec sh_attribute_table[] =
 #undef TARGET_CONSTANT_ALIGNMENT
 #define TARGET_CONSTANT_ALIGNMENT constant_alignment_word_strings
 
+#undef  TARGET_HAVE_SPECULATION_SAFE_VALUE
+#define TARGET_HAVE_SPECULATION_SAFE_VALUE speculation_safe_value_not_needed
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 
@@ -737,7 +740,7 @@ got_mode_name:;
     {
       if (tokens[i] == "strict")
 	ret.strict = true;
-      else if (tokens[i].find ("gbr-offset=") == 0)
+      else if (!tokens[i].compare (0, strlen ("gbr-offset="), "gbr-offset="))
 	{
 	  std::string offset_str = tokens[i].substr (strlen ("gbr-offset="));
 	  ret.tcb_gbr_offset = integral_argument (offset_str.c_str ());
@@ -958,11 +961,13 @@ sh_option_override (void)
   if (flag_unsafe_math_optimizations)
     {
       /* Enable fsca insn for SH4A if not otherwise specified by the user.  */
-      if (global_options_set.x_TARGET_FSCA == 0 && TARGET_SH4A_FP)
+      if (global_options_set.x_TARGET_FSCA == 0
+	  && (TARGET_SH4A_FP || TARGET_FPU_SH4_300))
 	TARGET_FSCA = 1;
 
       /* Enable fsrra insn for SH4A if not otherwise specified by the user.  */
-      if (global_options_set.x_TARGET_FSRRA == 0 && TARGET_SH4A_FP)
+      if (global_options_set.x_TARGET_FSRRA == 0
+	  && (TARGET_SH4A_FP || TARGET_FPU_SH4_300))
 	TARGET_FSRRA = 1;
     }
 
@@ -12087,9 +12092,11 @@ sh_extending_set_of_reg::use_as_extended_reg (rtx_insn* use_at_insn) const
 	rtx r = gen_reg_rtx (SImode);
 	rtx_insn* i0;
 	if (from_mode == QImode)
-	  i0 = emit_insn_after (gen_extendqisi2 (r, set_src), insn);
+	  i0 = sh_check_add_incdec_notes (
+			emit_insn_after (gen_extendqisi2 (r, set_src), insn));
 	else if (from_mode == HImode)
-	  i0 = emit_insn_after (gen_extendhisi2 (r, set_src), insn);
+	  i0 = sh_check_add_incdec_notes (
+			emit_insn_after (gen_extendhisi2 (r, set_src), insn));
 	else
 	  gcc_unreachable ();
 
@@ -12507,7 +12514,7 @@ static void
 sh_emit_mode_set (int entity ATTRIBUTE_UNUSED, int mode,
 		  int prev_mode, HARD_REG_SET regs_live ATTRIBUTE_UNUSED)
 {
-  if ((TARGET_SH4A_FP || TARGET_SH4_300)
+  if ((TARGET_SH4A_FP || TARGET_FPU_SH4_300)
       && prev_mode != FP_MODE_NONE && prev_mode != mode)
     {
       emit_insn (gen_toggle_pr ());
diff --git a/gcc/config/sh/sh.h b/gcc/config/sh/sh.h
index 0204872eae7..9372fcfa699 100644
--- a/gcc/config/sh/sh.h
+++ b/gcc/config/sh/sh.h
@@ -69,6 +69,8 @@ extern int code_for_indirect_jump_scratch;
    FPU is disabled (which makes it compatible with SH4al-dsp).  */
 #define TARGET_SH4A_FP (TARGET_SH4A && TARGET_FPU_ANY)
 
+/* True if the FPU is a SH4-300 variant.  */
+#define TARGET_FPU_SH4_300 (TARGET_FPU_ANY && TARGET_SH4_300)
 
 /* This is not used by the SH2E calling convention  */
 #define TARGET_VARARGS_PRETEND_ARGS(FUN_DECL) \
diff --git a/gcc/config/sh/sh.md b/gcc/config/sh/sh.md
index 83543778619..fdb80d5d9d6 100644
--- a/gcc/config/sh/sh.md
+++ b/gcc/config/sh/sh.md
@@ -9163,7 +9163,7 @@
 	(xor:SI (reg:SI FPSCR_REG) (const_int FPSCR_PR)))
    (set (reg:SI FPSCR_MODES_REG)
 	(unspec_volatile:SI [(const_int 0)] UNSPECV_FPSCR_MODES))]
-  "TARGET_SH4A_FP"
+  "TARGET_SH4A_FP || TARGET_FPU_SH4_300"
   "fpchg"
   [(set_attr "type" "fpscr_toggle")])
 
@@ -9391,15 +9391,31 @@
 (define_expand "negsf2"
   [(set (match_operand:SF 0 "fp_arith_reg_operand")
 	(neg:SF (match_operand:SF 1 "fp_arith_reg_operand")))]
-  "TARGET_SH2E")
+  "TARGET_FPU_ANY"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_negsf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_negsf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*negsf2_i"
+(define_insn "negsf2_no_fpscr"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
 	(neg:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_SH2E"
+  "TARGET_FPU_ANY && !TARGET_FPU_SH4_300"
   "fneg	%0"
   [(set_attr "type" "fmove")])
 
+(define_insn "negsf2_fpscr"
+  [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
+	(neg:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fneg	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "single")])
+
 (define_expand "sqrtsf2"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "")
 	(sqrt:SF (match_operand:SF 1 "fp_arith_reg_operand" "")))]
@@ -9489,15 +9505,31 @@
 (define_expand "abssf2"
   [(set (match_operand:SF 0 "fp_arith_reg_operand")
 	(abs:SF (match_operand:SF 1 "fp_arith_reg_operand")))]
-  "TARGET_SH2E")
+  "TARGET_FPU_ANY"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_abssf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_abssf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*abssf2_i"
+(define_insn "abssf2_no_fpscr"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
 	(abs:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_SH2E"
+  "TARGET_FPU_ANY && !TARGET_FPU_SH4_300"
   "fabs	%0"
   [(set_attr "type" "fmove")])
 
+(define_insn "abssf2_fpscr"
+  [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
+	(abs:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fabs	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "single")])
+
 (define_expand "adddf3"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "")
 	(plus:DF (match_operand:DF 1 "fp_arith_reg_operand" "")
@@ -9673,12 +9705,28 @@
 (define_expand "negdf2"
   [(set (match_operand:DF 0 "fp_arith_reg_operand")
 	(neg:DF (match_operand:DF 1 "fp_arith_reg_operand")))]
-  "TARGET_FPU_DOUBLE")
+  "TARGET_FPU_DOUBLE"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_negdf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_negdf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*negdf2_i"
+(define_insn "negdf2_fpscr"
+  [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
+	(neg:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fneg	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "double")])
+
+(define_insn "negdf2_no_fpscr"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
 	(neg:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_FPU_DOUBLE"
+  "TARGET_FPU_DOUBLE && !TARGET_FPU_SH4_300"
   "fneg	%0"
   [(set_attr "type" "fmove")])
 
@@ -9704,15 +9752,31 @@
 (define_expand "absdf2"
   [(set (match_operand:DF 0 "fp_arith_reg_operand")
 	(abs:DF (match_operand:DF 1 "fp_arith_reg_operand")))]
-  "TARGET_FPU_DOUBLE")
+  "TARGET_FPU_DOUBLE"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_absdf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_absdf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*absdf2_i"
+(define_insn "absdf2_no_fpscr"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
 	(abs:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_FPU_DOUBLE"
+  "TARGET_FPU_DOUBLE && !TARGET_FPU_SH4_300"
   "fabs	%0"
   [(set_attr "type" "fmove")])
 
+(define_insn "absdf2_fpscr"
+  [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
+	(abs:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fabs	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "double")])
+
 (define_expand "extendsfdf2"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "")
 	(float_extend:DF (match_operand:SF 1 "fpul_operand" "")))]
diff --git a/gcc/config/sparc/sparc-protos.h b/gcc/config/sparc/sparc-protos.h
index 9bdae7b9faa..ef1adb69ede 100644
--- a/gcc/config/sparc/sparc-protos.h
+++ b/gcc/config/sparc/sparc-protos.h
@@ -69,6 +69,7 @@ extern void sparc_split_reg_mem (rtx, rtx, machine_mode);
 extern void sparc_split_mem_reg (rtx, rtx, machine_mode);
 extern int sparc_split_reg_reg_legitimate (rtx, rtx);
 extern void sparc_split_reg_reg (rtx, rtx, machine_mode);
+extern const char *output_load_pcrel_sym (rtx *);
 extern const char *output_ubranch (rtx, rtx_insn *);
 extern const char *output_cbranch (rtx, rtx, int, int, int, rtx_insn *);
 extern const char *output_return (rtx_insn *);
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index 93479ab6bdc..ca783a68e2d 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -4243,9 +4243,11 @@ sparc_cannot_force_const_mem (machine_mode mode, rtx x)
 }
 
 /* Global Offset Table support.  */
-static GTY(()) rtx got_helper_rtx = NULL_RTX;
-static GTY(()) rtx got_register_rtx = NULL_RTX;
 static GTY(()) rtx got_symbol_rtx = NULL_RTX;
+static GTY(()) rtx got_register_rtx = NULL_RTX;
+static GTY(()) rtx got_helper_rtx = NULL_RTX;
+
+static GTY(()) bool got_helper_needed = false;
 
 /* Return the SYMBOL_REF for the Global Offset Table.  */
 
@@ -4258,27 +4260,6 @@ sparc_got (void)
   return got_symbol_rtx;
 }
 
-#ifdef HAVE_GAS_HIDDEN
-# define USE_HIDDEN_LINKONCE 1
-#else
-# define USE_HIDDEN_LINKONCE 0
-#endif
-
-static void
-get_pc_thunk_name (char name[32], unsigned int regno)
-{
-  const char *reg_name = reg_names[regno];
-
-  /* Skip the leading '%' as that cannot be used in a
-     symbol name.  */
-  reg_name += 1;
-
-  if (USE_HIDDEN_LINKONCE)
-    sprintf (name, "__sparc_get_pc_thunk.%s", reg_name);
-  else
-    ASM_GENERATE_INTERNAL_LABEL (name, "LADDPC", regno);
-}
-
 /* Wrapper around the load_pcrel_sym{si,di} patterns.  */
 
 static rtx
@@ -4298,30 +4279,78 @@ gen_load_pcrel_sym (rtx op0, rtx op1, rtx op2)
   return insn;
 }
 
+/* Output the load_pcrel_sym{si,di} patterns.  */
+
+const char *
+output_load_pcrel_sym (rtx *operands)
+{
+  if (flag_delayed_branch)
+    {
+      output_asm_insn ("sethi\t%%hi(%a1-4), %0", operands);
+      output_asm_insn ("call\t%a2", operands);
+      output_asm_insn (" add\t%0, %%lo(%a1+4), %0", operands);
+    }
+  else
+    {
+      output_asm_insn ("sethi\t%%hi(%a1-8), %0", operands);
+      output_asm_insn ("add\t%0, %%lo(%a1-4), %0", operands);
+      output_asm_insn ("call\t%a2", operands);
+      output_asm_insn (" nop", NULL);
+    }
+
+  if (operands[2] == got_helper_rtx)
+    got_helper_needed = true;
+
+  return "";
+}
+
+#ifdef HAVE_GAS_HIDDEN
+# define USE_HIDDEN_LINKONCE 1
+#else
+# define USE_HIDDEN_LINKONCE 0
+#endif
+
 /* Emit code to load the GOT register.  */
 
 void
 load_got_register (void)
 {
-  if (!got_register_rtx)
-    got_register_rtx = gen_rtx_REG (Pmode, GLOBAL_OFFSET_TABLE_REGNUM);
+  rtx insn;
 
   if (TARGET_VXWORKS_RTP)
-    emit_insn (gen_vxworks_load_got ());
+    {
+      if (!got_register_rtx)
+	got_register_rtx = pic_offset_table_rtx;
+
+      insn = gen_vxworks_load_got ();
+    }
   else
     {
+      if (!got_register_rtx)
+	got_register_rtx = gen_rtx_REG (Pmode, GLOBAL_OFFSET_TABLE_REGNUM);
+
       /* The GOT symbol is subject to a PC-relative relocation so we need a
 	 helper function to add the PC value and thus get the final value.  */
       if (!got_helper_rtx)
 	{
 	  char name[32];
-	  get_pc_thunk_name (name, GLOBAL_OFFSET_TABLE_REGNUM);
+
+	  /* Skip the leading '%' as that cannot be used in a symbol name.  */
+	  if (USE_HIDDEN_LINKONCE)
+	    sprintf (name, "__sparc_get_pc_thunk.%s",
+		     reg_names[REGNO (got_register_rtx)] + 1);
+	  else
+	    ASM_GENERATE_INTERNAL_LABEL (name, "LADDPC",
+					 REGNO (got_register_rtx));
+
 	  got_helper_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));
 	}
 
-      emit_insn (gen_load_pcrel_sym (got_register_rtx, sparc_got (),
-				     got_helper_rtx));
+      insn
+	= gen_load_pcrel_sym (got_register_rtx, sparc_got (), got_helper_rtx);
     }
+
+  emit_insn (insn);
 }
 
 /* Ensure that we are not using patterns that are not OK with PIC.  */
@@ -4457,7 +4486,7 @@ sparc_pic_register_p (rtx x)
     return true;
 
   if (!HARD_REGISTER_P (pic_offset_table_rtx)
-      && (HARD_REGISTER_P (x) || lra_in_progress)
+      && (HARD_REGISTER_P (x) || lra_in_progress || reload_in_progress)
       && ORIGINAL_REGNO (x) == REGNO (pic_offset_table_rtx))
     return true;
 
@@ -5486,7 +5515,7 @@ save_local_or_in_reg_p (unsigned int regno, int leaf_function)
     return true;
 
   /* GOT register (%l7) if needed.  */
-  if (regno == GLOBAL_OFFSET_TABLE_REGNUM && got_register_rtx)
+  if (got_register_rtx && regno == REGNO (got_register_rtx))
     return true;
 
   /* If the function accesses prior frames, the frame pointer and the return
@@ -12529,10 +12558,9 @@ static void
 sparc_file_end (void)
 {
   /* If we need to emit the special GOT helper function, do so now.  */
-  if (got_helper_rtx)
+  if (got_helper_needed)
     {
       const char *name = XSTR (got_helper_rtx, 0);
-      const char *reg_name = reg_names[GLOBAL_OFFSET_TABLE_REGNUM];
 #ifdef DWARF2_UNWIND_INFO
       bool do_cfi;
 #endif
@@ -12569,17 +12597,22 @@ sparc_file_end (void)
 #ifdef DWARF2_UNWIND_INFO
       do_cfi = dwarf2out_do_cfi_asm ();
       if (do_cfi)
-	fprintf (asm_out_file, "\t.cfi_startproc\n");
+	output_asm_insn (".cfi_startproc", NULL);
 #endif
       if (flag_delayed_branch)
-	fprintf (asm_out_file, "\tjmp\t%%o7+8\n\t add\t%%o7, %s, %s\n",
-		 reg_name, reg_name);
+	{
+	  output_asm_insn ("jmp\t%%o7+8", NULL);
+	  output_asm_insn (" add\t%%o7, %0, %0", &got_register_rtx);
+	}
       else
-	fprintf (asm_out_file, "\tadd\t%%o7, %s, %s\n\tjmp\t%%o7+8\n\t nop\n",
-		 reg_name, reg_name);
+	{
+	  output_asm_insn ("add\t%%o7, %0, %0", &got_register_rtx);
+	  output_asm_insn ("jmp\t%%o7+8", NULL);
+	  output_asm_insn (" nop", NULL);
+	}
 #ifdef DWARF2_UNWIND_INFO
       if (do_cfi)
-	fprintf (asm_out_file, "\t.cfi_endproc\n");
+	output_asm_insn (".cfi_endproc", NULL);
 #endif
     }
 
@@ -13085,7 +13118,10 @@ sparc_init_pic_reg (void)
   edge entry_edge;
   rtx_insn *seq;
 
-  if (!crtl->uses_pic_offset_table)
+  /* In PIC mode, we need to always initialize the PIC register if optimization
+     is enabled, because we are called from IRA and LRA may later force things
+     to the constant pool for optimization purposes.  */
+  if (!flag_pic || (!crtl->uses_pic_offset_table && !optimize))
     return;
 
   start_sequence ();
diff --git a/gcc/config/sparc/sparc.h b/gcc/config/sparc/sparc.h
index 015065ffb81..4b09fc86b78 100644
--- a/gcc/config/sparc/sparc.h
+++ b/gcc/config/sparc/sparc.h
@@ -736,6 +736,13 @@ along with GCC; see the file COPYING3.  If not see
    register window instruction in the prologue.  */
 #define HARD_REGNO_RENAME_OK(FROM, TO) ((FROM) != 1)
 
+/* Select a register mode required for caller save of hard regno REGNO.
+   Contrary to what is documented, the default is not the smallest suitable
+   mode but the largest suitable mode for the given (REGNO, NREGS) pair and
+   it quickly creates paradoxical subregs that can be problematic.  */
+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \
+  ((MODE) == VOIDmode ? choose_hard_reg_mode (REGNO, NREGS, false) : (MODE))
+
 /* Specify the registers used for certain standard purposes.
    The values of these macros are register numbers.  */
 
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index 7af62d599b9..0a6e27ffa83 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -1604,10 +1604,7 @@
    (clobber (reg:P O7_REG))]
   "REGNO (operands[0]) == INTVAL (operands[3])"
 {
-  if (flag_delayed_branch)
-    return "sethi\t%%hi(%a1-4), %0\n\tcall\t%a2\n\t add\t%0, %%lo(%a1+4), %0";
-  else
-    return "sethi\t%%hi(%a1-8), %0\n\tadd\t%0, %%lo(%a1-4), %0\n\tcall\t%a2\n\t nop";
+  return output_load_pcrel_sym (operands);
 }
   [(set (attr "type") (const_string "multi"))
    (set (attr "length")
diff --git a/gcc/config/xtensa/xtensa.c b/gcc/config/xtensa/xtensa.c
index 19bd616d67f..ee5612441e2 100644
--- a/gcc/config/xtensa/xtensa.c
+++ b/gcc/config/xtensa/xtensa.c
@@ -2865,7 +2865,8 @@ xtensa_expand_prologue (void)
 			    gen_rtx_SET (mem, reg));
 	    }
 	}
-      if (total_size > 1024)
+      if (total_size > 1024
+	  || (!callee_save_size && total_size > 128))
 	{
 	  rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);
 	  emit_move_insn (tmp_reg, GEN_INT (total_size -
diff --git a/gcc/configure b/gcc/configure
index 481071b4265..b4d80d140b5 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -701,6 +701,7 @@ build_exeext
 all_selected_languages
 all_languages
 all_lang_makefrags
+all_lang_configurefrags
 all_gtfiles
 all_compilers
 srcdir
@@ -18646,7 +18647,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 18649 "configure"
+#line 18650 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -18752,7 +18753,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 18755 "configure"
+#line 18756 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -29559,7 +29560,8 @@ lang_tree_files=
 all_languages=
 all_compilers=
 all_outputs='Makefile'
-# List of language makefile fragments.
+# List of language configure and makefile fragments.
+all_lang_configurefrags=
 all_lang_makefrags=
 # Additional files for gengtype
 all_gtfiles="$target_gtfiles"
@@ -29645,6 +29647,7 @@ do
 	esac
 	$ok || continue
 
+	all_lang_configurefrags="$all_lang_configurefrags \$(srcdir)/$gcc_subdir/config-lang.in"
 	all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$gcc_subdir/Make-lang.in"
 	if test -f $srcdir/$gcc_subdir/lang.opt; then
 	    lang_opt_files="$lang_opt_files $srcdir/$gcc_subdir/lang.opt"
@@ -29815,6 +29818,7 @@ fi
 
 
 
+
 
 
 # Echo link setup.
diff --git a/gcc/configure.ac b/gcc/configure.ac
index ce2825580c6..8243716589f 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -6188,7 +6188,8 @@ lang_tree_files=
 all_languages=
 all_compilers=
 all_outputs='Makefile'
-# List of language makefile fragments.
+# List of language configure and makefile fragments.
+all_lang_configurefrags=
 all_lang_makefrags=
 # Additional files for gengtype
 all_gtfiles="$target_gtfiles"
@@ -6276,6 +6277,7 @@ changequote([,])dnl
 	esac
 	$ok || continue
 
+	all_lang_configurefrags="$all_lang_configurefrags \$(srcdir)/$gcc_subdir/config-lang.in"
 	all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$gcc_subdir/Make-lang.in"
 	if test -f $srcdir/$gcc_subdir/lang.opt; then
 	    lang_opt_files="$lang_opt_files $srcdir/$gcc_subdir/lang.opt"
@@ -6383,6 +6385,7 @@ AC_SUBST(subdirs)
 AC_SUBST(srcdir)
 AC_SUBST(all_compilers)
 AC_SUBST(all_gtfiles)
+AC_SUBST(all_lang_configurefrags)
 AC_SUBST(all_lang_makefrags)
 AC_SUBST(all_languages)
 AC_SUBST(all_selected_languages)
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index c977850d067..f44fdee6aa1 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,238 @@
+2019-11-08  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-10-29  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90998 - ICE with copy elision in init by ctor and -Wconversion.
+	* call.c (joust): Don't attempt to warn if ->second_conv is null.
+
+2019-11-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-11-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92343
+	* constexpr.c (potential_constant_expression_1): Return true rather
+	than false for PREDICT_EXPR.
+
+	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90947
+	* cp-tree.h (type_initializer_zero_p): Declare.
+	* decl.c (reshape_init_array_1): Formatting fix.
+	* tree.c (type_initializer_zero_p): New function.  Moved from
+	../tree.c, use next_initializable_field, formatting fix.  Return
+	false for TYPE_NON_AGGREGATE_CLASS types.
+
+	2019-10-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85887
+	* decl.c (expand_static_init): Drop ECF_LEAF from __cxa_guard_acquire
+	and __cxa_guard_release.
+
+	2019-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92015
+	* constexpr.c (cxx_eval_component_reference, cxx_eval_bit_field_ref):
+	Use STRIP_ANY_LOCATION_WRAPPER on CONSTRUCTOR elts.
+
+2019-10-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92201
+	* cp-gimplify.c (cp_gimplify_expr): If gimplify_to_rvalue changes the
+	function pointer type, re-add cast to the original one.
+
+2018-10-26  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Backport from mainline
+
+	2019-06-01  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	PR c++/85254
+	* class.c (fixup_type_variants): Handle CLASSTYPE_FINAL.
+
+2019-10-24  Marek Polacek  <polacek@redhat.com>
+
+	* decl.c (reshape_init_r): Add missing space.
+
+2019-10-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-10-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/92106 - ICE with structured bindings and -Wreturn-local-addr.
+	* typeck.c (maybe_warn_about_returning_address_of_local): Avoid
+	recursing on null initializer and return false instead.
+
+	PR c++/92062 - ODR-use ignored for static member of class template.
+	* pt.c (has_value_dependent_address): Strip location wrappers.
+
+2019-10-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/91974
+	* cp-gimplify.c (cp_gimplify_expr) <case CALL_EXPR>: For
+	-fstrong-eval-order ensure CALL_EXPR_FN side-effects are evaluated
+	before any arguments.  Additionally, ensure CALL_EXPR_FN that isn't
+	invariant nor OBJ_TYPE_REF nor SSA_NAME is forced into a temporary.
+
+	2019-09-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/88203
+	* parser.c (cp_parser_omp_var_list_no_open): Parse predefined
+	variables.
+	* semantics.c (finish_omp_clauses): Allow predefined variables in
+	shared and firstprivate clauses, even when they are predetermined
+	shared.
+	* cp-gimplify.c (cxx_omp_predetermined_sharing_1): Return
+	OMP_CLAUSE_DEFAULT_SHARED for predefined variables.
+
+	2019-08-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/91401
+	* parser.c (cp_parser_omp_clause_dist_schedule): Comment out the
+	check_no_duplicate_clause call, instead emit a warning for duplicate
+	dist_schedule clauses.
+
+2019-10-16  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-02  Richard Biener  <rguenther@suse.de>
+
+	PR c++/91606
+	* decl.c (build_ptrmemfunc_type): Mark pointer-to-member
+	fat pointer structure members as DECL_NONADDRESSABLE_P.
+
+2019-10-08  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-09-15  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91740 - ICE with constexpr call and ?: in ARRAY_REF.
+	* pt.c (build_non_dependent_expr): Call build_non_dependent_expr for
+	the first operand.
+
+2019-09-28  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-09-28  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91923 - failure-to-SFINAE with class type NTTP in C++17.
+	* pt.c (invalid_nontype_parm_type_p): Only emit errors when
+	tf_error.
+
+2019-09-10  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-09-10  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91705 - constexpr evaluation rejects ++/-- on floats.
+	* constexpr.c (cxx_eval_increment_expression): Call fold_simple on
+	the offset.
+
+2019-09-01  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-09-01  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91129 - wrong error with binary op in template argument.
+	* typeck.c (warn_for_null_address): Use fold_for_warn instead of
+	fold_non_dependent_expr.
+	(cp_build_binary_op): Likewise.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from mainline
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* parser.c (cp_parser_initial_pragma): Call c_common_no_more_pch ()
+	after determining that the first token is not
+	PRAGMA_GCC_PCH_PREPROCESS.
+
+2019-08-23  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-08-23  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/91521 - wrong error with operator->.
+	* decl.c (grokdeclarator): Return error_mark_node for an invalid
+	trailing return type.
+
+2019-08-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90393 - ICE with throw in ?:
+	* call.c (build_conditional_expr_1): Revert changes from
+	PR c++/64372 and c++/86205.
+
+2019-08-15  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-08-07  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/81429 - wrong parsing of constructor with C++11 attribute.
+	* parser.c (cp_parser_constructor_declarator_p): Handle the scenario
+	when a parameter declaration begins with [[attribute]].
+
+	2019-08-08  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/87519 - bogus warning with -Wsign-conversion.
+	* typeck.c (cp_build_binary_op): Use same_type_p instead of comparing
+	the types directly.
+
+	2019-08-13  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90473 - wrong code with nullptr in default argument.
+	* call.c (null_ptr_cst_p): Update quote from the standard.
+	* decl.c (check_default_argument): Don't return nullptr when the arg
+	has side-effects.
+
+	2019-06-14  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90884 - stray note with -Wctor-dtor-privacy.
+	* class.c (maybe_warn_about_overly_private_class): Guard the call to
+	inform.
+
+2019-08-14  Martin Sebor  <msebor@redhat.com>
+
+	Backported from mainline
+	2019-08-01  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/90947
+	* decl.c (reshape_init_array_1): Avoid truncating initializer
+	lists containing string literals.
+
+2019-08-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/91436
+	* name-lookup.c (get_std_name_hint): Fix min_dialect field for
+	complex_literals and make_unique entries.
+
+2019-08-12  Tom Honermann  <tom@honermann.net>
+
+	* parser.c (cp_parser_template_declaration_after_parameters): Enable
+	class template argument deduction for non-type template parameters
+	in literal operator templates.
+
+2019-08-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91378 - ICE with noexcept and auto return type.
+	* pt.c (maybe_instantiate_noexcept): push_to_top_level.
+
+	PR c++/90538 - multiple expansions of capture packs
+	* cp-tree.h (DECLTYPE_FOR_INIT_CAPTURE): Remove.
+	* lambda.c (add_capture): Copy parameter packs from init.
+	(lambda_capture_field_type): Always use auto for init-capture.
+	* pt.c (uses_parameter_packs): Return tree.
+	(tsubst) [DECLTYPE_TYPE]: Remove init-capture handling.
+	(gen_elem_of_pack_expansion_instantiation): Don't push
+	local_specialization_stack.
+	(prepend_one_capture): New.
+	(tsubst_lambda_expr): Use it.  Don't touch local_specializations.
+	(do_auto_deduction): Avoid redundant error.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
@@ -16,7 +251,7 @@
 
 	Backported from mainline
 	2019-08-02  Marek Polacek  <polacek@redhat.com>
-	
+
 	PR c++/91230 - wrong error with __PRETTY_FUNCTION__ and generic lambda.
 	* pt.c (value_dependent_expression_p): Consider __PRETTY_FUNCTION__
 	inside a template function value-dependent.
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index 9e22a146a16..8f950d13321 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -530,9 +530,8 @@ null_ptr_cst_p (tree t)
 
   /* [conv.ptr]
 
-     A null pointer constant is an integral constant expression
-     (_expr.const_) rvalue of integer type that evaluates to zero or
-     an rvalue of type std::nullptr_t. */
+     A null pointer constant is an integer literal ([lex.icon]) with value
+     zero or a prvalue of type std::nullptr_t.  */
   if (NULLPTR_TYPE_P (type))
     return true;
 
@@ -5186,46 +5185,56 @@ build_conditional_expr_1 (const op_location_t &loc,
   arg3_type = unlowered_expr_type (arg3);
   if (VOID_TYPE_P (arg2_type) || VOID_TYPE_P (arg3_type))
     {
-      /* 'void' won't help in resolving an overloaded expression on the
-	 other side, so require it to resolve by itself.  */
-      if (arg2_type == unknown_type_node)
-	{
-	  arg2 = resolve_nondeduced_context_or_error (arg2, complain);
-	  arg2_type = TREE_TYPE (arg2);
-	}
-      if (arg3_type == unknown_type_node)
-	{
-	  arg3 = resolve_nondeduced_context_or_error (arg3, complain);
-	  arg3_type = TREE_TYPE (arg3);
-	}
+      /* Do the conversions.  We don't these for `void' type arguments
+	 since it can't have any effect and since decay_conversion
+	 does not handle that case gracefully.  */
+      if (!VOID_TYPE_P (arg2_type))
+	arg2 = decay_conversion (arg2, complain);
+      if (!VOID_TYPE_P (arg3_type))
+	arg3 = decay_conversion (arg3, complain);
+      arg2_type = TREE_TYPE (arg2);
+      arg3_type = TREE_TYPE (arg3);
 
       /* [expr.cond]
 
 	 One of the following shall hold:
 
 	 --The second or the third operand (but not both) is a
-	   throw-expression (_except.throw_); the result is of the type
-	   and value category of the other.
+	   throw-expression (_except.throw_); the result is of the
+	   type of the other and is an rvalue.
 
 	 --Both the second and the third operands have type void; the
-	   result is of type void and is a prvalue.  */
+	   result is of type void and is an rvalue.
+
+	 We must avoid calling force_rvalue for expressions of type
+	 "void" because it will complain that their value is being
+	 used.  */
       if (TREE_CODE (arg2) == THROW_EXPR
 	  && TREE_CODE (arg3) != THROW_EXPR)
 	{
+	  if (!VOID_TYPE_P (arg3_type))
+	    {
+	      arg3 = force_rvalue (arg3, complain);
+	      if (arg3 == error_mark_node)
+		return error_mark_node;
+	    }
+	  arg3_type = TREE_TYPE (arg3);
 	  result_type = arg3_type;
-	  is_glvalue = glvalue_p (arg3);
 	}
       else if (TREE_CODE (arg2) != THROW_EXPR
 	       && TREE_CODE (arg3) == THROW_EXPR)
 	{
+	  if (!VOID_TYPE_P (arg2_type))
+	    {
+	      arg2 = force_rvalue (arg2, complain);
+	      if (arg2 == error_mark_node)
+		return error_mark_node;
+	    }
+	  arg2_type = TREE_TYPE (arg2);
 	  result_type = arg2_type;
-	  is_glvalue = glvalue_p (arg2);
 	}
       else if (VOID_TYPE_P (arg2_type) && VOID_TYPE_P (arg3_type))
-	{
-	  result_type = void_type_node;
-	  is_glvalue = false;
-	}
+	result_type = void_type_node;
       else
 	{
           if (complain & tf_error)
@@ -5244,6 +5253,7 @@ build_conditional_expr_1 (const op_location_t &loc,
 	  return error_mark_node;
 	}
 
+      is_glvalue = false;
       goto valid_operands;
     }
   /* [expr.cond]
@@ -5361,6 +5371,10 @@ build_conditional_expr_1 (const op_location_t &loc,
       && same_type_p (arg2_type, arg3_type))
     {
       result_type = arg2_type;
+      if (processing_template_decl)
+	/* Let lvalue_kind know this was a glvalue.  */
+	result_type = cp_build_reference_type (result_type, xvalue_p (arg2));
+
       arg2 = mark_lvalue_use (arg2);
       arg3 = mark_lvalue_use (arg3);
       goto valid_operands;
@@ -5558,13 +5572,6 @@ build_conditional_expr_1 (const op_location_t &loc,
     return error_mark_node;
 
  valid_operands:
-  if (processing_template_decl && is_glvalue)
-    {
-      /* Let lvalue_kind know this was a glvalue.  */
-      tree arg = (result_type == arg2_type ? arg2 : arg3);
-      result_type = cp_build_reference_type (result_type, xvalue_p (arg));
-    }
-
   result = build3_loc (loc, COND_EXPR, result_type, arg1, arg2, arg3);
 
   /* If the ARG2 and ARG3 are the same and don't have side-effects,
@@ -10732,7 +10739,9 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,
      either between a constructor and a conversion op, or between two
      conversion ops.  */
   if ((complain & tf_warning)
-      && winner && warn_conversion && cand1->second_conv
+      /* In C++17, the constructor might have been elided, which means that
+	 an originally null ->second_conv could become non-null.  */
+      && winner && warn_conversion && cand1->second_conv && cand2->second_conv
       && (!DECL_CONSTRUCTOR_P (cand1->fn) || !DECL_CONSTRUCTOR_P (cand2->fn))
       && winner != compare_ics (cand1->second_conv, cand2->second_conv))
     {
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
index a47777cdd9e..f7059fb7341 100644
--- a/gcc/cp/class.c
+++ b/gcc/cp/class.c
@@ -1907,6 +1907,7 @@ fixup_type_variants (tree t)
 	= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t);
 
       TYPE_POLYMORPHIC_P (variants) = TYPE_POLYMORPHIC_P (t);
+      CLASSTYPE_FINAL (variants) = CLASSTYPE_FINAL (t);
 
       TYPE_BINFO (variants) = TYPE_BINFO (t);
 
@@ -2149,10 +2150,10 @@ maybe_warn_about_overly_private_class (tree t)
 
       if (!nonprivate_ctor)
 	{
-	  warning (OPT_Wctor_dtor_privacy,
-		   "%q#T only defines private constructors and has no friends",
-		   t);
-	  if (copy_or_move)
+	  bool w = warning (OPT_Wctor_dtor_privacy,
+			    "%q#T only defines private constructors and has "
+			    "no friends", t);
+	  if (w && copy_or_move)
 	    inform (DECL_SOURCE_LOCATION (copy_or_move),
 		    "%q#D is public, but requires an existing %q#T object",
 		    copy_or_move, t);
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
index f6f21b33396..9845416a812 100644
--- a/gcc/cp/constexpr.c
+++ b/gcc/cp/constexpr.c
@@ -2703,7 +2703,10 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,
 	  : field == part)
 	{
 	  if (value)
-	    return value;
+	    {
+	      STRIP_ANY_LOCATION_WRAPPER (value);
+	      return value;
+	    }
 	  else
 	    /* We're in the middle of initializing it.  */
 	    break;
@@ -2793,6 +2796,7 @@ cxx_eval_bit_field_ref (const constexpr_ctx *ctx, tree t,
   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (whole), i, field, value)
     {
       tree bitpos = bit_position (field);
+      STRIP_ANY_LOCATION_WRAPPER (value);
       if (bitpos == start && DECL_SIZE (field) == TREE_OPERAND (t, 1))
 	return value;
       if (TREE_CODE (TREE_TYPE (field)) == INTEGER_TYPE
@@ -3973,6 +3977,10 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,
   tree offset = TREE_OPERAND (t, 1);
   gcc_assert (TREE_CONSTANT (offset));
 
+  /* OFFSET is constant, but perhaps not constant enough.  We need to
+     e.g. bash FLOAT_EXPRs to REAL_CSTs.  */
+  offset = fold_simple (offset);
+
   /* The operand as an lvalue.  */
   op = cxx_eval_constant_expression (ctx, op, true,
 				     non_constant_p, overflow_p);
@@ -5917,6 +5925,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
     case LABEL_DECL:
     case LABEL_EXPR:
     case CASE_LABEL_EXPR:
+    case PREDICT_EXPR:
     case CONST_DECL:
     case SIZEOF_EXPR:
     case ALIGNOF_EXPR:
@@ -6751,7 +6760,6 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
 
     case CLEANUP_STMT:
     case EMPTY_CLASS_EXPR:
-    case PREDICT_EXPR:
       return false;
 
     case GOTO_EXPR:
diff --git a/gcc/cp/cp-gimplify.c b/gcc/cp/cp-gimplify.c
index 17d10456341..a7121b70a3b 100644
--- a/gcc/cp/cp-gimplify.c
+++ b/gcc/cp/cp-gimplify.c
@@ -816,6 +816,27 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)
 
     case CALL_EXPR:
       ret = GS_OK;
+      if (flag_strong_eval_order == 2
+	  && CALL_EXPR_FN (*expr_p)
+	  && cp_get_callee_fndecl_nofold (*expr_p) == NULL_TREE)
+	{
+	  tree fnptrtype = TREE_TYPE (CALL_EXPR_FN (*expr_p));
+	  enum gimplify_status t
+	    = gimplify_expr (&CALL_EXPR_FN (*expr_p), pre_p, NULL,
+			     is_gimple_call_addr, fb_rvalue);
+	  if (t == GS_ERROR)
+	    ret = GS_ERROR;
+	  else if (is_gimple_variable (CALL_EXPR_FN (*expr_p))
+		   && TREE_CODE (CALL_EXPR_FN (*expr_p)) != SSA_NAME)
+	    CALL_EXPR_FN (*expr_p)
+	      = get_initialized_tmp_var (CALL_EXPR_FN (*expr_p), pre_p,
+					 NULL);
+	  /* GIMPLE considers most pointer conversion useless, but for
+	     calls we actually care about the exact function pointer type.  */
+	  if (t != GS_ERROR && TREE_TYPE (CALL_EXPR_FN (*expr_p)) != fnptrtype)
+	    CALL_EXPR_FN (*expr_p)
+	      = build1 (NOP_EXPR, fnptrtype, CALL_EXPR_FN (*expr_p));
+	}
       if (!CALL_EXPR_FN (*expr_p))
 	/* Internal function call.  */;
       else if (CALL_EXPR_REVERSE_ARGS (*expr_p))
@@ -2050,6 +2071,9 @@ cxx_omp_predetermined_sharing_1 (tree decl)
       tree ctx = CP_DECL_CONTEXT (decl);
       if (TYPE_P (ctx) && MAYBE_CLASS_TYPE_P (ctx))
 	return OMP_CLAUSE_DEFAULT_SHARED;
+
+      if (c_omp_predefined_variable (decl))
+	return OMP_CLAUSE_DEFAULT_SHARED;
     }
 
   /* this may not be specified in data-sharing clauses, still we need
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index ff4ce068a83..050e4b0f3a7 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -423,7 +423,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];
       LAMBDA_EXPR_MUTABLE_P (in LAMBDA_EXPR)
       DECL_FINAL_P (in FUNCTION_DECL)
       QUALIFIED_NAME_IS_TEMPLATE (in SCOPE_REF)
-      DECLTYPE_FOR_INIT_CAPTURE (in DECLTYPE_TYPE)
       CONSTRUCTOR_IS_DEPENDENT (in CONSTRUCTOR)
       TINFO_USED_TEMPLATE_ID (in TEMPLATE_INFO)
       PACK_EXPANSION_SIZEOF_P (in *_PACK_EXPANSION)
@@ -4471,12 +4470,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)
   (DECLTYPE_TYPE_CHECK (NODE))->type_common.string_flag
 
 /* These flags indicate that we want different semantics from normal
-   decltype: lambda capture just drops references, init capture
-   uses auto semantics, lambda proxies look through implicit dereference.  */
+   decltype: lambda capture just drops references,
+   lambda proxies look through implicit dereference.  */
 #define DECLTYPE_FOR_LAMBDA_CAPTURE(NODE) \
   TREE_LANG_FLAG_0 (DECLTYPE_TYPE_CHECK (NODE))
-#define DECLTYPE_FOR_INIT_CAPTURE(NODE) \
-  TREE_LANG_FLAG_1 (DECLTYPE_TYPE_CHECK (NODE))
 #define DECLTYPE_FOR_LAMBDA_PROXY(NODE) \
   TREE_LANG_FLAG_2 (DECLTYPE_TYPE_CHECK (NODE))
 #define DECLTYPE_FOR_REF_CAPTURE(NODE) \
@@ -6779,7 +6776,7 @@ extern bool maybe_instantiate_noexcept		(tree, tsubst_flags_t = tf_warning_or_er
 extern tree instantiate_decl			(tree, bool, bool);
 extern int comp_template_parms			(const_tree, const_tree);
 extern bool builtin_pack_fn_p			(tree);
-extern bool uses_parameter_packs                (tree);
+extern tree uses_parameter_packs                (tree);
 extern bool template_parameter_pack_p           (const_tree);
 extern bool function_parameter_pack_p		(const_tree);
 extern bool function_parameter_expanded_from_pack_p (tree, tree);
@@ -7328,6 +7325,11 @@ extern tree cxx_copy_lang_qualifiers		(const_tree, const_tree);
 
 extern void cxx_print_statistics		(void);
 extern bool maybe_warn_zero_as_null_pointer_constant (tree, location_t);
+/* Analogous to initializer_zerop but also examines the type for
+   which the initializer is being used.  Unlike initializer_zerop,
+   considers empty strings to be zero initializers for arrays and
+   non-zero for pointers.  */
+extern bool type_initializer_zero_p		(tree, tree);
 
 /* in ptree.c */
 extern void cxx_print_xnode			(FILE *, tree, int);
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index b57ded813b6..444332e53ba 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -4474,13 +4474,27 @@ cp_fname_init (const char* name, tree *type_p)
 static tree
 cp_make_fname_decl (location_t loc, tree id, int type_dep)
 {
-  const char *const name = (type_dep && in_template_function ()
-			    ? NULL : fname_as_string (type_dep));
+  const char * name = NULL;
+  bool release_name = false;
+  if (!(type_dep && in_template_function ()))
+    {
+      if (current_function_decl == NULL_TREE)
+	name = "top level";
+      else if (type_dep == 1) /* __PRETTY_FUNCTION__ */
+	name = cxx_printable_name (current_function_decl, 2);
+      else if (type_dep == 0) /* __FUNCTION__ */
+	{
+	  name = fname_as_string (type_dep);
+	  release_name = true;
+	}
+      else
+	gcc_unreachable ();
+    }
   tree type;
   tree init = cp_fname_init (name, &type);
   tree decl = build_decl (loc, VAR_DECL, id, type);
 
-  if (name)
+  if (release_name)
     free (CONST_CAST (char *, name));
 
   /* As we're using pushdecl_with_scope, we must set the context.  */
@@ -5836,8 +5850,8 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,
       /* Pointers initialized to strings must be treated as non-zero
 	 even if the string is empty.  */
       tree init_type = TREE_TYPE (elt_init);
-      if ((POINTER_TYPE_P (elt_type) != POINTER_TYPE_P (init_type))
-	  || !initializer_zerop (elt_init))
+      if (POINTER_TYPE_P (elt_type) != POINTER_TYPE_P (init_type)
+	  || !type_initializer_zero_p (elt_type, elt_init))
 	last_nonzero = index;
 
       /* This can happen with an invalid initializer (c++/54501).  */
@@ -6114,7 +6128,7 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,
 			       (CONSTRUCTOR_ELT (stripped_init,0)->value))))
 		{
 		  if (complain & tf_error)
-		    error ("too many braces around scalar initializer"
+		    error ("too many braces around scalar initializer "
 		           "for type %qT", type);
 		  init = error_mark_node;
 		}
@@ -8407,14 +8421,14 @@ expand_static_init (tree decl, tree init)
 	      (acquire_name, build_function_type_list (integer_type_node,
 						       TREE_TYPE (guard_addr),
 						       NULL_TREE),
-	       NULL_TREE, ECF_NOTHROW | ECF_LEAF);
+	       NULL_TREE, ECF_NOTHROW);
 	  if (!release_fn || !abort_fn)
 	    vfntype = build_function_type_list (void_type_node,
 						TREE_TYPE (guard_addr),
 						NULL_TREE);
 	  if (!release_fn)
 	    release_fn = push_library_fn (release_name, vfntype, NULL_TREE,
-					   ECF_NOTHROW | ECF_LEAF);
+					  ECF_NOTHROW);
 	  if (!abort_fn)
 	    abort_fn = push_library_fn (abort_name, vfntype, NULL_TREE,
 					ECF_NOTHROW | ECF_LEAF);
@@ -9539,10 +9553,12 @@ build_ptrmemfunc_type (tree type)
   TYPE_PTRMEMFUNC_FLAG (t) = 1;
 
   field = build_decl (input_location, FIELD_DECL, pfn_identifier, type);
+  DECL_NONADDRESSABLE_P (field) = 1;
   fields = field;
 
   field = build_decl (input_location, FIELD_DECL, delta_identifier, 
 		      delta_type_node);
+  DECL_NONADDRESSABLE_P (field) = 1;
   DECL_CHAIN (field) = fields;
   fields = field;
 
@@ -11435,6 +11451,8 @@ grokdeclarator (const cp_declarator *declarator,
 		else if (late_return_type
 			 && sfk != sfk_conversion)
 		  {
+		    if (late_return_type == error_mark_node)
+		      return error_mark_node;
 		    if (cxx_dialect < cxx11)
 		      /* Not using maybe_warn_cpp0x because this should
 			 always be an error.  */
@@ -13042,7 +13060,9 @@ check_default_argument (tree decl, tree arg, tsubst_flags_t complain)
   /* Avoid redundant -Wzero-as-null-pointer-constant warnings at
      the call sites.  */
   if (TYPE_PTR_OR_PTRMEM_P (decl_type)
-      && null_ptr_cst_p (arg))
+      && null_ptr_cst_p (arg)
+      /* Don't lose side-effects as in PR90473.  */
+      && !TREE_SIDE_EFFECTS (arg))
     return nullptr_node;
 
   /* [dcl.fct.default]
diff --git a/gcc/cp/lambda.c b/gcc/cp/lambda.c
index 93664181b47..edfd2f75853 100644
--- a/gcc/cp/lambda.c
+++ b/gcc/cp/lambda.c
@@ -220,16 +220,7 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,
   tree type;
   bool is_this = is_this_parameter (tree_strip_nop_conversions (expr));
 
-  if (!is_this && type_dependent_expression_p (expr))
-    {
-      type = cxx_make_type (DECLTYPE_TYPE);
-      DECLTYPE_TYPE_EXPR (type) = expr;
-      DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;
-      DECLTYPE_FOR_INIT_CAPTURE (type) = explicit_init_p;
-      DECLTYPE_FOR_REF_CAPTURE (type) = by_reference_p;
-      SET_TYPE_STRUCTURAL_EQUALITY (type);
-    }
-  else if (!is_this && explicit_init_p)
+  if (!is_this && explicit_init_p)
     {
       tree auto_node = make_auto ();
       
@@ -240,6 +231,14 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,
 	type = build_reference_type (type);
       type = do_auto_deduction (type, expr, auto_node);
     }
+  else if (!is_this && type_dependent_expression_p (expr))
+    {
+      type = cxx_make_type (DECLTYPE_TYPE);
+      DECLTYPE_TYPE_EXPR (type) = expr;
+      DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;
+      DECLTYPE_FOR_REF_CAPTURE (type) = by_reference_p;
+      SET_TYPE_STRUCTURAL_EQUALITY (type);
+    }
   else
     {
       type = non_reference (unlowered_expr_type (expr));
@@ -602,7 +601,16 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,
   name = get_identifier (buf);
 
   if (variadic)
-    type = make_pack_expansion (type);
+    {
+      type = make_pack_expansion (type);
+      if (explicit_init_p)
+	/* With an explicit initializer 'type' is auto, which isn't really a
+	   parameter pack in this context.  We will want as many fields as we
+	   have elements in the expansion of the initializer, so use its packs
+	   instead.  */
+	PACK_EXPANSION_PARAMETER_PACKS (type)
+	  = uses_parameter_packs (initializer);
+    }
 
   /* Make member variable.  */
   member = build_decl (input_location, FIELD_DECL, name, type);
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
index 4ca976c812d..29004d920b1 100644
--- a/gcc/cp/name-lookup.c
+++ b/gcc/cp/name-lookup.c
@@ -5656,7 +5656,7 @@ get_std_name_hint (const char *name)
     {"bitset", "<bitset>", cxx11},
     /* <complex>.  */
     {"complex", "<complex>", cxx98},
-    {"complex_literals", "<complex>", cxx98},
+    {"complex_literals", "<complex>", cxx14},
     /* <condition_variable>. */
     {"condition_variable", "<condition_variable>", cxx11},
     {"condition_variable_any", "<condition_variable>", cxx11},
@@ -5718,7 +5718,7 @@ get_std_name_hint (const char *name)
     {"multimap", "<map>", cxx98},
     /* <memory>.  */
     {"make_shared", "<memory>", cxx11},
-    {"make_unique", "<memory>", cxx11},
+    {"make_unique", "<memory>", cxx14},
     {"shared_ptr", "<memory>", cxx11},
     {"unique_ptr", "<memory>", cxx11},
     {"weak_ptr", "<memory>", cxx11},
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index a7218e752b1..3fac495d293 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -27596,7 +27596,9 @@ cp_parser_constructor_declarator_p (cp_parser *parser, cp_parser_flags flags,
 	  /* A parameter declaration begins with a decl-specifier,
 	     which is either the "attribute" keyword, a storage class
 	     specifier, or (usually) a type-specifier.  */
-	  && !cp_lexer_next_token_is_decl_specifier_keyword (parser->lexer))
+	  && !cp_lexer_next_token_is_decl_specifier_keyword (parser->lexer)
+	  /* A parameter declaration can also begin with [[attribute]].  */
+	  && !cp_next_tokens_can_be_std_attribute_p (parser))
 	{
 	  tree type;
 	  tree pushed_scope = NULL_TREE;
@@ -27911,7 +27913,10 @@ cp_parser_template_declaration_after_parameters (cp_parser* parser,
 	    {
 	      tree parm_list = TREE_VEC_ELT (parameter_list, 0);
 	      tree parm = INNERMOST_TEMPLATE_PARMS (parm_list);
-	      if (CLASS_TYPE_P (TREE_TYPE (parm)))
+	      if (TREE_CODE (parm) != PARM_DECL)
+		ok = false;
+	      else if (MAYBE_CLASS_TYPE_P (TREE_TYPE (parm))
+		       && !TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))
 		/* OK, C++20 string literal operator template.  We don't need
 		   to warn in lower dialects here because we will have already
 		   warned about the template parameter.  */;
@@ -27925,7 +27930,7 @@ cp_parser_template_declaration_after_parameters (cp_parser* parser,
 	      tree type = INNERMOST_TEMPLATE_PARMS (parm_type);
 	      tree parm_list = TREE_VEC_ELT (parameter_list, 1);
 	      tree parm = INNERMOST_TEMPLATE_PARMS (parm_list);
-	      if (parm == error_mark_node
+	      if (TREE_CODE (parm) != PARM_DECL
 		  || TREE_TYPE (parm) != TREE_TYPE (type)
 		  || !TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))
 		ok = false;
@@ -32463,6 +32468,14 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,
 	    decl = TREE_OPERAND (decl, 0);
 	  cp_lexer_consume_token (parser->lexer);
 	}
+      else if (cp_parser_is_keyword (token, RID_FUNCTION_NAME)
+	       || cp_parser_is_keyword (token, RID_PRETTY_FUNCTION_NAME)
+	       || cp_parser_is_keyword (token, RID_C99_FUNCTION_NAME))
+	{
+	  cp_id_kind idk;
+	  decl = cp_parser_primary_expression (parser, false, false, false,
+					       &idk);
+	}
       else
 	{
 	  name = cp_parser_id_expression (parser, /*template_p=*/false,
@@ -34891,8 +34904,10 @@ cp_parser_omp_clause_dist_schedule (cp_parser *parser, tree list,
   else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_COMMA_CLOSE_PAREN))
     goto resync_fail;
 
-  check_no_duplicate_clause (list, OMP_CLAUSE_DIST_SCHEDULE, "dist_schedule",
-			     location);
+  /* check_no_duplicate_clause (list, OMP_CLAUSE_DIST_SCHEDULE,
+				"dist_schedule", location); */
+  if (omp_find_clause (list, OMP_CLAUSE_DIST_SCHEDULE))
+    warning_at (location, 0, "too many %qs clauses", "dist_schedule");
   OMP_CLAUSE_CHAIN (c) = list;
   return c;
 
@@ -40746,7 +40761,10 @@ cp_parser_initial_pragma (cp_token *first_token)
 
   cp_lexer_get_preprocessor_token (NULL, first_token);
   if (cp_parser_pragma_kind (first_token) != PRAGMA_GCC_PCH_PREPROCESS)
-    return;
+    {
+      c_common_no_more_pch ();
+      return;
+    }
 
   cp_lexer_get_preprocessor_token (NULL, first_token);
   if (first_token->type == CPP_STRING)
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index a2a986b1db1..48d8dbb6ad2 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -3875,7 +3875,7 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)
 }
 
 /* Determines if the expression or type T uses any parameter packs.  */
-bool
+tree
 uses_parameter_packs (tree t)
 {
   tree parameter_packs = NULL_TREE;
@@ -3885,7 +3885,7 @@ uses_parameter_packs (tree t)
   ppd.type_pack_expansion_p = false;
   cp_walk_tree (&t, &find_parameter_packs_r, &ppd, ppd.visited);
   delete ppd.visited;
-  return parameter_packs != NULL_TREE;
+  return parameter_packs;
 }
 
 /* Turn ARG, which may be an expression, type, or a TREE_LIST
@@ -6353,6 +6353,8 @@ check_valid_ptrmem_cst_expr (tree type, tree expr,
 static bool
 has_value_dependent_address (tree op)
 {
+  STRIP_ANY_LOCATION_WRAPPER (op);
+
   /* We could use get_inner_reference here, but there's no need;
      this is only relevant for template non-type arguments, which
      can only be expressed as &id-expression.  */
@@ -11757,10 +11759,6 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,
       ARGUMENT_PACK_SELECT_INDEX (aps) = index;
     }
 
-  // Any local specialization bindings arising from this substitution
-  // cannot be reused for a different INDEX.
-  local_specialization_stack lss (lss_copy);
-
   /* Substitute into the PATTERN with the (possibly altered)
      arguments.  */
   if (pattern == in_decl)
@@ -15130,24 +15128,12 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 				      /*function_p*/false,
 				      /*integral_constant_expression*/false);
 
-	if (DECLTYPE_FOR_INIT_CAPTURE (t))
-	  {
-	    if (type == NULL_TREE)
-	      {
-		if (complain & tf_error)
-		  error ("empty initializer in lambda init-capture");
-		type = error_mark_node;
-	      }
-	    else if (TREE_CODE (type) == TREE_LIST)
-	      type = build_x_compound_expr_from_list (type, ELK_INIT, complain);
-	  }
-
 	--cp_unevaluated_operand;
 	--c_inhibit_evaluation_warnings;
 
 	if (DECLTYPE_FOR_LAMBDA_CAPTURE (t))
 	  type = lambda_capture_field_type (type,
-					    DECLTYPE_FOR_INIT_CAPTURE (t),
+					    false /*explicit_init*/,
 					    DECLTYPE_FOR_REF_CAPTURE (t));
 	else if (DECLTYPE_FOR_LAMBDA_PROXY (t))
 	  type = lambda_proxy_type (type);
@@ -18014,6 +18000,33 @@ tsubst_non_call_postfix_expression (tree t, tree args,
   return t;
 }
 
+/* Subroutine of tsubst_lambda_expr: add the FIELD/INIT capture pair to the
+   LAMBDA_EXPR_CAPTURE_LIST passed in LIST.  Do deduction for a previously
+   dependent init-capture.  */
+
+static void
+prepend_one_capture (tree field, tree init, tree &list,
+		     tsubst_flags_t complain)
+{
+  if (tree auto_node = type_uses_auto (TREE_TYPE (field)))
+    {
+      tree type = NULL_TREE;
+      if (!init)
+	{
+	  if (complain & tf_error)
+	    error ("empty initializer in lambda init-capture");
+	  init = error_mark_node;
+	}
+      else if (TREE_CODE (init) == TREE_LIST)
+	init = build_x_compound_expr_from_list (init, ELK_INIT, complain);
+      if (!type)
+	type = do_auto_deduction (TREE_TYPE (field), init, auto_node, complain);
+      TREE_TYPE (field) = type;
+      cp_apply_type_quals_to_decl (cp_type_quals (type), field);
+    }
+  list = tree_cons (field, init, list);
+}
+
 /* T is a LAMBDA_EXPR.  Generate a new LAMBDA_EXPR for the current
    instantiation context.  Instantiating a pack expansion containing a lambda
    might result in multiple lambdas all based on the same lambda in the
@@ -18025,17 +18038,8 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)
   tree oldfn = lambda_function (t);
   in_decl = oldfn;
 
-  /* If we have already specialized this lambda expr, reuse it.  See
-     PR c++/87322.  */
-  if (local_specializations)
-    if (tree r = retrieve_local_specialization (t))
-      return r;
-
   tree r = build_lambda_expr ();
 
-  if (local_specializations)
-    register_local_specialization (r, t);
-
   LAMBDA_EXPR_LOCATION (r)
     = LAMBDA_EXPR_LOCATION (t);
   LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (r)
@@ -18088,15 +18092,15 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 	  gcc_assert (TREE_CODE (init) == TREE_VEC
 		      && TREE_VEC_LENGTH (init) == len);
 	  for (int i = 0; i < len; ++i)
-	    LAMBDA_EXPR_CAPTURE_LIST (r)
-	      = tree_cons (TREE_VEC_ELT (field, i),
-			   TREE_VEC_ELT (init, i),
-			   LAMBDA_EXPR_CAPTURE_LIST (r));
+	    prepend_one_capture (TREE_VEC_ELT (field, i),
+				 TREE_VEC_ELT (init, i),
+				 LAMBDA_EXPR_CAPTURE_LIST (r),
+				 complain);
 	}
       else
 	{
-	  LAMBDA_EXPR_CAPTURE_LIST (r)
-	    = tree_cons (field, init, LAMBDA_EXPR_CAPTURE_LIST (r));
+	  prepend_one_capture (field, init, LAMBDA_EXPR_CAPTURE_LIST (r),
+			       complain);
 
 	  if (id_equal (DECL_NAME (field), "__this"))
 	    LAMBDA_EXPR_THIS_CAPTURE (r) = field;
@@ -24321,12 +24325,11 @@ maybe_instantiate_noexcept (tree fn, tsubst_flags_t complain)
 	}
       else if (push_tinst_level (fn))
 	{
+	  push_to_top_level ();
 	  push_access_scope (fn);
 	  push_deferring_access_checks (dk_no_deferred);
 	  input_location = DECL_SOURCE_LOCATION (fn);
 
-	  tree save_ccp = current_class_ptr;
-	  tree save_ccr = current_class_ref;
 	  /* If needed, set current_class_ptr for the benefit of
 	     tsubst_copy/PARM_DECL.  */
 	  tree tdecl = DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (fn));
@@ -24352,9 +24355,6 @@ maybe_instantiate_noexcept (tree fn, tsubst_flags_t complain)
 					/*function_p=*/false,
 					/*i_c_e_p=*/true);
 
-	  current_class_ptr = save_ccp;
-	  current_class_ref = save_ccr;
-
 	  /* Build up the noexcept-specification.  */
 	  spec = build_noexcept_spec (noex, tf_warning_or_error);
 
@@ -24364,6 +24364,7 @@ maybe_instantiate_noexcept (tree fn, tsubst_flags_t complain)
 	  pop_deferring_access_checks ();
 	  pop_access_scope (fn);
 	  pop_tinst_level ();
+	  pop_from_top_level ();
 	}
       else
 	spec = noexcept_false_spec;
@@ -25232,8 +25233,9 @@ invalid_nontype_parm_type_p (tree type, tsubst_flags_t complain)
     {
       if (cxx_dialect < cxx2a)
 	{
-	  error ("non-type template parameters of class type only available "
-		 "with %<-std=c++2a%> or %<-std=gnu++2a%>");
+	  if (complain & tf_error)
+	    error ("non-type template parameters of class type only available "
+		   "with %<-std=c++2a%> or %<-std=gnu++2a%>");
 	  return true;
 	}
       if (dependent_type_p (type))
@@ -26715,7 +26717,7 @@ build_non_dependent_expr (tree expr)
   if (TREE_CODE (expr) == COND_EXPR)
     return build3 (COND_EXPR,
 		   TREE_TYPE (expr),
-		   TREE_OPERAND (expr, 0),
+		   build_non_dependent_expr (TREE_OPERAND (expr, 0)),
 		   (TREE_OPERAND (expr, 1)
 		    ? build_non_dependent_expr (TREE_OPERAND (expr, 1))
 		    : build_non_dependent_expr (TREE_OPERAND (expr, 0))),
@@ -27615,6 +27617,9 @@ do_auto_deduction (tree type, tree init, tree auto_node,
     }
   else
     {
+      if (error_operand_p (init))
+	return error_mark_node;
+
       tree parms = build_tree_list (NULL_TREE, type);
       tree tparms;
 
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index 6d40b145fcb..ebfdf9a47b0 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -7790,6 +7790,13 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)
 	    case OMP_CLAUSE_DEFAULT_UNSPECIFIED:
 	      break;
 	    case OMP_CLAUSE_DEFAULT_SHARED:
+	      if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED
+		   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE)
+		  && c_omp_predefined_variable (t))
+		/* The __func__ variable and similar function-local predefined
+		   variables may be listed in a shared or firstprivate
+		   clause.  */
+		break;
 	      if (VAR_P (t)
 		  && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE
 		  && TREE_STATIC (t)
diff --git a/gcc/cp/tree.c b/gcc/cp/tree.c
index 1339e9fd204..ae9bfd24cfb 100644
--- a/gcc/cp/tree.c
+++ b/gcc/cp/tree.c
@@ -5487,6 +5487,68 @@ maybe_warn_zero_as_null_pointer_constant (tree expr, location_t loc)
   return false;
 }
 
+/* Given an initializer INIT for a TYPE, return true if INIT is zero
+   so that it can be replaced by value initialization.  This function
+   distinguishes betwen empty strings as initializers for arrays and
+   for pointers (which make it return false).  */
+
+bool
+type_initializer_zero_p (tree type, tree init)
+{
+  if (type == error_mark_node || init == error_mark_node)
+    return false;
+
+  STRIP_NOPS (init);
+
+  if (POINTER_TYPE_P (type))
+    return TREE_CODE (init) != STRING_CST && initializer_zerop (init);
+
+  if (TREE_CODE (init) != CONSTRUCTOR)
+    return initializer_zerop (init);
+
+  if (TREE_CODE (type) == ARRAY_TYPE)
+    {
+      tree elt_type = TREE_TYPE (type);
+      elt_type = TYPE_MAIN_VARIANT (elt_type);
+      if (elt_type == char_type_node)
+	return initializer_zerop (init);
+
+      tree elt_init;
+      unsigned HOST_WIDE_INT i;
+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, elt_init)
+	if (!type_initializer_zero_p (elt_type, elt_init))
+	  return false;
+      return true;
+    }
+
+  if (TREE_CODE (type) != RECORD_TYPE)
+    return initializer_zerop (init);
+
+  if (TYPE_NON_AGGREGATE_CLASS (type))
+    return false;
+
+  tree fld = TYPE_FIELDS (type);
+
+  tree fld_init;
+  unsigned HOST_WIDE_INT i;
+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, fld_init)
+    {
+      fld = next_initializable_field (fld);
+      if (!fld)
+	return true;
+
+      tree fldtype = TREE_TYPE (fld);
+      if (!type_initializer_zero_p (fldtype, fld_init))
+	return false;
+
+      fld = DECL_CHAIN (fld);
+      if (!fld)
+	break;
+    }
+
+  return true;
+}
+
 #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)
 /* Complain that some language-specific thing hanging off a tree
    node has been accessed improperly.  */
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index 3255af58a25..2169f8c4efd 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -4309,7 +4309,7 @@ warn_for_null_address (location_t location, tree op, tsubst_flags_t complain)
       || TREE_NO_WARNING (op))
     return;
 
-  tree cop = fold_non_dependent_expr (op, complain);
+  tree cop = fold_for_warn (op);
 
   if (TREE_CODE (cop) == ADDR_EXPR
       && decl_with_nonnull_addr_p (TREE_OPERAND (cop, 0))
@@ -4632,9 +4632,8 @@ cp_build_binary_op (const op_location_t &location,
 	      || code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE))
 	{
 	  enum tree_code tcode0 = code0, tcode1 = code1;
-	  tree cop1 = fold_non_dependent_expr (op1, complain);
 	  doing_div_or_mod = true;
-	  warn_for_div_by_zero (location, cop1);
+	  warn_for_div_by_zero (location, fold_for_warn (op1));
 
 	  if (tcode0 == COMPLEX_TYPE || tcode0 == VECTOR_TYPE)
 	    tcode0 = TREE_CODE (TREE_TYPE (TREE_TYPE (op0)));
@@ -4673,11 +4672,8 @@ cp_build_binary_op (const op_location_t &location,
 
     case TRUNC_MOD_EXPR:
     case FLOOR_MOD_EXPR:
-      {
-	tree cop1 = fold_non_dependent_expr (op1, complain);
-	doing_div_or_mod = true;
-	warn_for_div_by_zero (location, cop1);
-      }
+      doing_div_or_mod = true;
+      warn_for_div_by_zero (location, fold_for_warn (op1));
 
       if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE
 	  && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE
@@ -4770,7 +4766,7 @@ cp_build_binary_op (const op_location_t &location,
 	}
       else if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)
 	{
-	  tree const_op1 = fold_non_dependent_expr (op1, complain);
+	  tree const_op1 = fold_for_warn (op1);
 	  if (TREE_CODE (const_op1) != INTEGER_CST)
 	    const_op1 = op1;
 	  result_type = type0;
@@ -4816,10 +4812,10 @@ cp_build_binary_op (const op_location_t &location,
 	}
       else if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)
 	{
-	  tree const_op0 = fold_non_dependent_expr (op0, complain);
+	  tree const_op0 = fold_for_warn (op0);
 	  if (TREE_CODE (const_op0) != INTEGER_CST)
 	    const_op0 = op0;
-	  tree const_op1 = fold_non_dependent_expr (op1, complain);
+	  tree const_op1 = fold_for_warn (op1);
 	  if (TREE_CODE (const_op1) != INTEGER_CST)
 	    const_op1 = op1;
 	  result_type = type0;
@@ -5516,9 +5512,9 @@ cp_build_binary_op (const op_location_t &location,
   if (! converted)
     {
       warning_sentinel w (warn_sign_conversion, short_compare);
-      if (TREE_TYPE (op0) != result_type)
+      if (!same_type_p (TREE_TYPE (op0), result_type))
 	op0 = cp_convert_and_check (result_type, op0, complain);
-      if (TREE_TYPE (op1) != result_type)
+      if (!same_type_p (TREE_TYPE (op1), result_type))
 	op1 = cp_convert_and_check (result_type, op1, complain);
 
       if (op0 == error_mark_node || op1 == error_mark_node)
@@ -9296,8 +9292,10 @@ maybe_warn_about_returning_address_of_local (tree retval)
 	  tree base = DECL_DECOMP_BASE (whats_returned);
 	  if (TYPE_REF_P (TREE_TYPE (base)))
 	    {
-	      tree init = DECL_INITIAL (base);
-	      return maybe_warn_about_returning_address_of_local (init);
+	      if (tree init = DECL_INITIAL (base))
+		return maybe_warn_about_returning_address_of_local (init);
+	      else
+		return false;
 	    }
 	}
       bool w = false;
diff --git a/gcc/doc/avr-mmcu.texi b/gcc/doc/avr-mmcu.texi
index ea0161ecccb..99cd93cb23b 100644
--- a/gcc/doc/avr-mmcu.texi
+++ b/gcc/doc/avr-mmcu.texi
@@ -21,7 +21,7 @@
 @*@var{mcu}@tie{}= @code{ata5272}, @code{ata6616c}, @code{attiny13}, @code{attiny13a}, @code{attiny2313}, @code{attiny2313a}, @code{attiny24}, @code{attiny24a}, @code{attiny25}, @code{attiny261}, @code{attiny261a}, @code{attiny43u}, @code{attiny4313}, @code{attiny44}, @code{attiny44a}, @code{attiny441}, @code{attiny45}, @code{attiny461}, @code{attiny461a}, @code{attiny48}, @code{attiny828}, @code{attiny84}, @code{attiny84a}, @code{attiny841}, @code{attiny85}, @code{attiny861}, @code{attiny861a}, @code{attiny87}, @code{attiny88}, @code{at86rf401}.
 
 @item avr3
-``Classic'' devices with 16@tie{}KiB up to 64@tie{}KiB of  program memory.
+``Classic'' devices with 16@tie{}KiB up to 64@tie{}KiB of program memory.
 @*@var{mcu}@tie{}= @code{at43usb355}, @code{at76c711}.
 
 @item avr31
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index 91679e8b9ba..5e5e8aa87e5 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -6713,6 +6713,33 @@ attributes.
 The following attributes are supported on most targets.
 
 @table @code
+
+@item alias ("@var{target}")
+@cindex @code{alias} variable attribute
+The @code{alias} variable attribute causes the declaration to be emitted
+as an alias for another symbol known as an @dfn{alias target}.  Except
+for top-level qualifiers the alias target must have the same type as
+the alias.  For instance, the following
+
+@smallexample
+int var_target;
+extern int __attribute__ ((alias ("var_target"))) var_alias;
+@end smallexample
+
+@noindent
+defines @code{var_alias} to be an alias for the @code{var_target} variable.
+
+It is an error if the alias target is not defined in the same translation
+unit as the alias.
+
+Note that in the absence of the attribute GCC assumes that distinct
+declarations with external linkage denote distinct objects.  Using both
+the alias and the alias target to access the same object is undefined
+in a translation unit without a declaration of the alias with the attribute.
+
+This attribute requires assembler and object file support, and may not be
+available on all targets.
+
 @cindex @code{aligned} variable attribute
 @item aligned
 @itemx aligned (@var{alignment})
diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi
index 911875f9578..78a59e6b21c 100644
--- a/gcc/doc/install.texi
+++ b/gcc/doc/install.texi
@@ -2129,7 +2129,7 @@ specifying paths @var{path1}, @dots{}, @var{pathN}.
 
 @smallexample
 % @var{srcdir}/configure \
-    --enable-offload-target=i686-unknown-linux-gnu=/path/to/i686/compiler,x86_64-pc-linux-gnu
+    --enable-offload-targets=x86_64-intelmicemul-linux-gnu=/path/to/x86_64/compiler,nvptx-none,hsa
 @end smallexample
 
 If @samp{hsa} is specified as one of the targets, the compiler will be
diff --git a/gcc/dse.c b/gcc/dse.c
index 6f6f768f371..4becdcf1cbb 100644
--- a/gcc/dse.c
+++ b/gcc/dse.c
@@ -2535,10 +2535,13 @@ scan_insn (bb_info_t bb_info, rtx_insn *insn)
 		clear_rhs_from_active_local_stores ();
 	    }
 	}
-      else if (SIBLING_CALL_P (insn) && reload_completed)
+      else if (SIBLING_CALL_P (insn)
+	       && (reload_completed || HARD_FRAME_POINTER_IS_ARG_POINTER))
 	/* Arguments for a sibling call that are pushed to memory are passed
 	   using the incoming argument pointer of the current function.  After
-	   reload that might be (and likely is) frame pointer based.  */
+	   reload that might be (and likely is) frame pointer based.  And, if
+	   it is a frame pointer on the target, even before reload we need to
+	   kill frame pointer based stores.  */
 	add_wild_read (bb_info);
       else
 	/* Every other call, including pure functions, may read any memory
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index 1cec00f2b85..ae47387b763 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -15461,7 +15461,7 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,
   if (mode != GET_MODE (rtl) && GET_MODE (rtl) != VOIDmode)
     return NULL;
 
-  scalar_int_mode int_mode, inner_mode, op1_mode;
+  scalar_int_mode int_mode = BImode, inner_mode, op1_mode;
   switch (GET_CODE (rtl))
     {
     case POST_INC:
@@ -22284,19 +22284,18 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,
       /* If the contexts differ, we may not be talking about the same
 	 thing.
 	 ???  When in LTO the DIE parent is the "abstract" copy and the
-	 context_die is the specification "copy".  But this whole block
-	 should eventually be no longer needed.  */
-      if (parm_die && parm_die->die_parent != context_die && !in_lto_p)
+	 context_die is the specification "copy".  */
+      if (parm_die
+	  && parm_die->die_parent != context_die
+	  && (parm_die->die_parent->die_tag != DW_TAG_GNU_formal_parameter_pack
+	      || parm_die->die_parent->die_parent != context_die)
+	  && !in_lto_p)
 	{
-	  if (!DECL_ABSTRACT_P (node))
-	    {
-	      /* This can happen when creating an inlined instance, in
-		 which case we need to create a new DIE that will get
-		 annotated with DW_AT_abstract_origin.  */
-	      parm_die = NULL;
-	    }
-	  else
-	    gcc_unreachable ();
+	  gcc_assert (!DECL_ABSTRACT_P (node));
+	  /* This can happen when creating a concrete instance, in
+	     which case we need to create a new DIE that will get
+	     annotated with DW_AT_abstract_origin.  */
+	  parm_die = NULL;
 	}
 
       if (parm_die && parm_die->die_parent == NULL)
@@ -26647,16 +26646,12 @@ dwarf2out_late_global_decl (tree decl)
     {
       dw_die_ref die = lookup_decl_die (decl);
 
-      /* We may have to generate early debug late for LTO in case debug
+      /* We may have to generate full debug late for LTO in case debug
          was not enabled at compile-time or the target doesn't support
 	 the LTO early debug scheme.  */
       if (! die && in_lto_p)
-	{
-	  dwarf2out_decl (decl);
-	  die = lookup_decl_die (decl);
-	}
-
-      if (die)
+	dwarf2out_decl (decl);
+      else if (die)
 	{
 	  /* We get called via the symtab code invoking late_global_decl
 	     for symbols that are optimized out.
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index f0e43b5fda2..9feaea9fde5 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -4935,10 +4935,9 @@ range_check_type (tree etype)
   /* First make sure that arithmetics in this type is valid, then make sure
      that it wraps around.  */
   if (TREE_CODE (etype) == ENUMERAL_TYPE || TREE_CODE (etype) == BOOLEAN_TYPE)
-    etype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype),
-					    TYPE_UNSIGNED (etype));
+    etype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype), 1);
 
-  if (TREE_CODE (etype) == INTEGER_TYPE && !TYPE_OVERFLOW_WRAPS (etype))
+  if (TREE_CODE (etype) == INTEGER_TYPE && !TYPE_UNSIGNED (etype))
     {
       tree utype, minv, maxv;
 
@@ -4956,6 +4955,8 @@ range_check_type (tree etype)
       else
 	return NULL_TREE;
     }
+  else if (POINTER_TYPE_P (etype))
+    etype = unsigned_type_for (etype);
   return etype;
 }
 
@@ -5046,9 +5047,6 @@ build_range_check (location_t loc, tree type, tree exp, int in_p,
   if (etype == NULL_TREE)
     return NULL_TREE;
 
-  if (POINTER_TYPE_P (etype))
-    etype = unsigned_type_for (etype);
-
   high = fold_convert_loc (loc, etype, high);
   low = fold_convert_loc (loc, etype, low);
   exp = fold_convert_loc (loc, etype, exp);
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index e3073787ea9..42430e46ef6 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,403 @@
+2019-11-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/92113
+	* trans-decl.c (gfc_get_symbol_decl): If __def_init actually
+	contains a value, put it into  the read-only section.
+
+2019-11-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/92321
+	* frontend-passes.c (call_external_blas): Commit symbol for
+	external BLAS routine.
+
+2019-11-08  Tobias Burnus  <tobias@codesourcery.com
+
+	Backport from mainline
+	2019-11-08  Tobias Burnus  <tobias@codesourcery.com
+
+	PR fortran/91253
+	* scanner.c (skip_fixed_comments): Move comment
+	lines to next if block.
+	(gfc_next_char_literal): Fix continue_line setting.
+	(get_file): Remove bogus ATTRIBUTE_UNUSED.
+
+2019-11-05  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92208
+	Backport from mainline
+	2019-10-31  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92277
+	* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Fix DECL_ARTIFICIAL
+	checking.
+
+2019-11-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-10-30  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92208
+	* trans-array.c (gfc_conv_array_parameter): Only copy
+	string-length backend_decl if expression is not a function.
+
+2019-11-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-10-31  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/92284.
+	* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Free CFI descriptor
+	at the end; partial revised revert of Rev. 277502.
+
+2019-10-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91926
+	* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Correct the
+	assignment of the attribute field to account correctly for an
+	assumed shape dummy. Assign separately to the gfc and cfi
+	descriptors since the atribute can be different. Add branch to
+	correctly handle missing optional dummies.
+
+2019-10-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-10-28  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/91863
+	* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Don't free data
+	memory as that's done on the Fortran side.
+	(gfc_conv_procedure_call): Handle void* pointers from
+	gfc_conv_gfc_desc_to_cfi_desc.
+
+2019-10-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/86248
+	* resolve.c (flag_fn_result_spec): Correct a typo before the
+	function declaration.
+	* trans-decl.c (gfc_sym_identifier): Boost the length of 'name'
+	to allow for all variants. Simplify the code by using a pointer
+	to the symbol's proc_name and taking the return out of each of
+	the conditional branches. Allow symbols with fn_result_spec set
+	that do not come from a procedure namespace and have a module
+	name to go through the non-fn_result_spec branch.
+
+2019-10-22  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/92174
+	* decl.c (attr_decl1): Move check for F2018:C822 from here ...
+	* array.c (gfc_set_array_spec): ... to here.
+
+2019-10-18  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/69455
+	* trans-decl.c (generate_local_decl): Avoid misconstructed
+	intrinsic modules in a BLOCK construct.
+
+2019-10-18  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backport from mainline
+	2019-10-18  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/91586
+	* class.c (gfc_find_derived_vtab): Return NULL
+	instead of deref'ing NULL pointer.
+
+2019-10-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/83113
+	PR fortran/89943
+	decl.c (gfc_match_function_decl): Ignore duplicate BIND(C) for function
+	declaration in submodule.  Implement at check for F2018 C1550.
+	(gfc_match_entry): Use temporary for locus, which allows removal of
+	one gfc_error_now().
+	(gfc_match_subroutine): Ignore duplicate BIND(C) for subroutine
+	declaration in submodule.  Implement at check for F2018 C1550.
+
+2019-10-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91715
+	* decl.c (gfc_match_prefix): If matching a type-spec returns an error,
+	it's an error so re-act correctly.
+
+2019-10-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91649
+	check.c (gfc_check_findloc): Additional checking for valid arguments
+
+2019-10-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91801
+	* simplify.c (gfc_simplify_reshape): Convert a gcc_assert into a
+	gfc_error as a user can easily hit the condition.
+
+2019-10-07  Thomas Koenig <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84487
+	* trans-decl.c (gfc_get_symbol_decl): For __def_init, set
+	DECL_ARTIFICAL and do not set TREE_READONLY.
+
+2019-10-05  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/47054
+	* decl.c (variable_decl): Do not search parent namespace for symbol.
+
+2019-10-04  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91942
+	* io.c (match_vtag): Check for non-NULL result->symtree.
+	(match_out_tag): Check for invalid constant due to inquiry parameter.
+	(match_filepos): Instead of a syntax error, go to cleanup to get better
+	error messages.
+
+2019-10-04  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91785
+	* primary.c (gfc_match_varspec): Ensure an inquiry parameter has
+	it locus set.
+
+2019-10-01  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91864
+	* gcc/fortran/io.c (match_io_element): An inquiry parameter cannot be
+	read into.
+	* gcc/fortran/match.c (gfc_match_allocate): An inquiry parameter
+	can be neither an allocate-object nor stat variable.
+	(gfc_match_deallocate): An inquiry parameter cannot be deallocated.
+
+2019-10-01  Steven G. Kargl  <kargl@gcc.ngu.org>
+
+	Backport of r276254+276265
+	PR fortran/91802
+	* decl.c (attr_decl1): Check if rank+corank > 15.
+
+2019-10-01  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91714
+	* decl.c (gfc_match_decl_type_spec):  Issue errors for a few
+	mangled types.
+
+2019-10-01  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91641
+	* check.c (gfc_check_is_contiguous): null() cannot be an actual
+	argument to is_contiguous().
+
+2019-09-21  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/91588
+	* expr.c (check_inquiry): Remove extended component refs by
+	using symbol pointers. If a function argument is an associate
+	variable with a constant target, copy the target expression in
+	place of the argument expression. Check that the charlen is not
+	NULL before using the string length.
+
+2019-09-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91727
+	* resolve.c (conformable_arrays):  If array-spec is NULL, then
+	allocate-object is a scalar.  a conformability check only occurs
+	for an array source-expr.
+
+2019-09-18  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91550
+	* frontend-passes.c (do_subscript): If step equals
+	zero, a previuos error has been reported; do nothing
+	in this case.
+	* resolve.c (gfc_resolve_iterator): Move error checking
+	after type conversion.
+
+2019-09-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91557
+	* trans-decl.c (generate_local_decl): Do not warn if the symbol
+	is artificial.
+	* trans-types.c (get_formal_from_actual_arglist): Set artificial
+	attribute on dummy arguments.
+
+2019-09-14  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91553
+	* simplify.c (gfc_convert_constant):  During conversion check if the
+	constant is enclosed in parenthesis, and simplify expression.
+
+2019-09-14  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91566
+	* simplify.c (gfc_simplify_merge): Need to simplify expression
+	after insertation of parenthesis.
+
+2019-09-14  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91642
+	* io.c (gfc_match_inquire): null() cannot be in an iolength inquire
+	list.
+
+2019-09-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/91589
+	* primary.c (gfc_match_varspec): Return MATCH_NO on an apparent
+	component ref, when the primary type is intrinsic.
+
+2019-09-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from mainline
+	PR fortran/91496
+	* gfortran.h: Extend struct gfc_iterator for loop annotations.
+	* array.c (gfc_copy_iterator): Copy loop annotations by IVDEP,
+	VECTOR, and NOVECTOR pragmas.
+	* decl.c (gfc_match_gcc_ivdep, gfc_match_gcc_vector)
+	(gfc_match_gcc_novector): New matcher functions handling IVDEP,
+	VECTOR, and NOVECTOR pragmas.
+	* match.h: Declare prototypes of matcher functions handling IVDEP,
+	VECTOR, and NOVECTOR pragmas.
+	* parse.c (decode_gcc_attribute, parse_do_block)
+	(parse_executable): Decode IVDEP, VECTOR, and NOVECTOR pragmas;
+	emit warning for unrecognized pragmas instead of error.
+	* trans-stmt.c (gfc_trans_simple_do, gfc_trans_do): Add code to
+	emit annotations for IVDEP, VECTOR, and NOVECTOR pragmas.
+	* gfortran.texi: Document IVDEP, VECTOR, and NOVECTOR pragmas.
+
+	PR fortran/91496
+	* parse.c (parse_executable): Improve error messages for
+	improperly placed pragmas not preceeding a loop.
+
+2019-09-05  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91660
+	* decl.c (gfc_match_decl_type_spec): Improve and restore error
+	message for malformed types-spec.
+
+2019-09-02  Steven G. Kargl  <kargl@gc.gnu.org>
+
+	PR fortran/91552
+	* array.c (walk_array_constructor): New function.
+	(gfc_match_array_constructor): Use it.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91587
+	* io.c (match_filepos): MATCH_ERROR should branch to a syntax error.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91565
+	* simplify.c (gfc_simplify_reshape): Add additional checks of the
+	ORDER dummy argument.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91564
+	* check.c (gfc_check_kill_sub): Additional checks on status dummy
+	argument.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91551
+	* intrinsic.c (sort_actual): ALLOCATED has one argument. Check for
+	no argument case.
+
+2019-08-30  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91485
+	module.c (gfc_match_use): User defined operator cannot conflict with
+	a rename symbol.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91471
+	* primary.c (gfc_variable_attr): Remove a gfc_internal_error(),
+	which cannot be reached by conforming Fortran code, but seems to
+	be reachable from nonconforming Fortran code.  Treat the AR_UNKNOWN
+	case as a no-op.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78739
+	* match.c (gfc_match_st_function):  When matching a statement function,
+	need to check if the statement function name shadows the function
+	name.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78719
+	* decl.c (get_proc_name): Check for a CLASS entity when trying to
+	add attributes to an entity that already has an explicit interface.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82992
+	* module.c (gfc_match_use):  When renaming a module entity, search
+	current namespace for conflicting symbol.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87991
+	* resolve.c (check_data_variable): data-stmt-object with pointer
+	attribute requires a data-stmt-value with the target attribute.
+
+2013-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90563
+	* frontend-passes.c (insert_index): Suppress errors while
+	simplifying the resulting expression.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88072
+	* misc.c (gfc_typename): Do not point to something that ought not to
+	be pointed at.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90561
+	* trans.h (gfc_evaluate_now_function_scope): New function.
+	* trans.c (gfc_evaluate_now_function_scope): New function.
+	* trans-expr.c (gfc_trans_assignment): Use it.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/89647
+	resolve.c (resolve_typebound_procedure): Allow host associated
+	procedure to be a binding target.  While here, wrap long line.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87993
+	* expr.c (gfc_simplify_expr): Simplifcation of an array with a kind
+	type inquiry suffix yields a constant expression.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91424
+	* frontend-passes.c (do_subscript): Do not warn for an
+	expression a second time.  Do not warn about a zero-trip loop.
+	(doloop_warn): Also look at contained namespaces.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91359
+	* trans-decl.c (gfc_generate_return): Ensure something is returned
+	from a function.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/42546
+	* check.c(gfc_check_allocated): Add comment pointing to ...
+ 	* intrinsic.c(sort_actual): ... the checking done here.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/gcc/fortran/array.c b/gcc/fortran/array.c
index 0aee220e68d..6d20cbb9d36 100644
--- a/gcc/fortran/array.c
+++ b/gcc/fortran/array.c
@@ -843,6 +843,10 @@ gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)
 
       sym->as->cotype = as->cotype;
       sym->as->corank = as->corank;
+      /* Check F2018:C822.  */
+      if (sym->as->rank + sym->as->corank > GFC_MAX_DIMENSIONS)
+	goto too_many;
+
       for (i = 0; i < as->corank; i++)
 	{
 	  sym->as->lower[sym->as->rank + i] = as->lower[i];
@@ -861,6 +865,10 @@ gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)
       sym->as->cray_pointee = as->cray_pointee;
       sym->as->cp_was_assumed = as->cp_was_assumed;
 
+      /* Check F2018:C822.  */
+      if (sym->as->rank + sym->as->corank > GFC_MAX_DIMENSIONS)
+	goto too_many;
+
       for (i = 0; i < sym->as->corank; i++)
 	{
 	  sym->as->lower[as->rank + i] = sym->as->lower[i];
@@ -875,6 +883,12 @@ gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)
 
   free (as);
   return true;
+
+too_many:
+
+  gfc_error ("rank + corank of %qs exceeds %d at %C", sym->name,
+	     GFC_MAX_DIMENSIONS);
+  return false;
 }
 
 
@@ -1124,6 +1138,31 @@ match_array_cons_element (gfc_constructor_base *result)
 }
 
 
+/* Convert components of an array constructor to the type in ts.  */
+
+static match
+walk_array_constructor (gfc_typespec *ts, gfc_constructor_base head)
+{
+  gfc_constructor *c;
+  gfc_expr *e;
+  match m;
+
+  for (c = gfc_constructor_first (head); c; c = gfc_constructor_next (c))
+    {
+      e = c->expr;
+      if (e->expr_type == EXPR_ARRAY && e->ts.type == BT_UNKNOWN
+	  && !e->ref && e->value.constructor)
+	{
+	  m = walk_array_constructor (ts, e->value.constructor);
+	  if (m == MATCH_ERROR)
+	    return m;
+	}
+      else if (!gfc_convert_type (e, ts, 1) && e->ts.type != BT_UNKNOWN)
+	return MATCH_ERROR;
+  }
+  return MATCH_YES;
+}
+
 /* Match an array constructor.  */
 
 match
@@ -1253,14 +1292,13 @@ done:
 	    }
 	}
 
-      /* Walk the constructor and ensure type conversion for numeric types.  */
+      /* Walk the constructor, and if possible, do type conversion for
+	 numeric types.  */
       if (gfc_numeric_ts (&ts))
 	{
-	  c = gfc_constructor_first (head);
-	  for (; c; c = gfc_constructor_next (c))
-	    if (!gfc_convert_type (c->expr, &ts, 1)
-		&& c->expr->ts.type != BT_UNKNOWN)
-	      return MATCH_ERROR;
+	  m = walk_array_constructor (&ts, head);
+	  if (m == MATCH_ERROR)
+	    return m;
 	}
     }
   else
@@ -2175,6 +2213,9 @@ gfc_copy_iterator (gfc_iterator *src)
   dest->end = gfc_copy_expr (src->end);
   dest->step = gfc_copy_expr (src->step);
   dest->unroll = src->unroll;
+  dest->ivdep = src->ivdep;
+  dest->vector = src->vector;
+  dest->novector = src->novector;
 
   return dest;
 }
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index a04f0d66655..4ef354f0a6e 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -924,6 +924,10 @@ gfc_check_all_any (gfc_expr *mask, gfc_expr *dim)
 }
 
 
+/* Limited checking for ALLOCATED intrinsic.  Additional checking
+   is performed in intrinsic.c(sort_actual), because ALLOCATED
+   has two mutually exclusive non-optional arguments.  */
+
 bool
 gfc_check_allocated (gfc_expr *array)
 {
@@ -2781,6 +2785,22 @@ gfc_check_kill_sub (gfc_expr *pid, gfc_expr *sig, gfc_expr *status)
 
       if (!scalar_check (status, 2))
 	return false;
+
+      if (status->expr_type != EXPR_VARIABLE)
+	{
+	  gfc_error ("STATUS at %L shall be an INTENT(OUT) variable",
+		     &status->where);
+	  return false;
+	}
+
+      if (status->expr_type == EXPR_VARIABLE
+	  && status->symtree && status->symtree->n.sym
+	  && status->symtree->n.sym->attr.intent == INTENT_IN)
+	{
+	  gfc_error ("%qs at %L shall be an INTENT(OUT) variable",
+		     status->symtree->name, &status->where);
+	  return false;
+	}
     }
 
   return true;
@@ -3343,26 +3363,27 @@ bool
 gfc_check_findloc (gfc_actual_arglist *ap)
 {
   gfc_expr *a, *v, *m, *d, *k, *b;
+  bool a1, v1;
 
   a = ap->expr;
   if (!intrinsic_type_check (a, 0) || !array_check (a, 0))
     return false;
 
   v = ap->next->expr;
-  if (!scalar_check (v,1))
+  if (!intrinsic_type_check (v, 1) || !scalar_check (v,1))
     return false;
 
-  /* Check if the type is compatible.  */
+  /* Check if the type are both logical.  */
+  a1 = a->ts.type == BT_LOGICAL;
+  v1 = v->ts.type == BT_LOGICAL;
+  if ((a1 && !v1) || (!a1 && v1))
+    goto incompat;
 
-  if ((a->ts.type == BT_LOGICAL && v->ts.type != BT_LOGICAL)
-      || (a->ts.type != BT_LOGICAL && v->ts.type == BT_LOGICAL))
-    {
-      gfc_error ("Argument %qs of %qs intrinsic at %L must be in type "
-		 "conformance to argument %qs at %L",
-		 gfc_current_intrinsic_arg[0]->name,
-		 gfc_current_intrinsic, &a->where,
-		 gfc_current_intrinsic_arg[1]->name, &v->where);
-    }
+  /* Check if the type are both character.  */
+  a1 = a->ts.type == BT_CHARACTER;
+  v1 = v->ts.type == BT_CHARACTER;
+  if ((a1 && !v1) || (!a1 && v1))
+    goto incompat;
 	 
   d = ap->next->next->expr;
   m = ap->next->next->next->expr;
@@ -3410,6 +3431,14 @@ gfc_check_findloc (gfc_actual_arglist *ap)
     return false;
 
   return true;
+
+incompat:
+  gfc_error ("Argument %qs of %qs intrinsic at %L must be in type "
+	     "conformance to argument %qs at %L",
+	     gfc_current_intrinsic_arg[0]->name,
+	     gfc_current_intrinsic, &a->where,
+	     gfc_current_intrinsic_arg[1]->name, &v->where);
+  return false;
 }
 
 
@@ -6549,6 +6578,14 @@ gfc_check_ttynam_sub (gfc_expr *unit, gfc_expr *name)
 bool
 gfc_check_is_contiguous (gfc_expr *array)
 {
+  if (array->expr_type == EXPR_NULL
+      && array->symtree->n.sym->attr.pointer == 1)
+    {
+      gfc_error ("Actual argument at %L of %qs intrinsic shall be an "
+		 "associated pointer", &array->where, gfc_current_intrinsic);
+      return false;
+    }
+
   if (!array_check (array, 0))
     return false;
 
@@ -6556,7 +6593,6 @@ gfc_check_is_contiguous (gfc_expr *array)
 }
 
 
-
 bool
 gfc_check_isatty (gfc_expr *unit)
 {
diff --git a/gcc/fortran/class.c b/gcc/fortran/class.c
index 8a1f43f116c..9117121e5fe 100644
--- a/gcc/fortran/class.c
+++ b/gcc/fortran/class.c
@@ -2241,6 +2241,9 @@ gfc_find_derived_vtab (gfc_symbol *derived)
   if (!derived->attr.unlimited_polymorphic && derived->attr.is_class)
     derived = gfc_get_derived_super_type (derived);
 
+  if (!derived)
+    return NULL;
+
   /* Find the gsymbol for the module of use associated derived types.  */
   if ((derived->attr.use_assoc || derived->attr.used_in_submodule)
        && !derived->attr.vtype && !derived->attr.is_class)
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index cf09420cfbe..52a98cd44ed 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -99,6 +99,11 @@ bool gfc_matching_function;
 /* Set upon parsing a !GCC$ unroll n directive for use in the next loop.  */
 int directive_unroll = -1;
 
+/* Set upon parsing supported !GCC$ pragmas for use in the next loop.  */
+bool directive_ivdep = false;
+bool directive_vector = false;
+bool directive_novector = false;
+
 /* Map of middle-end built-ins that should be vectorized.  */
 hash_map<nofree_string_hash, int> *gfc_vectorized_builtins;
 
@@ -1335,9 +1340,9 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)
 	}
 
       /* Trap declarations of attributes in encompassing scope.  The
-	 signature for this is that ts.kind is set.  Legitimate
-	 references only set ts.type.  */
-      if (sym->ts.kind != 0
+	 signature for this is that ts.kind is nonzero for no-CLASS
+	 entity.  For a CLASS entity, ts.kind is zero.  */
+      if ((sym->ts.kind != 0 || sym->ts.type == BT_CLASS)
 	  && !sym->attr.implicit_type
 	  && sym->attr.proc == 0
 	  && gfc_current_ns->parent != NULL
@@ -2644,7 +2649,7 @@ variable_decl (int elem)
       then we want to set the type & bail out.  */
   if (flag_cray_pointer && !gfc_comp_struct (gfc_current_state ()))
     {
-      gfc_find_symbol (name, gfc_current_ns, 1, &sym);
+      gfc_find_symbol (name, gfc_current_ns, 0, &sym);
       if (sym != NULL && sym->attr.cray_pointee)
 	{
 	  m = MATCH_YES;
@@ -3991,7 +3996,6 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
       return MATCH_YES;
     }
 
-
   m = gfc_match (" type (");
   matched_type = (m == MATCH_YES);
   if (matched_type)
@@ -4039,7 +4043,10 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 	m = MATCH_YES;
 
       if (matched_type && m == MATCH_YES && gfc_match_char (')') != MATCH_YES)
-	m = MATCH_ERROR;
+	{
+	  gfc_error ("Malformed type-spec at %C");
+	  return MATCH_ERROR;
+	}
 
       return m;
     }
@@ -4062,8 +4069,12 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 	  && !gfc_notify_std (GFC_STD_F2008, "TYPE with "
 			      "intrinsic-type-spec at %C"))
 	return MATCH_ERROR;
+
       if (matched_type && gfc_match_char (')') != MATCH_YES)
-	return MATCH_ERROR;
+	{
+	  gfc_error ("Malformed type-spec at %C");
+	  return MATCH_ERROR;
+	}
 
       ts->type = BT_REAL;
       ts->kind = gfc_default_double_kind;
@@ -4093,7 +4104,10 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 	return MATCH_ERROR;
 
       if (matched_type && gfc_match_char (')') != MATCH_YES)
-	return MATCH_ERROR;
+	{
+	  gfc_error ("Malformed type-spec at %C");
+	  return MATCH_ERROR;
+	}
 
       ts->type = BT_COMPLEX;
       ts->kind = gfc_default_double_kind;
@@ -4114,7 +4128,13 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
       if (m == MATCH_ERROR)
 	return m;
 
-    m = gfc_match_char (')');
+      gfc_gobble_whitespace ();
+      if (gfc_peek_ascii_char () != ')')
+	{
+	  gfc_error ("Malformed type-spec at %C");
+	  return MATCH_ERROR;
+	}
+      m = gfc_match_char (')'); /* Burn closing ')'.  */
     }
 
   if (m != MATCH_YES)
@@ -4397,6 +4417,7 @@ get_kind:
 	      gfc_next_ascii_char ();
 	      return MATCH_YES;
 	    }
+	  gfc_error ("Malformed type-spec at %C");
 	  return MATCH_NO;
 	}
     }
@@ -4410,7 +4431,10 @@ get_kind:
     }
 
   if (matched_type && gfc_match_char (')') != MATCH_YES)
-    return MATCH_ERROR;
+    {
+      gfc_error ("Malformed type-spec at %C");
+      return MATCH_ERROR;
+    }
 
   /* Defer association of the KIND expression of function results
      until after USE and IMPORT statements.  */
@@ -6145,13 +6169,17 @@ gfc_match_prefix (gfc_typespec *ts)
 	  found_prefix = true;
 	}
 
-      if (!seen_type && ts != NULL
-	  && gfc_match_decl_type_spec (ts, 0) == MATCH_YES
-	  && gfc_match_space () == MATCH_YES)
+      if (!seen_type && ts != NULL)
 	{
-
-	  seen_type = true;
-	  found_prefix = true;
+	  match m;
+	  m = gfc_match_decl_type_spec (ts, 0);
+	  if (m == MATCH_ERROR)
+	    goto error;
+	  if (m == MATCH_YES && gfc_match_space () == MATCH_YES)
+	    {
+	      seen_type = true;
+	      found_prefix = true;
+	    }
 	}
 
       if (gfc_match ("elemental% ") == MATCH_YES)
@@ -7202,13 +7230,16 @@ gfc_match_function_decl (void)
   if (sym->attr.is_bind_c == 1)
     {
       sym->attr.is_bind_c = 0;
-      if (sym->old_symbol != NULL)
-        gfc_error_now ("BIND(C) attribute at %L can only be used for "
-                       "variables or common blocks",
-                       &(sym->old_symbol->declared_at));
-      else
-        gfc_error_now ("BIND(C) attribute at %L can only be used for "
-                       "variables or common blocks", &gfc_current_locus);
+
+      if (gfc_state_stack->previous
+	  && gfc_state_stack->previous->state != COMP_SUBMODULE)
+	{
+	  locus loc;
+	  loc = sym->old_symbol != NULL
+	    ? sym->old_symbol->declared_at : gfc_current_locus;
+	  gfc_error_now ("BIND(C) attribute at %L can only be used for "
+			 "variables or common blocks", &loc);
+	}
     }
 
   if (found_match != MATCH_YES)
@@ -7222,6 +7253,24 @@ gfc_match_function_decl (void)
 	found_match = suffix_match;
     }
 
+  /* F2018 C1550 (R1526) If MODULE appears in the prefix of a module
+     subprogram and a binding label is specified, it shall be the
+     same as the binding label specified in the corresponding module
+     procedure interface body.  */
+    if (sym->attr.is_bind_c && sym->attr.module_procedure && sym->old_symbol
+  	&& strcmp (sym->name, sym->old_symbol->name) == 0
+	&& strcmp (sym->binding_label, sym->old_symbol->binding_label) != 0)
+      {
+	  const char *null = "NULL", *s1, *s2;
+	  s1 = sym->binding_label;
+	  if (!s1) s1 = null;
+	  s2 = sym->old_symbol->binding_label;
+	  if (!s2) s2 = null;
+          gfc_error ("Mismatch in BIND(C) names (%qs/%qs) at %C", s1, s2);
+	  sym->refs++;	/* Needed to avoid an ICE in gfc_release_symbol */
+	  return MATCH_ERROR;
+      }
+
   if(found_match != MATCH_YES)
     m = MATCH_ERROR;
   else
@@ -7460,15 +7509,15 @@ gfc_match_entry (void)
      not allowed for procedures.  */
   if (entry->attr.is_bind_c == 1)
     {
+      locus loc;
+
       entry->attr.is_bind_c = 0;
-      if (entry->old_symbol != NULL)
-        gfc_error_now ("BIND(C) attribute at %L can only be used for "
-                       "variables or common blocks",
-                       &(entry->old_symbol->declared_at));
-      else
-        gfc_error_now ("BIND(C) attribute at %L can only be used for "
-                       "variables or common blocks", &gfc_current_locus);
-    }
+
+      loc = entry->old_symbol != NULL
+	? entry->old_symbol->declared_at : gfc_current_locus; 
+      gfc_error_now ("BIND(C) attribute at %L can only be used for "
+		     "variables or common blocks", &loc);
+     }
 
   /* Check what next non-whitespace character is so we can tell if there
      is the required parens if we have a BIND(C).  */
@@ -7668,13 +7717,16 @@ gfc_match_subroutine (void)
   if (sym->attr.is_bind_c == 1)
     {
       sym->attr.is_bind_c = 0;
-      if (sym->old_symbol != NULL)
-        gfc_error_now ("BIND(C) attribute at %L can only be used for "
-                       "variables or common blocks",
-                       &(sym->old_symbol->declared_at));
-      else
-        gfc_error_now ("BIND(C) attribute at %L can only be used for "
-                       "variables or common blocks", &gfc_current_locus);
+
+      if (gfc_state_stack->previous
+	  && gfc_state_stack->previous->state != COMP_SUBMODULE)
+	{
+	  locus loc;
+	  loc = sym->old_symbol != NULL
+	    ? sym->old_symbol->declared_at : gfc_current_locus;
+	  gfc_error_now ("BIND(C) attribute at %L can only be used for "
+			 "variables or common blocks", &loc);
+	}
     }
 
   /* C binding names are not allowed for internal procedures.  */
@@ -7716,6 +7768,24 @@ gfc_match_subroutine (void)
           return MATCH_ERROR;
         }
 
+      /* F2018 C1550 (R1526) If MODULE appears in the prefix of a module
+	 subprogram and a binding label is specified, it shall be the
+	 same as the binding label specified in the corresponding module
+	 procedure interface body.  */
+      if (sym->attr.module_procedure && sym->old_symbol
+  	  && strcmp (sym->name, sym->old_symbol->name) == 0
+	  && strcmp (sym->binding_label, sym->old_symbol->binding_label) != 0)
+	{
+	  const char *null = "NULL", *s1, *s2;
+	  s1 = sym->binding_label;
+	  if (!s1) s1 = null;
+	  s2 = sym->old_symbol->binding_label;
+	  if (!s2) s2 = null;
+          gfc_error ("Mismatch in BIND(C) names (%qs/%qs) at %C", s1, s2);
+	  sym->refs++;	/* Needed to avoid an ICE in gfc_release_symbol */
+	  return MATCH_ERROR;
+	}
+
       /* Scan the dummy arguments for an alternate return.  */
       for (arg = sym->formal; arg; arg = arg->next)
 	if (!arg->sym)
@@ -10161,6 +10231,20 @@ gfc_match_derived_decl (void)
       return MATCH_ERROR;
     }
 
+  /*  In free source form, need to check for TYPE XXX as oppose to TYPEXXX.
+      But, we need to simply return for TYPE(.  */ 
+  if (m == MATCH_NO && gfc_current_form == FORM_FREE)
+    {
+      char c = gfc_peek_ascii_char ();
+      if (c == '(')
+	return m;
+      if (!gfc_is_whitespace (c))
+	{
+	  gfc_error ("Mangled derived type definition at %C");
+	  return MATCH_NO;
+	}
+    }
+
   m = gfc_match (" %n ", name);
   if (m != MATCH_YES)
     return m;
@@ -10168,7 +10252,7 @@ gfc_match_derived_decl (void)
   /* Make sure that we don't identify TYPE IS (...) as a parameterized
      derived type named 'is'.
      TODO Expand the check, when 'name' = "is" by matching " (tname) "
-     and checking if this is a(n intrinsic) typename. his picks up
+     and checking if this is a(n intrinsic) typename.  This picks up
      misplaced TYPE IS statements such as in select_type_1.f03.  */
   if (gfc_peek_ascii_char () == '(')
     {
@@ -11472,3 +11556,53 @@ gfc_match_gcc_builtin (void)
 
   return MATCH_YES;
 }
+
+/* Match an !GCC$ IVDEP statement.
+   When we come here, we have already matched the !GCC$ IVDEP string.  */
+
+match
+gfc_match_gcc_ivdep (void)
+{
+  if (gfc_match_eos () == MATCH_YES)
+    {
+      directive_ivdep = true;
+      return MATCH_YES;
+    }
+
+  gfc_error ("Syntax error in !GCC$ IVDEP directive at %C");
+  return MATCH_ERROR;
+}
+
+/* Match an !GCC$ VECTOR statement.
+   When we come here, we have already matched the !GCC$ VECTOR string.  */
+
+match
+gfc_match_gcc_vector (void)
+{
+  if (gfc_match_eos () == MATCH_YES)
+    {
+      directive_vector = true;
+      directive_novector = false;
+      return MATCH_YES;
+    }
+
+  gfc_error ("Syntax error in !GCC$ VECTOR directive at %C");
+  return MATCH_ERROR;
+}
+
+/* Match an !GCC$ NOVECTOR statement.
+   When we come here, we have already matched the !GCC$ NOVECTOR string.  */
+
+match
+gfc_match_gcc_novector (void)
+{
+  if (gfc_match_eos () == MATCH_YES)
+    {
+      directive_novector = true;
+      directive_vector = false;
+      return MATCH_YES;
+    }
+
+  gfc_error ("Syntax error in !GCC$ NOVECTOR directive at %C");
+  return MATCH_ERROR;
+}
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index 2aeea92b8fb..cad0dd36a67 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -2220,6 +2220,11 @@ gfc_simplify_expr (gfc_expr *p, int type)
       if (!simplify_ref_chain (p->ref, type, &p))
 	return false;
 
+      /* If the following conditions hold, we found something like kind type
+	 inquiry of the form a(2)%kind while simplify the ref chain.  */
+      if (p->expr_type == EXPR_CONSTANT && !p->ref && !p->rank && !p->shape)
+	return true;
+
       if (!simplify_constructor (p->value.constructor, type))
 	return false;
 
@@ -2598,6 +2603,8 @@ check_inquiry (gfc_expr *e, int not_restricted)
 
   int i = 0;
   gfc_actual_arglist *ap;
+  gfc_symbol *sym;
+  gfc_symbol *asym;
 
   if (!e->value.function.isym
       || !e->value.function.isym->inquiry)
@@ -2607,20 +2614,22 @@ check_inquiry (gfc_expr *e, int not_restricted)
   if (e->symtree == NULL)
     return MATCH_NO;
 
-  if (e->symtree->n.sym->from_intmod)
+  sym = e->symtree->n.sym;
+
+  if (sym->from_intmod)
     {
-      if (e->symtree->n.sym->from_intmod == INTMOD_ISO_FORTRAN_ENV
-	  && e->symtree->n.sym->intmod_sym_id != ISOFORTRAN_COMPILER_OPTIONS
-	  && e->symtree->n.sym->intmod_sym_id != ISOFORTRAN_COMPILER_VERSION)
+      if (sym->from_intmod == INTMOD_ISO_FORTRAN_ENV
+	  && sym->intmod_sym_id != ISOFORTRAN_COMPILER_OPTIONS
+	  && sym->intmod_sym_id != ISOFORTRAN_COMPILER_VERSION)
 	return MATCH_NO;
 
-      if (e->symtree->n.sym->from_intmod == INTMOD_ISO_C_BINDING
-	  && e->symtree->n.sym->intmod_sym_id != ISOCBINDING_C_SIZEOF)
+      if (sym->from_intmod == INTMOD_ISO_C_BINDING
+	  && sym->intmod_sym_id != ISOCBINDING_C_SIZEOF)
 	return MATCH_NO;
     }
   else
     {
-      name = e->symtree->n.sym->name;
+      name = sym->name;
 
       functions = inquiry_func_gnu;
       if (gfc_option.warn_std & GFC_STD_F2003)
@@ -2645,41 +2654,48 @@ check_inquiry (gfc_expr *e, int not_restricted)
       if (!ap->expr)
 	continue;
 
+      asym = ap->expr->symtree ? ap->expr->symtree->n.sym : NULL;
+
       if (ap->expr->ts.type == BT_UNKNOWN)
 	{
-	  if (ap->expr->symtree->n.sym->ts.type == BT_UNKNOWN
-	      && !gfc_set_default_type (ap->expr->symtree->n.sym, 0, gfc_current_ns))
+	  if (asym && asym->ts.type == BT_UNKNOWN
+	      && !gfc_set_default_type (asym, 0, gfc_current_ns))
 	    return MATCH_NO;
 
-	  ap->expr->ts = ap->expr->symtree->n.sym->ts;
+	  ap->expr->ts = asym->ts;
 	}
 
-	/* Assumed character length will not reduce to a constant expression
-	   with LEN, as required by the standard.  */
-	if (i == 5 && not_restricted && ap->expr->symtree
-	    && ap->expr->symtree->n.sym->ts.type == BT_CHARACTER
-	    && (ap->expr->symtree->n.sym->ts.u.cl->length == NULL
-		|| ap->expr->symtree->n.sym->ts.deferred))
-	  {
-	    gfc_error ("Assumed or deferred character length variable %qs "
-			"in constant expression at %L",
-			ap->expr->symtree->n.sym->name,
-			&ap->expr->where);
-	      return MATCH_ERROR;
-	  }
-	else if (not_restricted && !gfc_check_init_expr (ap->expr))
-	  return MATCH_ERROR;
+      if (asym && asym->assoc && asym->assoc->target
+	  && asym->assoc->target->expr_type == EXPR_CONSTANT)
+	{
+	  gfc_free_expr (ap->expr);
+	  ap->expr = gfc_copy_expr (asym->assoc->target);
+	}
 
-	if (not_restricted == 0
-	      && ap->expr->expr_type != EXPR_VARIABLE
-	      && !check_restricted (ap->expr))
+      /* Assumed character length will not reduce to a constant expression
+	 with LEN, as required by the standard.  */
+      if (i == 5 && not_restricted && asym
+	  && asym->ts.type == BT_CHARACTER
+	  && ((asym->ts.u.cl && asym->ts.u.cl->length == NULL)
+	      || asym->ts.deferred))
+	{
+	  gfc_error ("Assumed or deferred character length variable %qs "
+		     "in constant expression at %L",
+		      asym->name, &ap->expr->where);
 	  return MATCH_ERROR;
+	}
+      else if (not_restricted && !gfc_check_init_expr (ap->expr))
+	return MATCH_ERROR;
+
+      if (not_restricted == 0
+	  && ap->expr->expr_type != EXPR_VARIABLE
+	  && !check_restricted (ap->expr))
+	return MATCH_ERROR;
 
-	if (not_restricted == 0
-	    && ap->expr->expr_type == EXPR_VARIABLE
-	    && ap->expr->symtree->n.sym->attr.dummy
-	    && ap->expr->symtree->n.sym->attr.optional)
-	  return MATCH_NO;
+      if (not_restricted == 0
+	  && ap->expr->expr_type == EXPR_VARIABLE
+	  && asym->attr.dummy && asym->attr.optional)
+	return MATCH_NO;
     }
 
   return MATCH_YES;
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
index d4264dafa6f..ec374b684e0 100644
--- a/gcc/fortran/frontend-passes.c
+++ b/gcc/fortran/frontend-passes.c
@@ -2519,7 +2519,12 @@ insert_index (gfc_expr *e, gfc_symbol *sym, mpz_t val, mpz_t ret)
   data.sym = sym;
   mpz_init_set (data.val, val);
   gfc_expr_walker (&n, callback_insert_index, (void *) &data);
+
+  /* Suppress errors here - we could get errors here such as an
+     out of bounds access for arrays, see PR 90563.  */
+  gfc_push_suppress_errors ();
   gfc_simplify_expr (n, 0);
+  gfc_pop_suppress_errors ();
 
   if (n->expr_type == EXPR_CONSTANT)
     {
@@ -2557,6 +2562,12 @@ do_subscript (gfc_expr **e)
   if (in_assoc_list)
     return 0;
 
+  /* We already warned about this.  */
+  if (v->do_not_warn)
+    return 0;
+
+  v->do_not_warn = 1;
+
   for (ref = v->ref; ref; ref = ref->next)
     {
       if (ref->type == REF_ARRAY && ref->u.ar.type == AR_ELEMENT)
@@ -2569,6 +2580,7 @@ do_subscript (gfc_expr **e)
 	      bool have_do_start, have_do_end;
 	      bool error_not_proven;
 	      int warn;
+	      int sgn;
 
 	      dl = lp->c;
 	      if (dl == NULL)
@@ -2597,7 +2609,16 @@ do_subscript (gfc_expr **e)
 		 Do not warn in this case.  */
 
 	      if (dl->ext.iterator->step->expr_type == EXPR_CONSTANT)
-		mpz_init_set (do_step, dl->ext.iterator->step->value.integer);
+		{
+		  sgn = mpz_cmp_ui (dl->ext.iterator->step->value.integer, 0);
+		  /* This can happen, but then the error has been
+		     reported previusly.  */
+		  if (sgn == 0)
+		    continue;
+
+		  mpz_init_set (do_step, dl->ext.iterator->step->value.integer);
+		}
+
 	      else
 		continue;
 
@@ -2609,7 +2630,6 @@ do_subscript (gfc_expr **e)
 	      else
 		have_do_start = false;
 
-
 	      if (dl->ext.iterator->end->expr_type == EXPR_CONSTANT)
 		{
 		  have_do_end = true;
@@ -2621,6 +2641,16 @@ do_subscript (gfc_expr **e)
 	      if (!have_do_start && !have_do_end)
 		return 0;
 
+	      /* No warning inside a zero-trip loop.  */
+	      if (have_do_start && have_do_end)
+		{
+		  int cmp;
+
+		  cmp = mpz_cmp (do_end, do_start);
+		  if ((sgn > 0 && cmp < 0) || (sgn < 0 && cmp > 0))
+		    break;
+		}
+
 	      /* May have to correct the end value if the step does not equal
 		 one.  */
 	      if (have_do_start && have_do_end && mpz_cmp_ui (do_step, 1) != 0)
@@ -2762,6 +2792,12 @@ static void
 doloop_warn (gfc_namespace *ns)
 {
   gfc_code_walker (&ns->code, doloop_code, do_function, NULL);
+
+  for (ns = ns->contained; ns; ns = ns->sibling)
+    {
+      if (ns->code == NULL || ns->code->op != EXEC_BLOCK)
+	doloop_warn (ns);
+    }
 }
 
 /* This selction deals with inlining calls to MATMUL.  */
@@ -4601,6 +4637,7 @@ call_external_blas (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,
   call->symtree->n.sym->attr.procedure = 1;
   call->symtree->n.sym->attr.flavor = FL_PROCEDURE;
   call->resolved_sym = call->symtree->n.sym;
+  gfc_commit_symbol (call->resolved_sym);
 
   /* Argument TRANSA.  */
   next = gfc_get_actual_arglist ();
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index 2bb82980e8e..29b962d889c 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -2407,6 +2407,9 @@ typedef struct
 {
   gfc_expr *var, *start, *end, *step;
   unsigned short unroll;
+  bool ivdep;
+  bool vector;
+  bool novector;
 }
 gfc_iterator;
 
@@ -2783,6 +2786,9 @@ gfc_finalizer;
 bool gfc_in_match_data (void);
 match gfc_match_char_spec (gfc_typespec *);
 extern int directive_unroll;
+extern bool directive_ivdep;
+extern bool directive_vector;
+extern bool directive_novector;
 
 /* SIMD clause enum.  */
 enum gfc_simd_clause
diff --git a/gcc/fortran/gfortran.texi b/gcc/fortran/gfortran.texi
index 6a8337a4bbf..733403a129d 100644
--- a/gcc/fortran/gfortran.texi
+++ b/gcc/fortran/gfortran.texi
@@ -3542,6 +3542,9 @@ as this requires the new array descriptor.
 * ATTRIBUTES directive::
 * UNROLL directive::
 * BUILTIN directive::
+* IVDEP directive::
+* VECTOR directive::
+* NOVECTOR directive::
 @end menu
 
 @node ATTRIBUTES directive
@@ -3653,6 +3656,52 @@ for the built-in that should be vectorized.  Example usage:
 The purpose of the directive is to provide an API among the GCC compiler and
 the GNU C Library which would define vector implementations of math routines.
 
+
+@node IVDEP directive
+@subsection IVDEP directive
+
+The syntax of the directive is
+
+@code{!GCC$ ivdep}
+
+This directive tells the compiler to ignore vector dependencies in the
+following loop.  It must be placed immediately before a @code{DO} loop
+and applies only to the loop that follows.
+
+Sometimes the compiler may not have sufficient information to decide
+whether a particular loop is vectorizable due to potential
+dependencies between iterations.  The purpose of the directive is to
+tell the compiler that vectorization is safe.
+
+This directive is intended for annotation of existing code.  For new
+code it is recommended to consider OpenMP SIMD directives as potential
+alternative.
+
+
+@node VECTOR directive
+@subsection VECTOR directive
+
+The syntax of the directive is
+
+@code{!GCC$ vector}
+
+This directive tells the compiler to vectorize the following loop.  It
+must be placed immediately before a @code{DO} loop and applies only to
+the loop that follows.
+
+
+@node NOVECTOR directive
+@subsection NOVECTOR directive
+
+The syntax of the directive is
+
+@code{!GCC$ novector}
+
+This directive tells the compiler to not vectorize the following loop.
+It must be placed immediately before a @code{DO} loop and applies only
+to the loop that follows.
+
+
 @node Non-Fortran Main Program
 @section Non-Fortran Main Program
 
diff --git a/gcc/fortran/intrinsic.c b/gcc/fortran/intrinsic.c
index c21fbddd5fb..357a35052eb 100644
--- a/gcc/fortran/intrinsic.c
+++ b/gcc/fortran/intrinsic.c
@@ -4180,6 +4180,50 @@ sort_actual (const char *name, gfc_actual_arglist **ap,
   if (f == NULL && a == NULL)	/* No arguments */
     return true;
 
+  /* ALLOCATED has two mutually exclusive keywords, but only one
+     can be present at time and neither is optional. */
+  if (strcmp (name, "allocated") == 0)
+    {
+      if (!a)
+	{
+	  gfc_error ("ALLOCATED intrinsic at %L requires an array or scalar "
+		     "allocatable entity", where);
+	  return false;
+	}
+
+      if (a->name)
+	{
+	  if (strcmp (a->name, "scalar") == 0)
+	    {
+	      if (a->next)
+		goto whoops;
+	      if (a->expr->rank != 0)
+		{
+		  gfc_error ("Scalar entity required at %L", &a->expr->where);
+		  return false;
+		}
+	      return true;
+	    }
+	  else if (strcmp (a->name, "array") == 0)
+	    {
+	      if (a->next)
+		goto whoops;
+	      if (a->expr->rank == 0)
+		{
+		  gfc_error ("Array entity required at %L", &a->expr->where);
+		  return false;
+		}
+	      return true;
+	    }
+	  else
+	    {
+	      gfc_error ("Invalid keyword %qs in %qs intrinsic function at %L",
+			 a->name, name, &a->expr->where);
+	      return false;
+	    }
+	}
+    }
+
   for (;;)
     {		/* Put the nonkeyword arguments in a 1:1 correspondence */
       if (f == NULL)
@@ -4199,6 +4243,7 @@ sort_actual (const char *name, gfc_actual_arglist **ap,
   if (a == NULL)
     goto do_sort;
 
+whoops:
   gfc_error ("Too many arguments in call to %qs at %L", name, where);
   return false;
 
diff --git a/gcc/fortran/io.c b/gcc/fortran/io.c
index 9828897852a..b9a29a0f932 100644
--- a/gcc/fortran/io.c
+++ b/gcc/fortran/io.c
@@ -1441,24 +1441,29 @@ match_vtag (const io_tag *tag, gfc_expr **v)
       return MATCH_ERROR;
     }
 
-  if (result->symtree->n.sym->attr.intent == INTENT_IN)
+  if (result->symtree)
     {
-      gfc_error ("Variable %s cannot be INTENT(IN) at %C", tag->name);
-      gfc_free_expr (result);
-      return MATCH_ERROR;
-    }
+      bool impure;
 
-  bool impure = gfc_impure_variable (result->symtree->n.sym);
-  if (impure && gfc_pure (NULL))
-    {
-      gfc_error ("Variable %s cannot be assigned in PURE procedure at %C",
-		 tag->name);
-      gfc_free_expr (result);
-      return MATCH_ERROR;
-    }
+      if (result->symtree->n.sym->attr.intent == INTENT_IN)
+	{
+	  gfc_error ("Variable %s cannot be INTENT(IN) at %C", tag->name);
+	  gfc_free_expr (result);
+	  return MATCH_ERROR;
+	}
 
-  if (impure)
-    gfc_unset_implicit_pure (NULL);
+      impure = gfc_impure_variable (result->symtree->n.sym);
+      if (impure && gfc_pure (NULL))
+	{
+	  gfc_error ("Variable %s cannot be assigned in PURE procedure at %C",
+		     tag->name);
+	  gfc_free_expr (result);
+	  return MATCH_ERROR;
+	}
+
+      if (impure)
+	gfc_unset_implicit_pure (NULL);
+    }
 
   *v = result;
   return MATCH_YES;
@@ -1474,7 +1479,16 @@ match_out_tag (const io_tag *tag, gfc_expr **result)
 
   m = match_vtag (tag, result);
   if (m == MATCH_YES)
-    gfc_check_do_variable ((*result)->symtree);
+    {
+      if ((*result)->symtree)
+	gfc_check_do_variable ((*result)->symtree);
+
+      if ((*result)->expr_type == EXPR_CONSTANT)
+	{
+	  gfc_error ("Expecting a variable at %L", &(*result)->where);
+	  return MATCH_ERROR;
+	}
+    }
 
   return m;
 }
@@ -2804,7 +2818,7 @@ match_filepos (gfc_statement st, gfc_exec_op op)
 
   m = match_file_element (fp);
   if (m == MATCH_ERROR)
-    goto done;
+    goto cleanup;
   if (m == MATCH_NO)
     {
       m = gfc_match_expr (&fp->unit);
@@ -3608,7 +3622,17 @@ match_io_element (io_kind k, gfc_code **cpp)
     {
       m = gfc_match_variable (&expr, 0);
       if (m == MATCH_NO)
-	gfc_error ("Expected variable in READ statement at %C");
+	{
+	  gfc_error ("Expecting variable in READ statement at %C");
+	  m = MATCH_ERROR;
+	}
+
+      if (m == MATCH_YES && expr->expr_type == EXPR_CONSTANT)
+	{
+	  gfc_error ("Expecting variable or io-implied-do in READ statement "
+		   "at %L", &expr->where);
+	  m = MATCH_ERROR;
+	}
 
       if (m == MATCH_YES
 	  && expr->expr_type == EXPR_VARIABLE
@@ -3618,7 +3642,6 @@ match_io_element (io_kind k, gfc_code **cpp)
 		     &expr->where);
 	  m = MATCH_ERROR;
 	}
-
     }
   else
     {
@@ -4583,6 +4606,17 @@ gfc_match_inquire (void)
       if (m == MATCH_NO)
 	goto syntax;
 
+      for (gfc_code *c = code; c; c = c->next)
+	if (c->expr1 && c->expr1->expr_type == EXPR_FUNCTION
+	    && c->expr1->symtree && c->expr1->symtree->n.sym->attr.function
+	    && !c->expr1->symtree->n.sym->attr.external
+	    && strcmp (c->expr1->symtree->name, "null") == 0)
+	  {
+	    gfc_error ("NULL() near %L cannot appear in INQUIRE statement",
+		       &c->expr1->where);
+	    goto cleanup;
+	  }
+
       new_st.op = EXEC_IOLENGTH;
       new_st.expr1 = inquire->iolength;
       new_st.ext.inquire = inquire;
diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
index 156d7a05f6b..efc0c2d7bc3 100644
--- a/gcc/fortran/match.c
+++ b/gcc/fortran/match.c
@@ -4219,6 +4219,12 @@ gfc_match_allocate (void)
       if (m == MATCH_ERROR)
 	goto cleanup;
 
+      if (tail->expr->expr_type == EXPR_CONSTANT)
+	{
+	  gfc_error ("Unexpected constant at %C");
+	  goto cleanup;
+	}
+
       if (gfc_check_do_variable (tail->expr->symtree))
 	goto cleanup;
 
@@ -4351,6 +4357,12 @@ alloc_opt_list:
 	  tmp = NULL;
 	  saw_stat = true;
 
+	  if (stat->expr_type == EXPR_CONSTANT)
+	    {
+	      gfc_error ("STAT tag at %L cannot be a constant", &stat->where);
+	      goto cleanup;
+	    }
+
 	  if (gfc_check_do_variable (stat->symtree))
 	    goto cleanup;
 
@@ -4627,6 +4639,12 @@ gfc_match_deallocate (void)
       if (m == MATCH_NO)
 	goto syntax;
 
+      if (tail->expr->expr_type == EXPR_CONSTANT)
+	{
+	  gfc_error ("Unexpected constant at %C");
+	  goto cleanup;
+	}
+
       if (gfc_check_do_variable (tail->expr->symtree))
 	goto cleanup;
 
@@ -5698,7 +5716,29 @@ gfc_match_st_function (void)
   gfc_symbol *sym;
   gfc_expr *expr;
   match m;
+  char name[GFC_MAX_SYMBOL_LEN + 1];
+  locus old_locus;
+  bool fcn;
+  gfc_formal_arglist *ptr;
+
+  /* Read the possible statement function name, and then check to see if
+     a symbol is already present in the namespace.  Record if it is a
+     function and whether it has been referenced.  */
+  fcn = false;
+  ptr = NULL;
+  old_locus = gfc_current_locus;
+  m = gfc_match_name (name);
+  if (m == MATCH_YES)
+    {
+      gfc_find_symbol (name, NULL, 1, &sym);
+      if (sym && sym->attr.function && !sym->attr.referenced)
+	{
+	  fcn = true;
+	  ptr = sym->formal;
+	}
+    }
 
+  gfc_current_locus = old_locus;
   m = gfc_match_symbol (&sym, 0);
   if (m != MATCH_YES)
     return m;
@@ -5726,6 +5766,13 @@ gfc_match_st_function (void)
       return MATCH_ERROR;
     }
 
+  if (fcn && ptr != sym->formal)
+    {
+      gfc_error ("Statement function %qs at %L conflicts with function name",
+		 sym->name, &expr->where);
+      return MATCH_ERROR;
+    }
+
   sym->value = expr;
 
   if ((gfc_current_state () == COMP_FUNCTION
diff --git a/gcc/fortran/match.h b/gcc/fortran/match.h
index ac47d992f4a..29854ee9000 100644
--- a/gcc/fortran/match.h
+++ b/gcc/fortran/match.h
@@ -246,8 +246,11 @@ match gfc_match_contiguous (void);
 match gfc_match_dimension (void);
 match gfc_match_external (void);
 match gfc_match_gcc_attributes (void);
-match gfc_match_gcc_unroll (void);
 match gfc_match_gcc_builtin (void);
+match gfc_match_gcc_ivdep (void);
+match gfc_match_gcc_novector (void);
+match gfc_match_gcc_unroll (void);
+match gfc_match_gcc_vector (void);
 match gfc_match_import (void);
 match gfc_match_intent (void);
 match gfc_match_intrinsic (void);
diff --git a/gcc/fortran/misc.c b/gcc/fortran/misc.c
index ec31fb93cd2..809f2e07674 100644
--- a/gcc/fortran/misc.c
+++ b/gcc/fortran/misc.c
@@ -125,6 +125,7 @@ gfc_typename (gfc_typespec *ts)
   static char buffer2[GFC_MAX_SYMBOL_LEN + 7];
   static int flag = 0;
   char *buffer;
+  gfc_typespec *ts1;
 
   buffer = flag ? buffer1 : buffer2;
   flag = !flag;
@@ -156,9 +157,8 @@ gfc_typename (gfc_typespec *ts)
       sprintf (buffer, "TYPE(%s)", ts->u.derived->name);
       break;
     case BT_CLASS:
-      if (ts->u.derived->components)
-	ts = &ts->u.derived->components->ts;
-      if (ts->u.derived->attr.unlimited_polymorphic)
+      ts1 = ts->u.derived->components ? &ts->u.derived->components->ts : NULL;
+      if (ts1 && ts1->u.derived && ts1->u.derived->attr.unlimited_polymorphic)
 	sprintf (buffer, "CLASS(*)");
       else
 	sprintf (buffer, "CLASS(%s)", ts->u.derived->name);
diff --git a/gcc/fortran/module.c b/gcc/fortran/module.c
index 3e1ffedd8ee..dccce4fe0a4 100644
--- a/gcc/fortran/module.c
+++ b/gcc/fortran/module.c
@@ -525,6 +525,8 @@ gfc_match_use (void)
   gfc_intrinsic_op op;
   match m;
   gfc_use_list *use_list;
+  gfc_symtree *st;
+  locus loc;
 
   use_list = gfc_get_use_list ();
 
@@ -632,6 +634,8 @@ gfc_match_use (void)
 	case INTERFACE_USER_OP:
 	case INTERFACE_GENERIC:
 	case INTERFACE_DTIO:
+	  loc = gfc_current_locus;
+
 	  m = gfc_match (" =>");
 
 	  if (type == INTERFACE_USER_OP && m == MATCH_YES
@@ -642,6 +646,18 @@ gfc_match_use (void)
 	  if (type == INTERFACE_USER_OP)
 	    new_use->op = INTRINSIC_USER;
 
+	  st = gfc_find_symtree (gfc_current_ns->sym_root, name);
+	  if (st && type != INTERFACE_USER_OP)
+	    {
+	      if (m == MATCH_YES)
+		gfc_error ("Symbol %qs at %L conflicts with the rename symbol "
+			   "at %L", name, &st->n.sym->declared_at, &loc);
+	      else
+		gfc_error ("Symbol %qs at %L conflicts with the symbol "
+			   "at %L", name, &st->n.sym->declared_at, &loc);
+	      goto cleanup;
+	    }
+
 	  if (use_list->only_flag)
 	    {
 	      if (m != MATCH_YES)
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
index 66d84b4118f..86af947d152 100644
--- a/gcc/fortran/parse.c
+++ b/gcc/fortran/parse.c
@@ -1079,12 +1079,20 @@ decode_gcc_attribute (void)
   match ("attributes", gfc_match_gcc_attributes, ST_ATTR_DECL);
   match ("unroll", gfc_match_gcc_unroll, ST_NONE);
   match ("builtin", gfc_match_gcc_builtin, ST_NONE);
+  match ("ivdep", gfc_match_gcc_ivdep, ST_NONE);
+  match ("vector", gfc_match_gcc_vector, ST_NONE);
+  match ("novector", gfc_match_gcc_novector, ST_NONE);
 
   /* All else has failed, so give up.  See if any of the matchers has
      stored an error message of some sort.  */
 
   if (!gfc_error_check ())
-    gfc_error_now ("Unclassifiable GCC directive at %C");
+    {
+      if (pedantic)
+	gfc_error_now ("Unclassifiable GCC directive at %C");
+      else
+	gfc_warning_now (0, "Unclassifiable GCC directive at %C, ignored");
+    }
 
   reject_statement ();
 
@@ -4672,6 +4680,21 @@ parse_do_block (void)
 	  new_st.ext.iterator->unroll = directive_unroll;
 	  directive_unroll = -1;
 	}
+      if (directive_ivdep)
+	{
+	  new_st.ext.iterator->ivdep = directive_ivdep;
+	  directive_ivdep = false;
+	}
+      if (directive_vector)
+	{
+	  new_st.ext.iterator->vector = directive_vector;
+	  directive_vector = false;
+	}
+      if (directive_novector)
+	{
+	  new_st.ext.iterator->novector = directive_novector;
+	  directive_novector = false;
+	}
     }
   else
     stree = NULL;
@@ -5431,7 +5454,17 @@ parse_executable (gfc_statement st)
 	}
 
       if (directive_unroll != -1)
-	gfc_error ("%<GCC unroll%> directive does not commence a loop at %C");
+	gfc_error ("%<GCC unroll%> directive not at the start of a loop at %C");
+
+      if (directive_ivdep)
+	gfc_error ("%<GCC ivdep%> directive not at the start of a loop at %C");
+
+      if (directive_vector)
+	gfc_error ("%<GCC vector%> directive not at the start of a loop at %C");
+
+      if (directive_novector)
+	gfc_error ("%<GCC novector%> "
+		   "directive not at the start of a loop at %C");
 
       st = next_statement ();
     }
diff --git a/gcc/fortran/primary.c b/gcc/fortran/primary.c
index e918372ef85..8408e9c3d0d 100644
--- a/gcc/fortran/primary.c
+++ b/gcc/fortran/primary.c
@@ -1990,6 +1990,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
   match m;
   bool unknown;
   bool inquiry;
+  bool intrinsic;
   locus old_loc;
   char sep;
 
@@ -2194,11 +2195,15 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
       if (m != MATCH_YES)
 	return MATCH_ERROR;
 
+      intrinsic = false;
       if (primary->ts.type != BT_CLASS && primary->ts.type != BT_DERIVED)
 	{
 	  inquiry = is_inquiry_ref (name, &tmp);
 	  if (inquiry)
 	    sym = NULL;
+
+	  if (sep == '%' && primary->ts.type != BT_UNKNOWN)
+	    intrinsic = true;
 	}
       else
 	inquiry = false;
@@ -2258,12 +2263,16 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 	  break;
 	}
 
-      if (!inquiry)
+      if (!inquiry && !intrinsic)
 	component = gfc_find_component (sym, name, false, false, &tmp);
       else
 	component = NULL;
 
-      if (component == NULL && !inquiry)
+      /* In some cases, returning MATCH_NO gives a better error message. Most
+	 cases return "Unclassifiable statement at..."  */
+      if (intrinsic && !inquiry)
+	return MATCH_NO;
+      else if (component == NULL && !inquiry)
 	return MATCH_ERROR;
 
       /* Extend the reference chain determined by gfc_find_component or
@@ -2284,6 +2293,8 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 
       if (tmp && tmp->type == REF_INQUIRY)
 	{
+	  if (!primary->where.lb || !primary->where.nextc)
+	    primary->where = gfc_current_locus;
 	  gfc_simplify_expr (primary, 0);
 
 	  if (primary->expr_type == EXPR_CONSTANT)
@@ -2559,12 +2570,10 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)
 	    break;
 
 	  case AR_UNKNOWN:
-	    /* If any of start, end or stride is not integer, there will
-	       already have been an error issued.  */
-	    int errors;
-	    gfc_get_errors (NULL, &errors);
-	    if (errors == 0)
-	      gfc_internal_error ("gfc_variable_attr(): Bad array reference");
+	    /* For standard conforming code, AR_UNKNOWN should not happen.
+	       For nonconforming code, gfortran can end up here.  Treat it 
+	       as a no-op.  */
+	    break;
 	  }
 
 	break;
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index afa4e5c2ccf..b3807576653 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -1866,7 +1866,7 @@ resolve_procedure_expression (gfc_expr* expr)
 
 
 /* Check that name is not a derived type.  */
- 
+
 static bool
 is_dt_name (const char *name)
 {
@@ -7059,19 +7059,6 @@ gfc_resolve_iterator (gfc_iterator *iter, bool real_ok, bool own_scope)
 				  "Step expression in DO loop"))
     return false;
 
-  if (iter->step->expr_type == EXPR_CONSTANT)
-    {
-      if ((iter->step->ts.type == BT_INTEGER
-	   && mpz_cmp_ui (iter->step->value.integer, 0) == 0)
-	  || (iter->step->ts.type == BT_REAL
-	      && mpfr_sgn (iter->step->value.real) == 0))
-	{
-	  gfc_error ("Step expression in DO loop at %L cannot be zero",
-		     &iter->step->where);
-	  return false;
-	}
-    }
-
   /* Convert start, end, and step to the same type as var.  */
   if (iter->start->ts.kind != iter->var->ts.kind
       || iter->start->ts.type != iter->var->ts.type)
@@ -7085,6 +7072,19 @@ gfc_resolve_iterator (gfc_iterator *iter, bool real_ok, bool own_scope)
       || iter->step->ts.type != iter->var->ts.type)
     gfc_convert_type (iter->step, &iter->var->ts, 1);
 
+  if (iter->step->expr_type == EXPR_CONSTANT)
+    {
+      if ((iter->step->ts.type == BT_INTEGER
+	   && mpz_cmp_ui (iter->step->value.integer, 0) == 0)
+	  || (iter->step->ts.type == BT_REAL
+	      && mpfr_sgn (iter->step->value.real) == 0))
+	{
+	  gfc_error ("Step expression in DO loop at %L cannot be zero",
+		     &iter->step->where);
+	  return false;
+	}
+    }
+
   if (iter->start->expr_type == EXPR_CONSTANT
       && iter->end->expr_type == EXPR_CONSTANT
       && iter->step->expr_type == EXPR_CONSTANT)
@@ -7439,7 +7439,7 @@ conformable_arrays (gfc_expr *e1, gfc_expr *e2)
   for (tail = e2->ref; tail && tail->next; tail = tail->next);
 
   /* First compare rank.  */
-  if ((tail && e1->rank != tail->u.ar.as->rank)
+  if ((tail && (!tail->u.ar.as || e1->rank != tail->u.ar.as->rank))
       || (!tail && e1->rank != e2->rank))
     {
       gfc_error ("Source-expr at %L must be scalar or have the "
@@ -13539,14 +13539,34 @@ resolve_typebound_procedure (gfc_symtree* stree)
     }
   else
     {
+      /* If proc has not been resolved at this point, proc->name may
+	 actually be a USE associated entity. See PR fortran/89647. */
+      if (!proc->resolved
+	  && proc->attr.function == 0 && proc->attr.subroutine == 0)
+	{
+	  gfc_symbol *tmp;
+	  gfc_find_symbol (proc->name, gfc_current_ns->parent, 1, &tmp);
+	  if (tmp && tmp->attr.use_assoc)
+	    {
+	      proc->module = tmp->module;
+	      proc->attr.proc = tmp->attr.proc;
+	      proc->attr.function = tmp->attr.function;
+	      proc->attr.subroutine = tmp->attr.subroutine;
+	      proc->attr.use_assoc = tmp->attr.use_assoc;
+	      proc->ts = tmp->ts;
+	      proc->result = tmp->result;
+	    }
+	}
+
       /* Check for F08:C465.  */
       if ((!proc->attr.subroutine && !proc->attr.function)
 	  || (proc->attr.proc != PROC_MODULE
 	      && proc->attr.if_source != IFSRC_IFBODY)
 	  || proc->attr.abstract)
 	{
-	  gfc_error ("%qs must be a module procedure or an external procedure with"
-		    " an explicit interface at %L", proc->name, &where);
+	  gfc_error ("%qs must be a module procedure or an external "
+		     "procedure with an explicit interface at %L",
+		     proc->name, &where);
 	  goto error;
 	}
     }
@@ -15662,8 +15682,6 @@ check_data_variable (gfc_data_variable *var, locus *where)
       return false;
     }
 
-  has_pointer = sym->attr.pointer;
-
   if (gfc_is_coindexed (e))
     {
       gfc_error ("DATA element %qs at %L cannot have a coindex", sym->name,
@@ -15671,19 +15689,30 @@ check_data_variable (gfc_data_variable *var, locus *where)
       return false;
     }
 
+  has_pointer = sym->attr.pointer;
+
   for (ref = e->ref; ref; ref = ref->next)
     {
       if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)
 	has_pointer = 1;
 
-      if (has_pointer
-	    && ref->type == REF_ARRAY
-	    && ref->u.ar.type != AR_FULL)
-	  {
-	    gfc_error ("DATA element %qs at %L is a pointer and so must "
-			"be a full array", sym->name, where);
-	    return false;
-	  }
+      if (has_pointer)
+	{
+	  if (ref->type == REF_ARRAY && ref->u.ar.type != AR_FULL)
+	    {
+	      gfc_error ("DATA element %qs at %L is a pointer and so must "
+			 "be a full array", sym->name, where);
+	      return false;
+	    }
+
+	  if (values.vnode->expr->expr_type == EXPR_CONSTANT)
+	    {
+	      gfc_error ("DATA object near %L has the pointer attribute "
+			 "and the corresponding DATA value is not a valid "
+			 "initial-data-target", where);
+	      return false;
+	    }
+	}
     }
 
   if (e->rank == 0 || has_pointer)
@@ -16525,8 +16554,8 @@ resolve_equivalence (gfc_equiv *eq)
 }
 
 
-/* Function called by resolve_fntype to flag other symbol used in the
-   length type parameter specification of function resuls.  */
+/* Function called by resolve_fntype to flag other symbols used in the
+   length type parameter specification of function results.  */
 
 static bool
 flag_fn_result_spec (gfc_expr *expr,
diff --git a/gcc/fortran/scanner.c b/gcc/fortran/scanner.c
index e54d483baff..40c06b6b674 100644
--- a/gcc/fortran/scanner.c
+++ b/gcc/fortran/scanner.c
@@ -1050,6 +1050,10 @@ skip_fixed_comments (void)
 	      return;
 	    }
 
+	  if (gfc_current_locus.lb != NULL
+	      && continue_line < gfc_linebuf_linenum (gfc_current_locus.lb))
+	    continue_line = gfc_linebuf_linenum (gfc_current_locus.lb);
+
 	  /* If -fopenmp/-fopenacc, we need to handle here 2 things:
 	     1) don't treat !$omp/!$acc|c$omp/c$acc|*$omp / *$acc as comments, 
 		but directives
@@ -1057,10 +1061,6 @@ skip_fixed_comments (void)
 		!$|c$|*$ should be treated as 2 spaces if the characters
 		in columns 3 to 6 are valid fixed form label columns
 		characters.  */
-	  if (gfc_current_locus.lb != NULL
-	      && continue_line < gfc_linebuf_linenum (gfc_current_locus.lb))
-	    continue_line = gfc_linebuf_linenum (gfc_current_locus.lb);
-
 	  if ((flag_openmp || flag_openmp_simd) && !flag_openacc)
 	    {
 	      if (next_char () == '$')
@@ -1313,6 +1313,14 @@ restart:
       if (flag_openacc)
 	prev_openacc_flag = openacc_flag;
 
+      /* This can happen if the input file changed or via cpp's #line
+	 without getting reset (e.g. via input_stmt). It also happens
+	 when pre-including files via -fpre-include=.  */
+      if (continue_count == 0
+	  && gfc_current_locus.lb
+	  && continue_line > gfc_linebuf_linenum (gfc_current_locus.lb) + 1)
+	continue_line = gfc_linebuf_linenum (gfc_current_locus.lb) + 1;
+
       continue_flag = 1;
       if (c == '!')
 	skip_comment_line ();
@@ -1475,6 +1483,14 @@ restart:
       if (flag_openacc)
 	prev_openacc_flag = openacc_flag;
 
+      /* This can happen if the input file changed or via cpp's #line
+	 without getting reset (e.g. via input_stmt). It also happens
+	 when pre-including files via -fpre-include=.  */
+      if (continue_count == 0
+	  && gfc_current_locus.lb
+	  && continue_line > gfc_linebuf_linenum (gfc_current_locus.lb) + 1)
+	continue_line = gfc_linebuf_linenum (gfc_current_locus.lb) + 1;
+
       continue_flag = 1;
       old_loc = gfc_current_locus;
 
@@ -1943,7 +1959,7 @@ next_char:
    the file stack.  */
 
 static gfc_file *
-get_file (const char *name, enum lc_reason reason ATTRIBUTE_UNUSED)
+get_file (const char *name, enum lc_reason reason)
 {
   gfc_file *f;
 
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index 6c1f4bd4fce..58b4652b010 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -4808,8 +4808,12 @@ gfc_simplify_merge (gfc_expr *tsource, gfc_expr *fsource, gfc_expr *mask)
   gfc_constructor *tsource_ctor, *fsource_ctor, *mask_ctor;
 
   if (mask->expr_type == EXPR_CONSTANT)
-    return gfc_get_parentheses (gfc_copy_expr (mask->value.logical
-					       ? tsource : fsource));
+    {
+      result = gfc_copy_expr (mask->value.logical ? tsource : fsource);
+      result = gfc_get_parentheses (result);
+      gfc_simplify_expr (result, 1);
+      return result;
+    }
 
   if (!mask->rank || !is_constant_array_expr (mask)
       || !is_constant_array_expr (tsource) || !is_constant_array_expr (fsource))
@@ -6684,6 +6688,9 @@ gfc_simplify_reshape (gfc_expr *source, gfc_expr *shape_exp,
   mpz_init (index);
   rank = 0;
 
+  for (i = 0; i < GFC_MAX_DIMENSIONS; i++)
+    x[i] = 0;
+
   for (;;)
     {
       e = gfc_constructor_lookup_expr (shape_exp->value.constructor, rank);
@@ -6708,8 +6715,28 @@ gfc_simplify_reshape (gfc_expr *source, gfc_expr *shape_exp,
     }
   else
     {
-      for (i = 0; i < rank; i++)
-	x[i] = 0;
+      mpz_t size;
+      int order_size, shape_size;
+
+      if (order_exp->rank != shape_exp->rank)
+	{
+	  gfc_error ("Shapes of ORDER at %L and SHAPE at %L are different",
+		     &order_exp->where, &shape_exp->where);
+	  return &gfc_bad_expr;
+	}
+
+      gfc_array_size (shape_exp, &size);
+      shape_size = mpz_get_ui (size);
+      mpz_clear (size);
+      gfc_array_size (order_exp, &size);
+      order_size = mpz_get_ui (size);
+      mpz_clear (size);
+      if (order_size != shape_size)
+	{
+	  gfc_error ("Sizes of ORDER at %L and SHAPE at %L are different",
+		     &order_exp->where, &shape_exp->where);
+	  return &gfc_bad_expr;
+	}
 
       for (i = 0; i < rank; i++)
 	{
@@ -6718,9 +6745,22 @@ gfc_simplify_reshape (gfc_expr *source, gfc_expr *shape_exp,
 
 	  gfc_extract_int (e, &order[i]);
 
-	  gcc_assert (order[i] >= 1 && order[i] <= rank);
+	  if (order[i] < 1 || order[i] > rank)
+	    {
+	      gfc_error ("Element with a value of %d in ORDER at %L must be "
+			 "in the range [1, ..., %d] for the RESHAPE intrinsic "
+			 "near %L", order[i], &order_exp->where, rank,
+			 &shape_exp->where);
+	      return &gfc_bad_expr;
+	    }
+
 	  order[i]--;
-	  gcc_assert (x[order[i]] == 0);
+	  if (x[order[i]] != 0)
+	    {
+	      gfc_error ("ORDER at %L is not a permutation of the size of "
+			 "SHAPE at %L", &order_exp->where, &shape_exp->where);
+	      return &gfc_bad_expr;
+	    }
 	  x[order[i]] = 1;
 	}
     }
@@ -8494,6 +8534,12 @@ gfc_convert_constant (gfc_expr *e, bt type, int kind)
 	    {
 	      if (c->expr->expr_type == EXPR_ARRAY)
 		tmp = gfc_convert_constant (c->expr, type, kind);
+	      else if (c->expr->expr_type == EXPR_OP
+			&& c->expr->value.op.op == INTRINSIC_PARENTHESES)
+		{
+		  gfc_simplify_expr (c->expr, 1);
+		  tmp = f (c->expr, kind);
+		}
 	      else
 		tmp = f (c->expr, kind);
 	    }
diff --git a/gcc/fortran/trans-array.c b/gcc/fortran/trans-array.c
index 583425c516d..3945d116180 100644
--- a/gcc/fortran/trans-array.c
+++ b/gcc/fortran/trans-array.c
@@ -6110,17 +6110,20 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)
 		  tree atype = type;
 		  while (TREE_CODE (TREE_TYPE (atype)) == ARRAY_TYPE)
 		    atype = TREE_TYPE (atype);
-		  if (TREE_CODE (TREE_TYPE (atype)) == INTEGER_TYPE
-		      && tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (se.expr)))
-			 > tree_to_uhwi (TYPE_SIZE_UNIT (atype)))
+		  gcc_checking_assert (TREE_CODE (TREE_TYPE (atype))
+				       == INTEGER_TYPE);
+		  gcc_checking_assert (TREE_TYPE (TREE_TYPE (se.expr))
+				       == TREE_TYPE (atype));
+		  if (tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (se.expr)))
+		      > tree_to_uhwi (TYPE_SIZE_UNIT (atype)))
 		    {
 		      unsigned HOST_WIDE_INT size
 			= tree_to_uhwi (TYPE_SIZE_UNIT (atype));
 		      const char *p = TREE_STRING_POINTER (se.expr);
 
 		      se.expr = build_string (size, p);
-		      TREE_TYPE (se.expr) = atype;
 		    }
+		  TREE_TYPE (se.expr) = atype;
 		}
 	      break;
 
@@ -8024,7 +8027,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,
 	  /* The components shall be deallocated before their containing entity.  */
 	  gfc_prepend_expr_to_block (&se->post, tmp);
 	}
-      if (expr->ts.type == BT_CHARACTER)
+      if (expr->ts.type == BT_CHARACTER && expr->expr_type != EXPR_FUNCTION)
 	se->string_length = expr->ts.u.cl->backend_decl;
       if (size)
 	array_parameter_size (se->expr, expr, size);
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index 9538dee5733..27613f761e3 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -369,44 +369,37 @@ gfc_sym_identifier (gfc_symbol * sym)
 static const char *
 mangled_identifier (gfc_symbol *sym)
 {
-  static char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];
+  gfc_symbol *proc = sym->ns->proc_name;
+  static char name[3*GFC_MAX_MANGLED_SYMBOL_LEN + 14];
   /* Prevent the mangling of identifiers that have an assigned
      binding label (mainly those that are bind(c)).  */
 
   if (sym->attr.is_bind_c == 1 && sym->binding_label)
     return sym->binding_label;
 
-  if (!sym->fn_result_spec)
+  if (!sym->fn_result_spec
+      || (sym->module && !(proc && proc->attr.flavor == FL_PROCEDURE)))
     {
       if (sym->module == NULL)
 	return sym_identifier (sym);
       else
-	{
-	  snprintf (name, sizeof name, "__%s_MOD_%s", sym->module, sym->name);
-	  return name;
-	}
+	snprintf (name, sizeof name, "__%s_MOD_%s", sym->module, sym->name);
     }
   else
     {
       /* This is an entity that is actually local to a module procedure
 	 that appears in the result specification expression.  Since
 	 sym->module will be a zero length string, we use ns->proc_name
-	 instead. */
-      if (sym->ns->proc_name && sym->ns->proc_name->module)
-	{
-	  snprintf (name, sizeof name, "__%s_MOD__%s_PROC_%s",
-		    sym->ns->proc_name->module,
-		    sym->ns->proc_name->name,
-		    sym->name);
-	  return name;
-	}
+	 to provide the module name instead. */
+      if (proc && proc->module)
+	snprintf (name, sizeof name, "__%s_MOD__%s_PROC_%s",
+		  proc->module, proc->name, sym->name);
       else
-	{
-	  snprintf (name, sizeof name, "__%s_PROC_%s",
-		    sym->ns->proc_name->name, sym->name);
-	  return name;
-	}
+	snprintf (name, sizeof name, "__%s_PROC_%s",
+		  proc->name, sym->name);
     }
+
+  return name;
 }
 
 /* Get mangled identifier, adding the symbol to the global table if
@@ -1892,9 +1885,18 @@ gfc_get_symbol_decl (gfc_symbol * sym)
   if (sym->attr.associate_var)
     GFC_DECL_ASSOCIATE_VAR_P (decl) = 1;
 
-  if (sym->attr.vtab
-      || (sym->name[0] == '_' && gfc_str_startswith (sym->name, "__def_init")))
-    TREE_READONLY (decl) = 1;
+  /* We only mark __def_init as read-only if it actually has an
+     initializer so it does not needlessly take up space in the
+     read-only section and can go into the BSS instead, see PR 84487.
+     Marking this as artificial means that OpenMP will treat this as
+     predetermined shared.  */
+
+  if (sym->attr.vtab || gfc_str_startswith (sym->name, "__def_init"))
+    {
+      DECL_ARTIFICIAL (decl) = 1;
+      if (sym->attr.vtab || sym->value)
+	TREE_READONLY (decl) = 1;
+    }
 
   return decl;
 }
@@ -5862,9 +5864,11 @@ generate_local_decl (gfc_symbol * sym)
 	    }
 	  else if (warn_unused_dummy_argument)
 	    {
-	      gfc_warning (OPT_Wunused_dummy_argument,
-			   "Unused dummy argument %qs at %L", sym->name,
-			   &sym->declared_at);
+	      if (!sym->attr.artificial)
+		gfc_warning (OPT_Wunused_dummy_argument,
+			     "Unused dummy argument %qs at %L", sym->name,
+			     &sym->declared_at);
+
 	      if (sym->backend_decl != NULL_TREE)
 		TREE_NO_WARNING(sym->backend_decl) = 1;
 	    }
@@ -5956,7 +5960,14 @@ generate_local_decl (gfc_symbol * sym)
 
       if (sym->ns && sym->ns->construct_entities)
 	{
-	  if (sym->attr.referenced)
+	  /* Construction of the intrinsic modules within a BLOCK
+	     construct, where ONLY and RENAMED entities are included,
+	     seems to be bogus.  This is a workaround that can be removed
+	     if someone ever takes on the task to creating full-fledge
+	     modules.  See PR 69455.  */
+	  if (sym->attr.referenced
+	      && sym->from_intmod != INTMOD_ISO_C_BINDING
+	      && sym->from_intmod != INTMOD_ISO_FORTRAN_ENV)
 	    gfc_get_symbol_decl (sym);
 	  sym->mark = 1;
 	}
@@ -6440,6 +6451,20 @@ gfc_generate_return (void)
 				    TREE_TYPE (result), DECL_RESULT (fndecl),
 				    result);
 	}
+      else
+	{
+	  /* If the function does not have a result variable, result is
+	     NULL_TREE, and a 'return' is generated without a variable.
+	     The following generates a 'return __result_XXX' where XXX is
+	     the function name.  */
+	  if (sym == sym->result && sym->attr.function)
+	    {
+	      result = gfc_get_fake_result_decl (sym, 0);
+	      result = fold_build2_loc (input_location, MODIFY_EXPR,
+					TREE_TYPE (result),
+					DECL_RESULT (fndecl), result);
+	    }
+	}
     }
 
   return build1_v (RETURN_EXPR, result);
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index afe08fc2668..52a8cdd6902 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -4989,21 +4989,30 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)
   tree gfc_desc_ptr;
   tree type;
   tree cond;
+  tree desc_attr;
   int attribute;
+  int cfi_attribute;
   symbol_attribute attr = gfc_expr_attr (e);
-  stmtblock_t block;
 
   /* If this is a full array or a scalar, the allocatable and pointer
      attributes can be passed. Otherwise it is 'CFI_attribute_other'*/
   attribute = 2;
   if (!e->rank || gfc_get_full_arrayspec_from_expr (e))
     {
-      if (fsym->attr.pointer)
+      if (attr.pointer)
 	attribute = 0;
-      else if (fsym->attr.allocatable)
+      else if (attr.allocatable)
 	attribute = 1;
     }
 
+  /* If the formal argument is assumed shape and neither a pointer nor
+     allocatable, it is unconditionally CFI_attribute_other.  */
+  if (fsym->as->type == AS_ASSUMED_SHAPE
+      && !fsym->attr.pointer && !fsym->attr.allocatable)
+   cfi_attribute = 2;
+  else
+   cfi_attribute = attribute;
+
   if (e->rank != 0)
     {
       parmse->force_no_tmp = 1;
@@ -5018,6 +5027,10 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)
 	parmse->expr = build_fold_indirect_ref_loc (input_location,
 						    parmse->expr);
 
+      bool is_artificial = (INDIRECT_REF_P (parmse->expr)
+			    ? DECL_ARTIFICIAL (TREE_OPERAND (parmse->expr, 0))
+			    : DECL_ARTIFICIAL (parmse->expr));
+
       /* Unallocated allocatable arrays and unassociated pointer arrays
 	 need their dtype setting if they are argument associated with
 	 assumed rank dummies.  */
@@ -5036,7 +5049,7 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)
       type = e->ts.type != BT_ASSUMED ? gfc_typenode_for_spec (&e->ts) :
 					NULL_TREE;
 
-      if (type && DECL_ARTIFICIAL (parmse->expr)
+      if (type && is_artificial
 	  && type != gfc_get_element_type (TREE_TYPE (parmse->expr)))
 	{
 	  /* Obtain the offset to the data.  */
@@ -5048,8 +5061,7 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)
 			  gfc_conv_descriptor_dtype (parmse->expr),
 			  gfc_get_dtype_rank_type (e->rank, type));
 	}
-      else if (type == NULL_TREE
-	       || (!is_subref_array (e) && !DECL_ARTIFICIAL (parmse->expr)))
+      else if (type == NULL_TREE || (!is_subref_array (e) && !is_artificial))
 	{
 	  /* Make sure that the span is set for expressions where it
 	     might not have been done already.  */
@@ -5070,41 +5082,40 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)
 						    parmse->expr, attr);
     }
 
-  /* Set the CFI attribute field.  */
-  tmp = gfc_conv_descriptor_attribute (parmse->expr);
+  /* Set the CFI attribute field through a temporary value for the
+     gfc attribute.  */
+  desc_attr = gfc_conv_descriptor_attribute (parmse->expr);
   tmp = fold_build2_loc (input_location, MODIFY_EXPR,
-			 void_type_node, tmp,
-			 build_int_cst (TREE_TYPE (tmp), attribute));
+			 void_type_node, desc_attr,
+			 build_int_cst (TREE_TYPE (desc_attr), cfi_attribute));
   gfc_add_expr_to_block (&parmse->pre, tmp);
 
   /* Now pass the gfc_descriptor by reference.  */
   parmse->expr = gfc_build_addr_expr (NULL_TREE, parmse->expr);
 
-  /* Variables to point to the gfc and CFI descriptors.  */
+  /* Variables to point to the gfc and CFI descriptors; cfi = NULL implies
+     that the CFI descriptor is allocated by the gfor_fndecl_gfc_to_cfi call.  */
   gfc_desc_ptr = parmse->expr;
   cfi_desc_ptr = gfc_create_var (pvoid_type_node, "cfi");
-  gfc_add_modify (&parmse->pre, cfi_desc_ptr,
-		  build_int_cst (pvoid_type_node, 0));
+  gfc_add_modify (&parmse->pre, cfi_desc_ptr, null_pointer_node);
 
-  /* Allocate the CFI descriptor and fill the fields.  */
+  /* Allocate the CFI descriptor itself and fill the fields.  */
   tmp = gfc_build_addr_expr (NULL_TREE, cfi_desc_ptr);
   tmp = build_call_expr_loc (input_location,
 			     gfor_fndecl_gfc_to_cfi, 2, tmp, gfc_desc_ptr);
   gfc_add_expr_to_block (&parmse->pre, tmp);
 
+  /* Now set the gfc descriptor attribute.  */
+  tmp = fold_build2_loc (input_location, MODIFY_EXPR,
+			 void_type_node, desc_attr,
+			 build_int_cst (TREE_TYPE (desc_attr), attribute));
+  gfc_add_expr_to_block (&parmse->pre, tmp);
+
   /* The CFI descriptor is passed to the bind_C procedure.  */
   parmse->expr = cfi_desc_ptr;
 
   /* Free the CFI descriptor.  */
-  gfc_init_block (&block);
-  cond = fold_build2_loc (input_location, NE_EXPR,
-			  logical_type_node, cfi_desc_ptr,
-			  build_int_cst (TREE_TYPE (cfi_desc_ptr), 0));
   tmp = gfc_call_free (cfi_desc_ptr);
-  gfc_add_expr_to_block (&block, tmp);
-  tmp = build3_v (COND_EXPR, cond,
-		  gfc_finish_block (&block),
-		  build_empty_stmt (input_location));
   gfc_prepend_expr_to_block (&parmse->post, tmp);
 
   /* Transfer values back to gfc descriptor.  */
@@ -5112,6 +5123,25 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)
   tmp = build_call_expr_loc (input_location,
 			     gfor_fndecl_cfi_to_gfc, 2, gfc_desc_ptr, tmp);
   gfc_prepend_expr_to_block (&parmse->post, tmp);
+
+  /* Deal with an optional dummy being passed to an optional formal arg
+     by finishing the pre and post blocks and making their execution
+     conditional on the dummy being present.  */
+  if (fsym->attr.optional && e->expr_type == EXPR_VARIABLE
+      && e->symtree->n.sym->attr.optional)
+    {
+      cond = gfc_conv_expr_present (e->symtree->n.sym);
+      tmp = fold_build2 (MODIFY_EXPR, void_type_node,
+			 cfi_desc_ptr,
+			 build_int_cst (pvoid_type_node, 0));
+      tmp = build3_v (COND_EXPR, cond,
+		      gfc_finish_block (&parmse->pre), tmp);
+      gfc_add_expr_to_block (&parmse->pre, tmp);
+      tmp = build3_v (COND_EXPR, cond,
+		      gfc_finish_block (&parmse->post),
+		      build_empty_stmt (input_location));
+      gfc_add_expr_to_block (&parmse->post, tmp);
+    }
 }
 
 
@@ -6001,8 +6031,14 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		      gfc_add_expr_to_block (&se->pre, tmp);
 		  }
 
-		  tmp = build_fold_indirect_ref_loc (input_location,
-						     parmse.expr);
+		  tmp = parmse.expr;
+		  /* With bind(C), the actual argument is replaced by a bind-C
+		     descriptor; in this case, the data component arrives here,
+		     which shall not be dereferenced, but still freed and
+		     nullified.  */
+		  if  (TREE_TYPE(tmp) != pvoid_type_node)
+		    tmp = build_fold_indirect_ref_loc (input_location,
+						       parmse.expr);
 		  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))
 		    tmp = gfc_conv_descriptor_data_get (tmp);
 		  tmp = gfc_deallocate_with_status (tmp, NULL_TREE, NULL_TREE,
@@ -10603,7 +10639,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
       if (expr1->ts.deferred
 	  && gfc_expr_attr (expr1).allocatable
 	  && gfc_check_dependency (expr1, expr2, true))
-	rse.string_length = gfc_evaluate_now (rse.string_length, &rse.pre);
+	rse.string_length =
+	  gfc_evaluate_now_function_scope (rse.string_length, &rse.pre);
       string_length = rse.string_length;
     }
   else
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
index 5fa182bf05a..b839d6c73e1 100644
--- a/gcc/fortran/trans-stmt.c
+++ b/gcc/fortran/trans-stmt.c
@@ -2171,6 +2171,19 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,
 		build_int_cst (integer_type_node, annot_expr_unroll_kind),
 		build_int_cst (integer_type_node, code->ext.iterator->unroll));
 
+  if (code->ext.iterator->ivdep && cond != error_mark_node)
+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
+		   build_int_cst (integer_type_node, annot_expr_ivdep_kind),
+		   integer_zero_node);
+  if (code->ext.iterator->vector && cond != error_mark_node)
+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
+		   build_int_cst (integer_type_node, annot_expr_vector_kind),
+		   integer_zero_node);
+  if (code->ext.iterator->novector && cond != error_mark_node)
+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
+		   build_int_cst (integer_type_node, annot_expr_no_vector_kind),
+		   integer_zero_node);
+
   /* The loop exit.  */
   tmp = fold_build1_loc (loc, GOTO_EXPR, void_type_node, exit_label);
   TREE_USED (exit_label) = 1;
@@ -2501,6 +2514,20 @@ gfc_trans_do (gfc_code * code, tree exit_cond)
       = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
 		build_int_cst (integer_type_node, annot_expr_unroll_kind),
 		build_int_cst (integer_type_node, code->ext.iterator->unroll));
+
+  if (code->ext.iterator->ivdep && cond != error_mark_node)
+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
+		   build_int_cst (integer_type_node, annot_expr_ivdep_kind),
+		   integer_zero_node);
+  if (code->ext.iterator->vector && cond != error_mark_node)
+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
+		   build_int_cst (integer_type_node, annot_expr_vector_kind),
+		   integer_zero_node);
+  if (code->ext.iterator->novector && cond != error_mark_node)
+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
+		   build_int_cst (integer_type_node, annot_expr_no_vector_kind),
+		   integer_zero_node);
+
   tmp = fold_build1_loc (loc, GOTO_EXPR, void_type_node, exit_label);
   tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,
 			 cond, tmp, build_empty_stmt (loc));
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index d3b61e78887..3c8188b30c4 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -3021,6 +3021,7 @@ get_formal_from_actual_arglist (gfc_symbol *sym, gfc_actual_arglist *actual_args
 		}
 	    }
 	  s->attr.dummy = 1;
+	  s->attr.artificial = 1;
 	  s->attr.intent = INTENT_UNKNOWN;
 	  (*f)->sym = s;
 	}
diff --git a/gcc/fortran/trans.c b/gcc/fortran/trans.c
index e7844c9bf1f..167fcb2158c 100644
--- a/gcc/fortran/trans.c
+++ b/gcc/fortran/trans.c
@@ -118,6 +118,19 @@ gfc_evaluate_now (tree expr, stmtblock_t * pblock)
   return gfc_evaluate_now_loc (input_location, expr, pblock);
 }
 
+/* Like gfc_evaluate_now, but add the created variable to the
+   function scope.  */
+
+tree
+gfc_evaluate_now_function_scope (tree expr, stmtblock_t * pblock)
+{
+  tree var;
+  var = gfc_create_var_np (TREE_TYPE (expr), NULL);
+  gfc_add_decl_to_function (var);
+  gfc_add_modify (pblock, var, expr);
+
+  return var;
+}
 
 /* Build a MODIFY_EXPR node and add it to a given statement block PBLOCK.
    A MODIFY_EXPR is an assignment:
diff --git a/gcc/fortran/trans.h b/gcc/fortran/trans.h
index 273c75a422c..6b42d82806b 100644
--- a/gcc/fortran/trans.h
+++ b/gcc/fortran/trans.h
@@ -507,6 +507,7 @@ void gfc_conv_label_variable (gfc_se * se, gfc_expr * expr);
 /* If the value is not constant, Create a temporary and copy the value.  */
 tree gfc_evaluate_now_loc (location_t, tree, stmtblock_t *);
 tree gfc_evaluate_now (tree, stmtblock_t *);
+tree gfc_evaluate_now_function_scope (tree, stmtblock_t *);
 
 /* Find the appropriate variant of a math intrinsic.  */
 tree gfc_builtin_decl_for_float_kind (enum built_in_function, int);
diff --git a/gcc/function.c b/gcc/function.c
index c6e862b3369..acf9f9e60c7 100644
--- a/gcc/function.c
+++ b/gcc/function.c
@@ -2449,8 +2449,7 @@ assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,
   /* If the parm is to be passed as a transparent union or record, use the
      type of the first field for the tests below.  We have already verified
      that the modes are the same.  */
-  if ((TREE_CODE (passed_type) == UNION_TYPE
-       || TREE_CODE (passed_type) == RECORD_TYPE)
+  if (RECORD_OR_UNION_TYPE_P (passed_type)
       && TYPE_TRANSPARENT_AGGR (passed_type))
     passed_type = TREE_TYPE (first_field (passed_type));
 
@@ -3079,7 +3078,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,
 	move_block_from_reg (REGNO (entry_parm), mem,
 			     size_stored / UNITS_PER_WORD);
     }
-  else if (data->stack_parm == 0)
+  else if (data->stack_parm == 0 && !TYPE_EMPTY_P (data->passed_type))
     {
       push_to_sequence2 (all->first_conversion_insn, all->last_conversion_insn);
       emit_block_move (stack_parm, data->entry_parm, GEN_INT (size),
@@ -3455,7 +3454,9 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,
       dest = validize_mem (copy_rtx (data->stack_parm));
       src = validize_mem (copy_rtx (data->entry_parm));
 
-      if (MEM_P (src))
+      if (TYPE_EMPTY_P (data->passed_type))
+	/* Empty types don't really need to be copied.  */;
+      else if (MEM_P (src))
 	{
 	  /* Use a block move to handle potentially misaligned entry_parm.  */
 	  if (!to_conversion)
@@ -3611,6 +3612,16 @@ assign_parms (tree fndecl)
 	{
 	  assign_parm_find_stack_rtl (parm, &data);
 	  assign_parm_adjust_entry_rtl (&data);
+	  /* For arguments that occupy no space in the parameter
+	     passing area, have non-zero size and have address taken,
+	     force creation of a stack slot so that they have distinct
+	     address from other parameters.  */
+	  if (TYPE_EMPTY_P (data.passed_type)
+	      && TREE_ADDRESSABLE (parm)
+	      && data.entry_parm == data.stack_parm
+	      && MEM_P (data.entry_parm)
+	      && int_size_in_bytes (data.passed_type))
+	    data.stack_parm = NULL_RTX;
 	}
       /* Record permanently how this parm was passed.  */
       if (data.passed_pointer)
diff --git a/gcc/gcov.c b/gcc/gcov.c
index b06a6714c2e..7e51c2efb30 100644
--- a/gcc/gcov.c
+++ b/gcc/gcov.c
@@ -725,10 +725,10 @@ unblock (const block_info *u, block_vector_t &blocked,
 /* Return true when PATH contains a zero cycle arc count.  */
 
 static bool
-path_contains_zero_cycle_arc (arc_vector_t &path)
+path_contains_zero_or_negative_cycle_arc (arc_vector_t &path)
 {
   for (unsigned i = 0; i < path.size (); i++)
-    if (path[i]->cs_count == 0)
+    if (path[i]->cs_count <= 0)
       return true;
   return false;
 }
@@ -754,7 +754,7 @@ circuit (block_info *v, arc_vector_t &path, block_info *start,
     {
       block_info *w = arc->dst;
       if (w < start
-	  || arc->cs_count == 0
+	  || arc->cs_count <= 0
 	  || !linfo.has_block (w))
 	continue;
 
@@ -765,7 +765,7 @@ circuit (block_info *v, arc_vector_t &path, block_info *start,
 	  handle_cycle (path, count);
 	  loop_found = true;
 	}
-      else if (!path_contains_zero_cycle_arc (path)
+      else if (!path_contains_zero_or_negative_cycle_arc (path)
 	       &&  find (blocked.begin (), blocked.end (), w) == blocked.end ())
 	loop_found |= circuit (w, path, start, blocked, block_lists, linfo,
 			       count);
@@ -780,7 +780,7 @@ circuit (block_info *v, arc_vector_t &path, block_info *start,
       {
 	block_info *w = arc->dst;
 	if (w < start
-	    || arc->cs_count == 0
+	    || arc->cs_count <= 0
 	    || !linfo.has_block (w))
 	  continue;
 
diff --git a/gcc/generic-match-head.c b/gcc/generic-match-head.c
index a46f375017b..3478cf59f91 100644
--- a/gcc/generic-match-head.c
+++ b/gcc/generic-match-head.c
@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "ssa.h"
 #include "cgraph.h"
 #include "fold-const.h"
+#include "fold-const-call.h"
 #include "stor-layout.h"
 #include "tree-dfa.h"
 #include "builtins.h"
diff --git a/gcc/ggc-none.c b/gcc/ggc-none.c
index 6edec27868c..737429f9e49 100644
--- a/gcc/ggc-none.c
+++ b/gcc/ggc-none.c
@@ -72,3 +72,8 @@ void
 ggc_grow (void)
 {
 }
+
+void
+ggc_trim (void)
+{
+}
diff --git a/gcc/ggc-page.c b/gcc/ggc-page.c
index 143986be58f..3c9636d0fe7 100644
--- a/gcc/ggc-page.c
+++ b/gcc/ggc-page.c
@@ -1016,6 +1016,8 @@ free_page (page_entry *entry)
 static void
 release_pages (void)
 {
+  size_t n1 = 0;
+  size_t n2 = 0;
 #ifdef USING_MADVISE
   page_entry *p, *start_p;
   char *start;
@@ -1061,6 +1063,7 @@ release_pages (void)
           else
             G.free_pages = p;
           G.bytes_mapped -= mapped_len;
+	  n1 += len;
 	  continue;
         }
       prev = newprev;
@@ -1092,6 +1095,7 @@ release_pages (void)
       /* Don't count those pages as mapped to not touch the garbage collector
          unnecessarily. */
       G.bytes_mapped -= len;
+      n2 += len;
       while (start_p != p)
         {
           start_p->discarded = true;
@@ -1124,6 +1128,7 @@ release_pages (void)
 	}
 
       munmap (start, len);
+      n1 += len;
       G.bytes_mapped -= len;
     }
 
@@ -1151,11 +1156,21 @@ release_pages (void)
       {
 	*gp = g->next;
 	G.bytes_mapped -= g->alloc_size;
+	n1 += g->alloc_size;
 	free (g->allocation);
       }
     else
       gp = &g->next;
 #endif
+  if (!quiet_flag && (n1 || n2))
+    {
+      fprintf (stderr, " {GC");
+      if (n1)
+	fprintf (stderr, " released %luk", (unsigned long)(n1 / 1024));
+      if (n2)
+	fprintf (stderr, " madv_dontneed %luk", (unsigned long)(n2 / 1024));
+      fprintf (stderr, "}");
+    }
 }
 
 /* This table provides a fast way to determine ceil(log_2(size)) for
@@ -2178,19 +2193,22 @@ ggc_collect (void)
     return;
 
   timevar_push (TV_GC);
-  if (!quiet_flag)
-    fprintf (stderr, " {GC %luk -> ", (unsigned long) G.allocated / 1024);
   if (GGC_DEBUG_LEVEL >= 2)
     fprintf (G.debug_file, "BEGIN COLLECTING\n");
 
   /* Zero the total allocated bytes.  This will be recalculated in the
      sweep phase.  */
+  size_t allocated = G.allocated;
   G.allocated = 0;
 
   /* Release the pages we freed the last time we collected, but didn't
      reuse in the interim.  */
   release_pages ();
 
+  /* Output this later so we do not interfere with release_pages.  */
+  if (!quiet_flag)
+    fprintf (stderr, " {GC %luk -> ", (unsigned long) allocated / 1024);
+
   /* Indicate that we've seen collections at this context depth.  */
   G.context_depth_collections = ((unsigned long)1 << (G.context_depth + 1)) - 1;
 
@@ -2221,9 +2239,25 @@ ggc_collect (void)
     fprintf (G.debug_file, "END COLLECTING\n");
 }
 
-/* Assume that all GGC memory is reachable and grow the limits for next collection.
-   With checking, trigger GGC so -Q compilation outputs how much of memory really is
-   reachable.  */
+/* Return free pages to the system.  */
+
+void
+ggc_trim ()
+{
+  timevar_push (TV_GC);
+  G.allocated = 0;
+  sweep_pages ();
+  release_pages ();
+  if (!quiet_flag)
+    fprintf (stderr, " {GC trimmed to %luk, %luk mapped}",
+	     (unsigned long) G.allocated / 1024,
+	     (unsigned long) G.bytes_mapped / 1024);
+  timevar_pop (TV_GC);
+}
+
+/* Assume that all GGC memory is reachable and grow the limits for next
+   collection.  With checking, trigger GGC so -Q compilation outputs how much
+   of memory really is reachable.  */
 
 void
 ggc_grow (void)
@@ -2556,6 +2590,9 @@ ggc_pch_read (FILE *f, void *addr)
 
   count_old_page_tables = G.by_depth_in_use;
 
+  if (fread (&d, sizeof (d), 1, f) != 1)
+    fatal_error (input_location, "cannot read PCH file: %m");
+
   /* We've just read in a PCH file.  So, every object that used to be
      allocated is now free.  */
   clear_marks ();
@@ -2584,8 +2621,6 @@ ggc_pch_read (FILE *f, void *addr)
 
   /* Allocate the appropriate page-table entries for the pages read from
      the PCH file.  */
-  if (fread (&d, sizeof (d), 1, f) != 1)
-    fatal_error (input_location, "can%'t read PCH file: %m");
 
   for (i = 0; i < NUM_ORDERS; i++)
     {
diff --git a/gcc/ggc.h b/gcc/ggc.h
index 60273f2e57d..31606dc843f 100644
--- a/gcc/ggc.h
+++ b/gcc/ggc.h
@@ -243,6 +243,9 @@ extern const char *ggc_alloc_string (const char *contents, int length
    function is called, not during allocations.  */
 extern void ggc_collect	(void);
 
+/* Return unused memory pages to the system.  */
+extern void ggc_trim (void);
+
 /* Assume that all GGC memory is reachable and grow the limits for next collection. */
 extern void ggc_grow (void);
 
diff --git a/gcc/gimple-fold.c b/gcc/gimple-fold.c
index f30818042ee..d00f1e2b035 100644
--- a/gcc/gimple-fold.c
+++ b/gcc/gimple-fold.c
@@ -6557,6 +6557,7 @@ gimple_fold_stmt_to_constant_1 (gimple *stmt, tree (*valueize) (tree),
 
 	fn = (*valueize) (gimple_call_fn (stmt));
 	if (TREE_CODE (fn) == ADDR_EXPR
+	    && TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL
 	    && fndecl_built_in_p (TREE_OPERAND (fn, 0))
 	    && gimple_builtin_call_types_compatible_p (stmt,
 						       TREE_OPERAND (fn, 0)))
diff --git a/gcc/gimple-streamer-out.c b/gcc/gimple-streamer-out.c
index 34b8d6fda7d..7185c07f36b 100644
--- a/gcc/gimple-streamer-out.c
+++ b/gcc/gimple-streamer-out.c
@@ -57,7 +57,7 @@ output_phi (struct output_block *ob, gphi *phi)
 /* Emit statement STMT on the main stream of output block OB.  */
 
 static void
-output_gimple_stmt (struct output_block *ob, gimple *stmt)
+output_gimple_stmt (struct output_block *ob, struct function *fn, gimple *stmt)
 {
   unsigned i;
   enum gimple_code code;
@@ -80,7 +80,7 @@ output_gimple_stmt (struct output_block *ob, gimple *stmt)
 		     as_a <gassign *> (stmt)),
 		   1);
   bp_pack_value (&bp, gimple_has_volatile_ops (stmt), 1);
-  hist = gimple_histogram_value (cfun, stmt);
+  hist = gimple_histogram_value (fn, stmt);
   bp_pack_value (&bp, hist != NULL, 1);
   bp_pack_var_len_unsigned (&bp, stmt->subcode);
 
@@ -139,7 +139,7 @@ output_gimple_stmt (struct output_block *ob, gimple *stmt)
 	     so that we do not have to deal with type mismatches on
 	     merged symbols during IL read in.  The first operand
 	     of GIMPLE_DEBUG must be a decl, not MEM_REF, though.  */
-	  if (op && (i || !is_gimple_debug (stmt)))
+	  if (!flag_wpa && op && (i || !is_gimple_debug (stmt)))
 	    {
 	      basep = &op;
 	      if (TREE_CODE (*basep) == ADDR_EXPR)
@@ -147,7 +147,7 @@ output_gimple_stmt (struct output_block *ob, gimple *stmt)
 	      while (handled_component_p (*basep))
 		basep = &TREE_OPERAND (*basep, 0);
 	      if (VAR_P (*basep)
-		  && !auto_var_in_fn_p (*basep, current_function_decl)
+		  && !auto_var_in_fn_p (*basep, fn->decl)
 		  && !DECL_REGISTER (*basep))
 		{
 		  bool volatilep = TREE_THIS_VOLATILE (*basep);
@@ -228,7 +228,7 @@ output_bb (struct output_block *ob, basic_block bb, struct function *fn)
 	      print_gimple_stmt (streamer_dump_file, stmt, 0, TDF_SLIM);
 	    }
 
-	  output_gimple_stmt (ob, stmt);
+	  output_gimple_stmt (ob, fn, stmt);
 
 	  /* Emit the EH region holding STMT.  */
 	  region = lookup_stmt_eh_lp_fn (fn, stmt);
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index 98408b981dc..a0cb6c402bc 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -7058,6 +7058,8 @@ omp_default_clause (struct gimplify_omp_ctx *ctx, tree decl,
   kind = lang_hooks.decls.omp_predetermined_sharing (decl);
   if (kind != OMP_CLAUSE_DEFAULT_UNSPECIFIED)
     default_kind = kind;
+  else if (VAR_P (decl) && TREE_STATIC (decl) && DECL_IN_CONSTANT_POOL (decl))
+    default_kind = OMP_CLAUSE_DEFAULT_SHARED;
 
   switch (default_kind)
     {
@@ -8716,8 +8718,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,
 			      break;
 			    if (scp)
 			      continue;
-			    gcc_assert (offset == NULL_TREE
-					|| poly_int_tree_p (offset));
+			    gcc_assert (offset2 == NULL_TREE
+					|| poly_int_tree_p (offset2));
 			    tree d1 = OMP_CLAUSE_DECL (*sc);
 			    tree d2 = OMP_CLAUSE_DECL (c);
 			    while (TREE_CODE (d1) == ARRAY_REF)
diff --git a/gcc/go/gofrontend/expressions.cc b/gcc/go/gofrontend/expressions.cc
index 6f9775dd5a2..859c1ece5da 100644
--- a/gcc/go/gofrontend/expressions.cc
+++ b/gcc/go/gofrontend/expressions.cc
@@ -2036,7 +2036,11 @@ class Integer_expression : public Expression
 
   int
   do_inlining_cost() const
-  { return 1; }
+  {
+    if (this->type_ != NULL && this->type_->named_type() != NULL)
+      return 0x100000;
+    return 1; 
+  }
 
   void
   do_export(Export_function_body*) const;
@@ -2451,7 +2455,11 @@ class Float_expression : public Expression
 
   int
   do_inlining_cost() const
-  { return 1; }
+  {
+    if (this->type_ != NULL && this->type_->named_type() != NULL)
+      return 0x100000;
+    return 1;
+  }
 
   void
   do_export(Export_function_body*) const;
@@ -2664,7 +2672,11 @@ class Complex_expression : public Expression
 
   int
   do_inlining_cost() const
-  { return 2; }
+  {
+    if (this->type_ != NULL && this->type_->named_type() != NULL)
+      return 0x100000;
+    return 2;
+  }
 
   void
   do_export(Export_function_body*) const;
diff --git a/gcc/ipa-cp.c b/gcc/ipa-cp.c
index 32b352328a9..d414632e602 100644
--- a/gcc/ipa-cp.c
+++ b/gcc/ipa-cp.c
@@ -5190,4 +5190,5 @@ ipa_cp_c_finalize (void)
   max_count = profile_count::uninitialized ();
   overall_size = 0;
   max_new_size = 0;
+  ipcp_free_transformation_sum ();
 }
diff --git a/gcc/ipa-prop.c b/gcc/ipa-prop.c
index d86c2f3db55..848180aa441 100644
--- a/gcc/ipa-prop.c
+++ b/gcc/ipa-prop.c
@@ -3725,6 +3725,18 @@ ipcp_transformation_initialize (void)
     ipcp_transformation_sum = ipcp_transformation_t::create_ggc (symtab);
 }
 
+/* Release the IPA CP transformation summary.  */
+
+void
+ipcp_free_transformation_sum (void)
+{
+  if (!ipcp_transformation_sum)
+    return;
+
+  ipcp_transformation_sum->release ();
+  ipcp_transformation_sum = NULL;
+}
+
 /* Set the aggregate replacements of NODE to be AGGVALS.  */
 
 void
diff --git a/gcc/ipa-prop.h b/gcc/ipa-prop.h
index 7257a6d04f1..5ab3d07a6de 100644
--- a/gcc/ipa-prop.h
+++ b/gcc/ipa-prop.h
@@ -558,6 +558,7 @@ struct GTY(()) ipcp_transformation
 void ipa_set_node_agg_value_chain (struct cgraph_node *node,
 				   struct ipa_agg_replacement_value *aggvals);
 void ipcp_transformation_initialize (void);
+void ipcp_free_transformation_sum (void);
 
 /* ipa_edge_args stores information related to a callsite and particularly its
    arguments.  It can be accessed by the IPA_EDGE_REF macro.  */
diff --git a/gcc/ira.c b/gcc/ira.c
index fd481d6e0e2..b330f2a287b 100644
--- a/gcc/ira.c
+++ b/gcc/ira.c
@@ -5198,6 +5198,8 @@ ira (FILE *f)
   int ira_max_point_before_emit;
   bool saved_flag_caller_saves = flag_caller_saves;
   enum ira_region saved_flag_ira_region = flag_ira_region;
+  unsigned int i;
+  int num_used_regs = 0;
 
   clear_bb_flags ();
 
@@ -5213,12 +5215,17 @@ ira (FILE *f)
 
   ira_conflicts_p = optimize > 0;
 
+  /* Determine the number of pseudos actually requiring coloring.  */
+  for (i = FIRST_PSEUDO_REGISTER; i < DF_REG_SIZE (df); i++)
+    num_used_regs += !!(DF_REG_USE_COUNT (i) + DF_REG_DEF_COUNT (i));
+
   /* If there are too many pseudos and/or basic blocks (e.g. 10K
      pseudos and 10K blocks or 100K pseudos and 1K blocks), we will
      use simplified and faster algorithms in LRA.  */
   lra_simple_p
     = (ira_use_lra_p
-       && max_reg_num () >= (1 << 26) / last_basic_block_for_fn (cfun));
+       && num_used_regs >= (1 << 26) / last_basic_block_for_fn (cfun));
+
   if (lra_simple_p)
     {
       /* It permits to skip live range splitting in LRA.  */
diff --git a/gcc/lra-int.h b/gcc/lra-int.h
index d0a8facc50e..253ae1e6cb0 100644
--- a/gcc/lra-int.h
+++ b/gcc/lra-int.h
@@ -401,6 +401,7 @@ extern bool lra_coalesce (void);
 
 /* lra-spills.c:  */
 
+extern bool lra_need_for_scratch_reg_p (void);
 extern bool lra_need_for_spills_p (void);
 extern void lra_spill (void);
 extern void lra_final_code_change (void);
diff --git a/gcc/lra-remat.c b/gcc/lra-remat.c
index 10838116143..69209b2a18d 100644
--- a/gcc/lra-remat.c
+++ b/gcc/lra-remat.c
@@ -1020,7 +1020,6 @@ get_hard_regs (struct lra_insn_reg *reg, int &nregs)
 static void
 update_scratch_ops (rtx_insn *remat_insn)
 {
-  int hard_regno;
   lra_insn_recog_data_t id = lra_get_insn_recog_data (remat_insn);
   struct lra_static_insn_data *static_id = id->insn_static_data;
   for (int i = 0; i < static_id->n_operands; i++)
@@ -1031,17 +1030,9 @@ update_scratch_ops (rtx_insn *remat_insn)
       int regno = REGNO (*loc);
       if (! lra_former_scratch_p (regno))
 	continue;
-      hard_regno = reg_renumber[regno];
       *loc = lra_create_new_reg (GET_MODE (*loc), *loc,
 				 lra_get_allocno_class (regno),
 				 "scratch pseudo copy");
-      if (hard_regno >= 0)
-	{
-	  reg_renumber[REGNO (*loc)] = hard_regno;
-	  if (lra_dump_file)
-	    fprintf (lra_dump_file, "	 Assigning the same %d to r%d\n",
-		     REGNO (*loc), hard_regno);
-	}
       lra_register_new_scratch_op (remat_insn, i, id->icode);
     }
   
diff --git a/gcc/lra-spills.c b/gcc/lra-spills.c
index c19b76a579c..7a49c0779b8 100644
--- a/gcc/lra-spills.c
+++ b/gcc/lra-spills.c
@@ -548,6 +548,19 @@ spill_pseudos (void)
     }
 }
 
+/* Return true if we need scratch reg assignments.  */
+bool
+lra_need_for_scratch_reg_p (void)
+{
+  int i; max_regno = max_reg_num ();
+
+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)
+    if (lra_reg_info[i].nrefs != 0 && lra_get_regno_hard_regno (i) < 0
+	&& lra_former_scratch_p (i))
+      return true;
+  return false;
+}
+
 /* Return true if we need to change some pseudos into memory.  */
 bool
 lra_need_for_spills_p (void)
diff --git a/gcc/lra.c b/gcc/lra.c
index bef2f676a78..1d2578f8c12 100644
--- a/gcc/lra.c
+++ b/gcc/lra.c
@@ -2587,7 +2587,11 @@ lra (FILE *f)
 	  lra_create_live_ranges (lra_reg_spill_p, true);
 	  live_p = true;
 	  if (! lra_need_for_spills_p ())
-	    break;
+	    {
+	      if (lra_need_for_scratch_reg_p ())
+		continue;
+	      break;
+	    }
 	}
       lra_spill ();
       /* Assignment of stack slots changes elimination offsets for
diff --git a/gcc/lto-streamer-out.c b/gcc/lto-streamer-out.c
index b6e395b53fd..42f382ecf21 100644
--- a/gcc/lto-streamer-out.c
+++ b/gcc/lto-streamer-out.c
@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "debug.h"
 #include "omp-offload.h"
 #include "print-tree.h"
+#include "tree-dfa.h"
 
 
 static void lto_write_tree (struct output_block*, tree, bool);
@@ -1891,7 +1892,7 @@ output_cfg (struct output_block *ob, struct function *fn)
 
   streamer_write_hwi (ob, -1);
 
-  bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);
+  bb = ENTRY_BLOCK_PTR_FOR_FN (fn);
   while (bb->next_bb)
     {
       streamer_write_hwi (ob, bb->next_bb->index);
@@ -1900,9 +1901,6 @@ output_cfg (struct output_block *ob, struct function *fn)
 
   streamer_write_hwi (ob, -1);
 
-  /* ???  The cfgloop interface is tied to cfun.  */
-  gcc_assert (cfun == fn);
-
   /* Output the number of loops.  */
   streamer_write_uhwi (ob, number_of_loops (fn));
 
@@ -2063,6 +2061,62 @@ collect_block_tree_leafs (tree root, vec<tree> &leafs)
       collect_block_tree_leafs (BLOCK_SUBBLOCKS (root), leafs);
 }
 
+/* This performs function body modifications that are needed for streaming
+   to work.  */
+
+void
+lto_prepare_function_for_streaming (struct cgraph_node *node)
+{
+  struct function *fn = DECL_STRUCT_FUNCTION (node->decl);
+  basic_block bb;
+
+  if (number_of_loops (fn))
+    {
+      push_cfun (fn);
+      loop_optimizer_init (AVOID_CFG_MODIFICATIONS);
+      loop_optimizer_finalize ();
+      pop_cfun ();
+    }
+  /* We will renumber the statements.  The code that does this uses
+     the same ordering that we use for serializing them so we can use
+     the same code on the other end and not have to write out the
+     statement numbers.  We do not assign UIDs to PHIs here because
+     virtual PHIs get re-computed on-the-fly which would make numbers
+     inconsistent.  */
+  set_gimple_stmt_max_uid (fn, 0);
+  FOR_ALL_BB_FN (bb, fn)
+    {
+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
+	   gsi_next (&gsi))
+	{
+	  gphi *stmt = gsi.phi ();
+
+	  /* Virtual PHIs are not going to be streamed.  */
+	  if (!virtual_operand_p (gimple_phi_result (stmt)))
+	    gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));
+	}
+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);
+	   gsi_next (&gsi))
+	{
+	  gimple *stmt = gsi_stmt (gsi);
+	  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));
+	}
+    }
+  /* To avoid keeping duplicate gimple IDs in the statements, renumber
+     virtual phis now.  */
+  FOR_ALL_BB_FN (bb, fn)
+    {
+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
+	   gsi_next (&gsi))
+	{
+	  gphi *stmt = gsi.phi ();
+	  if (virtual_operand_p (gimple_phi_result (stmt)))
+	    gimple_set_uid (stmt, inc_gimple_stmt_max_uid (fn));
+	}
+    }
+
+}
+
 /* Output the body of function NODE->DECL.  */
 
 static void
@@ -2086,9 +2140,6 @@ output_function (struct cgraph_node *node)
 
   gcc_assert (current_function_decl == NULL_TREE && cfun == NULL);
 
-  /* Set current_function_decl and cfun.  */
-  push_cfun (fn);
-
   /* Make string 0 be a NULL string.  */
   streamer_write_char_stream (ob->string_stream, 0);
 
@@ -2125,9 +2176,6 @@ output_function (struct cgraph_node *node)
      debug info.  */
   if (gimple_has_body_p (function))
     {
-      /* Fixup loops if required to match discovery done in the reader.  */
-      loop_optimizer_init (AVOID_CFG_MODIFICATIONS);
-
       streamer_write_uhwi (ob, 1);
       output_struct_function_base (ob, fn);
 
@@ -2137,45 +2185,6 @@ output_function (struct cgraph_node *node)
       /* Output any exception handling regions.  */
       output_eh_regions (ob, fn);
 
-
-      /* We will renumber the statements.  The code that does this uses
-	 the same ordering that we use for serializing them so we can use
-	 the same code on the other end and not have to write out the
-	 statement numbers.  We do not assign UIDs to PHIs here because
-	 virtual PHIs get re-computed on-the-fly which would make numbers
-	 inconsistent.  */
-      set_gimple_stmt_max_uid (cfun, 0);
-      FOR_ALL_BB_FN (bb, cfun)
-	{
-	  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
-	       gsi_next (&gsi))
-	    {
-	      gphi *stmt = gsi.phi ();
-
-	      /* Virtual PHIs are not going to be streamed.  */
-	      if (!virtual_operand_p (gimple_phi_result (stmt)))
-	        gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));
-	    }
-	  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);
-	       gsi_next (&gsi))
-	    {
-	      gimple *stmt = gsi_stmt (gsi);
-	      gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));
-	    }
-	}
-      /* To avoid keeping duplicate gimple IDs in the statements, renumber
-	 virtual phis now.  */
-      FOR_ALL_BB_FN (bb, cfun)
-	{
-	  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);
-	       gsi_next (&gsi))
-	    {
-	      gphi *stmt = gsi.phi ();
-	      if (virtual_operand_p (gimple_phi_result (stmt)))
-	        gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));
-	    }
-	}
-
       /* Output the code for the function.  */
       FOR_ALL_BB_FN (bb, fn)
 	output_bb (ob, bb, fn);
@@ -2184,9 +2193,6 @@ output_function (struct cgraph_node *node)
       streamer_write_record_start (ob, LTO_null);
 
       output_cfg (ob, fn);
-
-      loop_optimizer_finalize ();
-      pop_cfun ();
    }
   else
     streamer_write_uhwi (ob, 0);
@@ -2617,12 +2623,6 @@ write_symbol (struct streamer_tree_cache_d *cache,
   const char *comdat;
   unsigned char c;
 
-  gcc_checking_assert (TREE_PUBLIC (t)
-		       && (TREE_CODE (t) != FUNCTION_DECL
-			   || !fndecl_built_in_p (t))
-		       && !DECL_ABSTRACT_P (t)
-		       && (!VAR_P (t) || !DECL_HARD_REGISTER (t)));
-
   gcc_assert (VAR_OR_FUNCTION_DECL_P (t));
 
   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (t));
diff --git a/gcc/lto-streamer.h b/gcc/lto-streamer.h
index 04b79dbce3b..ac3ecc9e5ed 100644
--- a/gcc/lto-streamer.h
+++ b/gcc/lto-streamer.h
@@ -879,6 +879,7 @@ void lto_output_decl_state_refs (struct output_block *,
 			         struct lto_out_decl_state *);
 void lto_output_location (struct output_block *, struct bitpack_d *, location_t);
 void lto_output_init_mode_table (void);
+void lto_prepare_function_for_streaming (cgraph_node *);
 
 
 /* In lto-cgraph.c  */
diff --git a/gcc/lto-wrapper.c b/gcc/lto-wrapper.c
index ac971494054..10bd7c9becb 100644
--- a/gcc/lto-wrapper.c
+++ b/gcc/lto-wrapper.c
@@ -128,12 +128,11 @@ maybe_unlink (const char *file)
 #define DUMPBASE_SUFFIX ".ltrans18446744073709551615"
 
 /* Create decoded options from the COLLECT_GCC and COLLECT_GCC_OPTIONS
-   environment according to LANG_MASK.  */
+   environment.  */
 
 static void
 get_options_from_collect_gcc_options (const char *collect_gcc,
 				      const char *collect_gcc_options,
-				      unsigned int lang_mask,
 				      struct cl_decoded_option **decoded_options,
 				      unsigned int *decoded_options_count)
 {
@@ -175,8 +174,7 @@ get_options_from_collect_gcc_options (const char *collect_gcc,
   argc = obstack_object_size (&argv_obstack) / sizeof (void *) - 1;
   argv = XOBFINISH (&argv_obstack, const char **);
 
-  decode_cmdline_options_to_array (argc, (const char **)argv,
-				   lang_mask,
+  decode_cmdline_options_to_array (argc, (const char **)argv, CL_DRIVER,
 				   decoded_options, decoded_options_count);
   obstack_free (&argv_obstack, NULL);
 }
@@ -1008,8 +1006,7 @@ find_and_merge_options (int fd, off_t file_offset, const char *prefix,
     {
       struct cl_decoded_option *f2decoded_options;
       unsigned int f2decoded_options_count;
-      get_options_from_collect_gcc_options (collect_gcc,
-					    fopts, CL_LANG_ALL,
+      get_options_from_collect_gcc_options (collect_gcc, fopts,
 					    &f2decoded_options,
 					    &f2decoded_options_count);
       if (!fdecoded_options)
@@ -1150,7 +1147,6 @@ run_gcc (unsigned argc, char *argv[])
     fatal_error (input_location,
 		 "environment variable COLLECT_GCC_OPTIONS must be set");
   get_options_from_collect_gcc_options (collect_gcc, collect_gcc_options,
-					CL_LANG_ALL,
 					&decoded_options,
 					&decoded_options_count);
 
diff --git a/gcc/lto/ChangeLog b/gcc/lto/ChangeLog
index eb2653be616..e381db79f17 100644
--- a/gcc/lto/ChangeLog
+++ b/gcc/lto/ChangeLog
@@ -1,3 +1,28 @@
+2019-11-08  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/92231
+	* lto-lang.c (handle_const_attribute): Don't call fndecl_built_in_p
+	on *node that is not FUNCTION_DECL.
+
+2019-10-26  Jan Hubicka  <hubicka@ucw.cz>
+
+	Backport from mainline
+
+	2019-10-12  Jan Hubicka  <hubicka@ucw.cz>
+	* lto.c (lto_wpa_write_files): Do not update bodies of clones.
+
+	2019-10-11  Jan Hubicka  <hubicka@ucw.cz>
+	* lto.c (lto_wpa_write_files): Prepare all bodies for streaming.
+
+2019-10-25  Jan Hubicka  <hubicka@ucw.cz>
+
+	Backport from mainline
+	* lto-partition.c (add_symbol_to_partition_1): Update.
+	(undo_parittion): Update.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/gcc/lto/lto-lang.c b/gcc/lto/lto-lang.c
index 5a35d4794c2..4ef228fcb45 100644
--- a/gcc/lto/lto-lang.c
+++ b/gcc/lto/lto-lang.c
@@ -303,7 +303,8 @@ handle_const_attribute (tree *node, tree ARG_UNUSED (name),
 			tree ARG_UNUSED (args), int ARG_UNUSED (flags),
 			bool * ARG_UNUSED (no_add_attrs))
 {
-  if (!fndecl_built_in_p (*node))
+  if (TREE_CODE (*node) != FUNCTION_DECL
+      || !fndecl_built_in_p (*node))
     inform (UNKNOWN_LOCATION, "%s:%s: %E: %E", __FILE__, __func__, *node, name);
 
   tree type = TREE_TYPE (*node);
diff --git a/gcc/lto/lto.c b/gcc/lto/lto.c
index 4367928a515..4dde8c001e1 100644
--- a/gcc/lto/lto.c
+++ b/gcc/lto/lto.c
@@ -2446,6 +2446,15 @@ lto_wpa_write_files (void)
 
   timevar_push (TV_WHOPR_WPA_IO);
 
+  ggc_trim ();
+
+  cgraph_node *node;
+  /* Do body modifications needed for streaming before we fork out
+     worker processes.  */
+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)
+    if (!node->clone_of && gimple_has_body_p (node->decl))
+      lto_prepare_function_for_streaming (node);
+
   /* Generate a prefix for the LTRANS unit files.  */
   blen = strlen (ltrans_output_list);
   temp_filename = (char *) xmalloc (blen + sizeof ("2147483648.o"));
diff --git a/gcc/match.pd b/gcc/match.pd
index 039ddacfed1..bd3e3bf1ae9 100644
--- a/gcc/match.pd
+++ b/gcc/match.pd
@@ -1519,8 +1519,6 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
 	tree etype = range_check_type (TREE_TYPE (@0));
 	if (etype)
 	  {
-	    if (! TYPE_UNSIGNED (etype))
-	      etype = unsigned_type_for (etype);
 	    hi = fold_convert (etype, hi);
 	    lo = fold_convert (etype, lo);
 	    hi = const_binop (MINUS_EXPR, etype, hi, lo);
@@ -3381,8 +3379,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
      (cmp { tem; } @1)))))
 
  /* Fold comparisons against built-in math functions.  */
- (if (flag_unsafe_math_optimizations
-      && ! flag_errno_math)
+ (if (flag_unsafe_math_optimizations && ! flag_errno_math)
   (for sq (SQRT)
    (simplify
     (cmp (sq @0) REAL_CST@1)
@@ -3417,56 +3414,108 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
 	  if x is negative or NaN.  Due to -funsafe-math-optimizations,
 	  the results for other x follow from natural arithmetic.  */
        (cmp @0 @1)))
-     (if (cmp == GT_EXPR || cmp == GE_EXPR)
+     (if ((cmp == LT_EXPR
+	   || cmp == LE_EXPR
+	   || cmp == GT_EXPR
+	   || cmp == GE_EXPR)
+	  && !REAL_VALUE_ISNAN (TREE_REAL_CST (@1))
+	  /* Give up for -frounding-math.  */
+	  && !HONOR_SIGN_DEPENDENT_ROUNDING (TREE_TYPE (@0)))
       (with
        {
-         REAL_VALUE_TYPE c2;
+	 REAL_VALUE_TYPE c2;
+	 enum tree_code ncmp = cmp;
+	 const real_format *fmt
+	   = REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (@0)));
 	 real_arithmetic (&c2, MULT_EXPR,
 			  &TREE_REAL_CST (@1), &TREE_REAL_CST (@1));
-	 real_convert (&c2, TYPE_MODE (TREE_TYPE (@0)), &c2);
-       }
-       (if (REAL_VALUE_ISINF (c2))
-	/* sqrt(x) > y is x == +Inf, when y is very large.  */
-	(if (HONOR_INFINITIES (@0))
-	 (eq @0 { build_real (TREE_TYPE (@0), c2); })
-	 { constant_boolean_node (false, type); })
-	/* sqrt(x) > c is the same as x > c*c.  */
-	(cmp @0 { build_real (TREE_TYPE (@0), c2); }))))
-     (if (cmp == LT_EXPR || cmp == LE_EXPR)
-      (with
-       {
-       	 REAL_VALUE_TYPE c2;
-	 real_arithmetic (&c2, MULT_EXPR,
-			  &TREE_REAL_CST (@1), &TREE_REAL_CST (@1));
-	 real_convert (&c2, TYPE_MODE (TREE_TYPE (@0)), &c2);
+	 real_convert (&c2, fmt, &c2);
+	 /* See PR91734: if c2 is inexact and sqrt(c2) < c (or sqrt(c2) >= c),
+	    then change LT_EXPR into LE_EXPR or GE_EXPR into GT_EXPR.  */
+	 if (!REAL_VALUE_ISINF (c2))
+	   {
+	     tree c3 = fold_const_call (CFN_SQRT, TREE_TYPE (@0),
+					build_real (TREE_TYPE (@0), c2));
+	     if (c3 == NULL_TREE || TREE_CODE (c3) != REAL_CST)
+	       ncmp = ERROR_MARK;
+	     else if ((cmp == LT_EXPR || cmp == GE_EXPR)
+		      && real_less (&TREE_REAL_CST (c3), &TREE_REAL_CST (@1)))
+	       ncmp = cmp == LT_EXPR ? LE_EXPR : GT_EXPR;
+	     else if ((cmp == LE_EXPR || cmp == GT_EXPR)
+		      && real_less (&TREE_REAL_CST (@1), &TREE_REAL_CST (c3)))
+	       ncmp = cmp == LE_EXPR ? LT_EXPR : GE_EXPR;
+	     else
+	       {
+		 /* With rounding to even, sqrt of up to 3 different values
+		    gives the same normal result, so in some cases c2 needs
+		    to be adjusted.  */
+		 REAL_VALUE_TYPE c2alt, tow;
+		 if (cmp == LT_EXPR || cmp == GE_EXPR)
+		   tow = dconst0;
+		 else
+		   real_inf (&tow);
+		 real_nextafter (&c2alt, fmt, &c2, &tow);
+		 real_convert (&c2alt, fmt, &c2alt);
+		 if (REAL_VALUE_ISINF (c2alt))
+		   ncmp = ERROR_MARK;
+		 else
+		   {
+		     c3 = fold_const_call (CFN_SQRT, TREE_TYPE (@0),
+					   build_real (TREE_TYPE (@0), c2alt));
+		     if (c3 == NULL_TREE || TREE_CODE (c3) != REAL_CST)
+		       ncmp = ERROR_MARK;
+		     else if (real_equal (&TREE_REAL_CST (c3),
+					  &TREE_REAL_CST (@1)))
+		       c2 = c2alt;
+		   }
+	       }
+	   }
        }
-       (if (REAL_VALUE_ISINF (c2))
-        (switch
-	 /* sqrt(x) < y is always true, when y is a very large
-	    value and we don't care about NaNs or Infinities.  */
-	 (if (! HONOR_NANS (@0) && ! HONOR_INFINITIES (@0))
-	  { constant_boolean_node (true, type); })
-	 /* sqrt(x) < y is x != +Inf when y is very large and we
-	    don't care about NaNs.  */
-	 (if (! HONOR_NANS (@0))
-	  (ne @0 { build_real (TREE_TYPE (@0), c2); }))
-	 /* sqrt(x) < y is x >= 0 when y is very large and we
-	    don't care about Infinities.  */
-	 (if (! HONOR_INFINITIES (@0))
-	  (ge @0 { build_real (TREE_TYPE (@0), dconst0); }))
-	 /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */
-	 (if (GENERIC)
-	  (truth_andif
-	   (ge @0 { build_real (TREE_TYPE (@0), dconst0); })
-	   (ne @0 { build_real (TREE_TYPE (@0), c2); }))))
-	/* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */
-	(if (! HONOR_NANS (@0))
-	 (cmp @0 { build_real (TREE_TYPE (@0), c2); })
-	 /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */
-	 (if (GENERIC)
-	  (truth_andif
-	   (ge @0 { build_real (TREE_TYPE (@0), dconst0); })
-	   (cmp @0 { build_real (TREE_TYPE (@0), c2); })))))))))
+       (if (cmp == GT_EXPR || cmp == GE_EXPR)
+	(if (REAL_VALUE_ISINF (c2))
+	 /* sqrt(x) > y is x == +Inf, when y is very large.  */
+	 (if (HONOR_INFINITIES (@0))
+	  (eq @0 { build_real (TREE_TYPE (@0), c2); })
+	  { constant_boolean_node (false, type); })
+	 /* sqrt(x) > c is the same as x > c*c.  */
+	 (if (ncmp != ERROR_MARK)
+	  (if (ncmp == GE_EXPR)
+	   (ge @0 { build_real (TREE_TYPE (@0), c2); })
+	   (gt @0 { build_real (TREE_TYPE (@0), c2); }))))
+	/* else if (cmp == LT_EXPR || cmp == LE_EXPR)  */
+	(if (REAL_VALUE_ISINF (c2))
+	 (switch
+	  /* sqrt(x) < y is always true, when y is a very large
+	     value and we don't care about NaNs or Infinities.  */
+	  (if (! HONOR_NANS (@0) && ! HONOR_INFINITIES (@0))
+	   { constant_boolean_node (true, type); })
+	  /* sqrt(x) < y is x != +Inf when y is very large and we
+	     don't care about NaNs.  */
+	  (if (! HONOR_NANS (@0))
+	   (ne @0 { build_real (TREE_TYPE (@0), c2); }))
+	  /* sqrt(x) < y is x >= 0 when y is very large and we
+	     don't care about Infinities.  */
+	  (if (! HONOR_INFINITIES (@0))
+	   (ge @0 { build_real (TREE_TYPE (@0), dconst0); }))
+	  /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */
+	  (if (GENERIC)
+	   (truth_andif
+	    (ge @0 { build_real (TREE_TYPE (@0), dconst0); })
+	    (ne @0 { build_real (TREE_TYPE (@0), c2); }))))
+	 /* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */
+	 (if (ncmp != ERROR_MARK && ! HONOR_NANS (@0))
+	  (if (ncmp == LT_EXPR)
+	   (lt @0 { build_real (TREE_TYPE (@0), c2); })
+	   (le @0 { build_real (TREE_TYPE (@0), c2); }))
+	  /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */
+	  (if (ncmp != ERROR_MARK && GENERIC)
+	   (if (ncmp == LT_EXPR)
+	    (truth_andif
+	     (ge @0 { build_real (TREE_TYPE (@0), dconst0); })
+	     (lt @0 { build_real (TREE_TYPE (@0), c2); }))
+	    (truth_andif
+	     (ge @0 { build_real (TREE_TYPE (@0), dconst0); })
+	     (le @0 { build_real (TREE_TYPE (@0), c2); })))))))))))
    /* Transform sqrt(x) cmp sqrt(y) -> x cmp y.  */
    (simplify
     (cmp (sq @0) (sq @1))
diff --git a/gcc/omp-simd-clone.c b/gcc/omp-simd-clone.c
index 472e2025e19..845443efc59 100644
--- a/gcc/omp-simd-clone.c
+++ b/gcc/omp-simd-clone.c
@@ -498,7 +498,6 @@ simd_clone_adjust_return_type (struct cgraph_node *node)
   /* Adjust the function return type.  */
   if (orig_rettype == void_type_node)
     return NULL_TREE;
-  TREE_TYPE (fndecl) = build_distinct_type_copy (TREE_TYPE (fndecl));
   t = TREE_TYPE (TREE_TYPE (fndecl));
   if (INTEGRAL_TYPE_P (t) || POINTER_TYPE_P (t))
     veclen = node->simdclone->vecsize_int;
@@ -724,11 +723,7 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)
 	  else
 	    new_reversed = void_list_node;
 	}
-
-      tree new_type = build_distinct_type_copy (TREE_TYPE (node->decl));
-      TYPE_ARG_TYPES (new_type) = new_reversed;
-      TREE_TYPE (node->decl) = new_type;
-
+      TYPE_ARG_TYPES (TREE_TYPE (node->decl)) = new_reversed;
       adjustments.release ();
     }
   args.release ();
@@ -1164,6 +1159,7 @@ simd_clone_adjust (struct cgraph_node *node)
 {
   push_cfun (DECL_STRUCT_FUNCTION (node->decl));
 
+  TREE_TYPE (node->decl) = build_distinct_type_copy (TREE_TYPE (node->decl));
   targetm.simd_clone.adjust (node);
 
   tree retval = simd_clone_adjust_return_type (node);
@@ -1737,6 +1733,8 @@ expand_simd_clones (struct cgraph_node *node)
 	    simd_clone_adjust (n);
 	  else
 	    {
+	      TREE_TYPE (n->decl)
+		= build_distinct_type_copy (TREE_TYPE (n->decl));
 	      targetm.simd_clone.adjust (n);
 	      simd_clone_adjust_return_type (n);
 	      simd_clone_adjust_argument_types (n);
diff --git a/gcc/optabs.c b/gcc/optabs.c
index a0e361b8bfe..7d7efe0a4a2 100644
--- a/gcc/optabs.c
+++ b/gcc/optabs.c
@@ -5819,6 +5819,25 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,
   icode = get_vcond_icode (mode, cmp_op_mode, unsignedp);
   if (icode == CODE_FOR_nothing)
     {
+      if (tcode == LT_EXPR
+	  && op0a == op0
+	  && TREE_CODE (op0) == VECTOR_CST)
+	{
+	  /* A VEC_COND_EXPR condition could be folded from EQ_EXPR/NE_EXPR
+	     into a constant when only get_vcond_eq_icode is supported.
+	     Verify < 0 and != 0 behave the same and change it to NE_EXPR.  */
+	  unsigned HOST_WIDE_INT nelts;
+	  if (!VECTOR_CST_NELTS (op0).is_constant (&nelts))
+	    {
+	      if (VECTOR_CST_STEPPED_P (op0))
+		return 0;
+	      nelts = vector_cst_encoded_nelts (op0);
+	    }
+	  for (unsigned int i = 0; i < nelts; ++i)
+	    if (tree_int_cst_sgn (vector_cst_elt (op0, i)) == 1)
+	      return 0;
+	  tcode = NE_EXPR;
+	}
       if (tcode == EQ_EXPR || tcode == NE_EXPR)
 	icode = get_vcond_eq_icode (mode, cmp_op_mode);
       if (icode == CODE_FOR_nothing)
diff --git a/gcc/optc-save-gen.awk b/gcc/optc-save-gen.awk
index 74096bc5462..cf1c3689eff 100644
--- a/gcc/optc-save-gen.awk
+++ b/gcc/optc-save-gen.awk
@@ -332,7 +332,7 @@ for (i = 0; i < n_opt_string; i++) {
 	print "             indent_to, \"\",";
 	print "             \"" name "\",";
 	print "             ptr1->x_" name " ? ptr1->x_" name " : \"(null)\",";
-	print "             ptr2->x_" name " ? ptr1->x_" name " : \"(null)\");";
+	print "             ptr2->x_" name " ? ptr2->x_" name " : \"(null)\");";
 	print "";
 }
 
diff --git a/gcc/passes.c b/gcc/passes.c
index d8d479a1c17..e071a878301 100644
--- a/gcc/passes.c
+++ b/gcc/passes.c
@@ -1646,24 +1646,39 @@ do_per_function (void (*callback) (function *, void *data), void *data)
     }
 }
 
-/* Because inlining might remove no-longer reachable nodes, we need to
-   keep the array visible to garbage collector to avoid reading collected
-   out nodes.  */
-static int nnodes;
-static GTY ((length ("nnodes"))) cgraph_node **order;
-
-#define uid_hash_t hash_set<int_hash <int, 0, -1> >
-
 /* Hook called when NODE is removed and therefore should be
    excluded from order vector.  DATA is a hash set with removed nodes.  */
 
 static void
 remove_cgraph_node_from_order (cgraph_node *node, void *data)
 {
-  uid_hash_t *removed_nodes = (uid_hash_t *)data;
-  removed_nodes->add (node->get_uid ());
+  hash_set<cgraph_node *> *removed_nodes = (hash_set<cgraph_node *> *)data;
+  removed_nodes->add (node);
+}
+
+/* Hook called when NODE is insert and therefore should be
+   excluded from removed_nodes.  DATA is a hash set with removed nodes.  */
+
+static void
+insert_cgraph_node_to_order (cgraph_node *node, void *data)
+{
+  hash_set<cgraph_node *> *removed_nodes = (hash_set<cgraph_node *> *)data;
+  removed_nodes->remove (node);
+}
+
+/* Hook called when NODE is duplicated and therefore should be
+   excluded from removed_nodes.  DATA is a hash set with removed nodes.  */
+
+static void
+duplicate_cgraph_node_to_order (cgraph_node *node, cgraph_node *node2,
+				void *data)
+{
+  hash_set<cgraph_node *> *removed_nodes = (hash_set<cgraph_node *> *)data;
+  gcc_checking_assert (!removed_nodes->contains (node));
+  removed_nodes->remove (node2);
 }
 
+
 /* If we are in IPA mode (i.e., current_function_decl is NULL), call
    function CALLBACK for every function in the call graph.  Otherwise,
    call CALLBACK on the current function.
@@ -1677,26 +1692,30 @@ do_per_function_toporder (void (*callback) (function *, void *data), void *data)
     callback (cfun, data);
   else
     {
-      cgraph_node_hook_list *hook;
-      uid_hash_t removed_nodes;
-      gcc_assert (!order);
-      order = ggc_vec_alloc<cgraph_node *> (symtab->cgraph_count);
+      hash_set<cgraph_node *> removed_nodes;
+      unsigned nnodes = symtab->cgraph_count;
+      cgraph_node **order = XNEWVEC (cgraph_node *, nnodes);
 
       nnodes = ipa_reverse_postorder (order);
       for (i = nnodes - 1; i >= 0; i--)
 	order[i]->process = 1;
-      hook = symtab->add_cgraph_removal_hook (remove_cgraph_node_from_order,
-					      &removed_nodes);
+      cgraph_node_hook_list *removal_hook
+	= symtab->add_cgraph_removal_hook (remove_cgraph_node_from_order,
+					   &removed_nodes);
+      cgraph_node_hook_list *insertion_hook
+	= symtab->add_cgraph_insertion_hook (insert_cgraph_node_to_order,
+					     &removed_nodes);
+      cgraph_2node_hook_list *duplication_hook
+	= symtab->add_cgraph_duplication_hook (duplicate_cgraph_node_to_order,
+					       &removed_nodes);
       for (i = nnodes - 1; i >= 0; i--)
 	{
 	  cgraph_node *node = order[i];
 
 	  /* Function could be inlined and removed as unreachable.  */
-	  if (node == NULL || removed_nodes.contains (node->get_uid ()))
+	  if (node == NULL || removed_nodes.contains (node))
 	    continue;
 
-	  /* Allow possibly removed nodes to be garbage collected.  */
-	  order[i] = NULL;
 	  node->process = 0;
 	  if (node->has_gimple_body_p ())
 	    {
@@ -1706,11 +1725,12 @@ do_per_function_toporder (void (*callback) (function *, void *data), void *data)
 	      pop_cfun ();
 	    }
 	}
-      symtab->remove_cgraph_removal_hook (hook);
+      symtab->remove_cgraph_removal_hook (removal_hook);
+      symtab->remove_cgraph_insertion_hook (insertion_hook);
+      symtab->remove_cgraph_duplication_hook (duplication_hook);
+
+      free (order);
     }
-  ggc_free (order);
-  order = NULL;
-  nnodes = 0;
 }
 
 /* Helper function to perform function body dump.  */
@@ -2699,20 +2719,12 @@ ipa_write_summaries (void)
     {
       struct cgraph_node *node = order[i];
 
-      if (gimple_has_body_p (node->decl))
+      if (node->definition && node->need_lto_streaming)
 	{
-	  /* When streaming out references to statements as part of some IPA
-	     pass summary, the statements need to have uids assigned and the
-	     following does that for all the IPA passes here. Naturally, this
-	     ordering then matches the one IPA-passes get in their stmt_fixup
-	     hooks.  */
-
-	  push_cfun (DECL_STRUCT_FUNCTION (node->decl));
-	  renumber_gimple_stmt_uids ();
-	  pop_cfun ();
+	  if (gimple_has_body_p (node->decl))
+	    lto_prepare_function_for_streaming (node);
+	  lto_set_symtab_encoder_in_partition (encoder, node);
 	}
-      if (node->definition && node->need_lto_streaming)
-        lto_set_symtab_encoder_in_partition (encoder, node);
     }
 
   FOR_EACH_DEFINED_FUNCTION (node)
@@ -2780,28 +2792,13 @@ void
 ipa_write_optimization_summaries (lto_symtab_encoder_t encoder)
 {
   struct lto_out_decl_state *state = lto_new_out_decl_state ();
-  lto_symtab_encoder_iterator lsei;
   state->symtab_node_encoder = encoder;
 
   lto_output_init_mode_table ();
   lto_push_out_decl_state (state);
-  for (lsei = lsei_start_function_in_partition (encoder);
-       !lsei_end_p (lsei); lsei_next_function_in_partition (&lsei))
-    {
-      struct cgraph_node *node = lsei_cgraph_node (lsei);
-      /* When streaming out references to statements as part of some IPA
-	 pass summary, the statements need to have uids assigned.
-
-	 For functions newly born at WPA stage we need to initialize
-	 the uids here.  */
-      if (node->definition
-	  && gimple_has_body_p (node->decl))
-	{
-	  push_cfun (DECL_STRUCT_FUNCTION (node->decl));
-	  renumber_gimple_stmt_uids ();
-	  pop_cfun ();
-	}
-    }
+
+  /* Be sure that we did not forget to renumber stmt uids.  */
+  gcc_checking_assert (flag_wpa);
 
   gcc_assert (flag_wpa);
   pass_manager *passes = g->get_passes ();
@@ -3060,5 +3057,3 @@ function_called_by_processed_nodes_p (void)
     }
   return e != NULL;
 }
-
-#include "gt-passes.h"
diff --git a/gcc/passes.def b/gcc/passes.def
index bc147c4444d..9a859070b26 100644
--- a/gcc/passes.def
+++ b/gcc/passes.def
@@ -434,6 +434,7 @@ along with GCC; see the file COPYING3.  If not see
       NEXT_PASS (pass_ud_rtl_dce);
       NEXT_PASS (pass_combine);
       NEXT_PASS (pass_if_after_combine);
+      NEXT_PASS (pass_jump_after_combine);
       NEXT_PASS (pass_partition_blocks);
       NEXT_PASS (pass_outof_cfg_layout_mode);
       NEXT_PASS (pass_split_all_insns);
@@ -450,7 +451,6 @@ along with GCC; see the file COPYING3.  If not see
       NEXT_PASS (pass_reload);
       NEXT_PASS (pass_postreload);
       PUSH_INSERT_PASSES_WITHIN (pass_postreload)
-	  NEXT_PASS (pass_postreload_jump);
 	  NEXT_PASS (pass_postreload_cse);
 	  NEXT_PASS (pass_gcse2);
 	  NEXT_PASS (pass_split_after_reload);
diff --git a/gcc/po/ChangeLog b/gcc/po/ChangeLog
index e0186084236..bf3dc9c10ef 100644
--- a/gcc/po/ChangeLog
+++ b/gcc/po/ChangeLog
@@ -1,3 +1,23 @@
+2019-10-11  Joseph Myers  <joseph@codesourcery.com>
+
+	* fi.po: Update.
+
+2019-09-30  Joseph Myers  <joseph@codesourcery.com>
+
+	* es.po: Update.
+
+2019-08-31  Joseph Myers  <joseph@codesourcery.com>
+
+	* es.po: Update.
+
+2019-08-28  Joseph Myers  <joseph@codesourcery.com>
+
+	* es.po: Update.
+
+2019-08-23  Joseph Myers  <joseph@codesourcery.com>
+
+	* zh_CN.po: Update.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
diff --git a/gcc/po/es.po b/gcc/po/es.po
index 2f3a21984ac..c6eed017b3f 100644
--- a/gcc/po/es.po
+++ b/gcc/po/es.po
@@ -43,7 +43,7 @@ msgstr ""
 "Project-Id-Version: gcc 9.1.0\n"
 "Report-Msgid-Bugs-To: https://gcc.gnu.org/bugs/\n"
 "POT-Creation-Date: 2019-05-02 20:28+0000\n"
-"PO-Revision-Date: 2019-05-17 05:23+0200\n"
+"PO-Revision-Date: 2019-09-30 17:16+0200\n"
 "Last-Translator: Antonio Ceballos Roa <aceballos@gmail.com>\n"
 "Language-Team: Spanish <es@tp.org.es>\n"
 "Language: es\n"
@@ -174,17 +174,11 @@ msgstr "compilación terminada.\n"
 
 #: diagnostic.c:618
 msgid "In file included from"
-msgstr ""
+msgstr "En el fichero incluido desde"
 
 #: diagnostic.c:619
-#, fuzzy
-#| msgid ""
-#| ",\n"
-#| "                 from %s:%u"
 msgid "                 from"
-msgstr ""
-",\n"
-"                 de %s:%u"
+msgstr "                 desde"
 
 #: diagnostic.c:991
 #, c-format
@@ -796,10 +790,9 @@ msgstr ""
 "%s.\n"
 
 #: gcov-tool.c:528
-#, fuzzy, c-format
-#| msgid "Copyright %s 2018 Free Software Foundation, Inc.\n"
+#, c-format
 msgid "Copyright %s 2019 Free Software Foundation, Inc.\n"
-msgstr "Copyright %s 2018 Free Software Foundation, Inc.\n"
+msgstr "Copyright %s 2019 Free Software Foundation, Inc.\n"
 
 #: gcov-tool.c:531 gcov.c:925
 #, c-format
@@ -867,10 +860,9 @@ msgid "  -h, --help                      Print this help, then exit\n"
 msgstr "  -h, --help                      Muestra esta información, y finaliza\n"
 
 #: gcov.c:894
-#, fuzzy, c-format
-#| msgid "  -n, --no-output                 Do not create an output file\n"
+#, c-format
 msgid "  -i, --json-format               Output JSON intermediate format into .gcov.json.gz file\n"
-msgstr "  -n, --no-output                 No crea un fichero de salida\n"
+msgstr "  -i, --json-format               Salida con formato JSON intermedia en el fichero .gcov.json.gz\n"
 
 #: gcov.c:895
 #, c-format
@@ -912,10 +904,9 @@ msgid "  -p, --preserve-paths            Preserve all pathname components\n"
 msgstr "  -p, --preserve-paths            Preserva todos los nombres de ruta de los componentes\n"
 
 #: gcov.c:903
-#, fuzzy, c-format
-#| msgid "  -k, --use-colors                Emit colored output\n"
+#, c-format
 msgid "  -q, --use-hotness-colors        Emit perf-like colored output for hot lines\n"
-msgstr "  -k, --use-colors                Emite salida con colores\n"
+msgstr "  -q, --use-hotness-colors        Emite salida con colores de tipo perf para las líneas calientes\n"
 
 #: gcov.c:904
 #, c-format
@@ -928,10 +919,9 @@ msgid "  -s, --source-prefix DIR         Source prefix to elide\n"
 msgstr "  -s, --source-prefix DIR         Prefijo de fuente a omitir\n"
 
 #: gcov.c:906
-#, fuzzy, c-format
-#| msgid "  -n, --no-output                 Do not create an output file\n"
+#, c-format
 msgid "  -t, --stdout                    Output to stdout instead of a file\n"
-msgstr "  -n, --no-output                 No crea un fichero de salida\n"
+msgstr "  -t, --stdout                    Salida en stdout en lugar de un fichero\n"
 
 #: gcov.c:907
 #, c-format
@@ -959,10 +949,9 @@ msgid "gcov %s%s\n"
 msgstr "gcov %s%s\n"
 
 #: gcov.c:1250
-#, fuzzy, c-format
-#| msgid "Treat the input file as already preprocessed."
+#, c-format
 msgid "'%s' file is already processed\n"
-msgstr "Trata al fichero de entrada como previamente preprocesado."
+msgstr "El fichero '%s' ya está procesado\n"
 
 #: gcov.c:1364
 #, c-format
@@ -990,16 +979,14 @@ msgid "\n"
 msgstr "\n"
 
 #: gcov.c:1489
-#, fuzzy, c-format
-#| msgid "%s: Cannot open output file: %s\n"
+#, c-format
 msgid "Cannot open JSON output file %s\n"
-msgstr "%s: No se puede abrir el fichero de salida: %s\n"
+msgstr "No se puede abrir el fichero de salida JSON %s\n"
 
 #: gcov.c:1497
-#, fuzzy, c-format
-#| msgid "Error writing output file '%s'\n"
+#, c-format
 msgid "Error writing JSON output file %s\n"
-msgstr "Error al escribir el fichero de salida '%s'\n"
+msgstr "Error al escribir el fichero de salida JSON %s\n"
 
 #: gcov.c:1664
 #, c-format
@@ -1266,10 +1253,8 @@ msgid "this is the insn:"
 msgstr "este es la insn:"
 
 #: lra-constraints.c:2971
-#, fuzzy
-#| msgid "unable to generate reloads for:"
 msgid "unable to generate reloads for impossible constraints:"
-msgstr "no se pueden generar recargas para:"
+msgstr "no se pueden generar recargas para restricciones imposibles:"
 
 #: lra-constraints.c:3962 reload.c:3814
 msgid "unable to generate reloads for:"
@@ -1327,12 +1312,13 @@ msgid " All options with the desired characteristics have already been displayed
 msgstr "Ya se mostraron todas las opciones con las características deseadas\n"
 
 #: opts.c:1581
-#, fuzzy, c-format
-#| msgid "invalid argument %qs to %qs"
+#, c-format
 msgid ""
 "  Known valid arguments for %s option:\n"
 "   "
-msgstr "argumento %qs no válido para %qs"
+msgstr ""
+"  Argumentos válidos conocidos para la opción %s:\n"
+"   "
 
 #: opts.c:1631
 msgid "The following options are target specific"
@@ -1430,16 +1416,12 @@ msgid "created and used with differing settings of '%s'"
 msgstr "creado y usado con diferentes opciones de '%s'"
 
 #: targhooks.c:2038
-#, fuzzy
-#| msgid "created and used with different settings of -fpic"
 msgid "created and used with different settings of %<-fpic%>"
-msgstr "creado y usado con diferentes opciones de -fpic"
+msgstr "creado y usado con diferentes opciones de %<-fpic%>"
 
 #: targhooks.c:2040
-#, fuzzy
-#| msgid "created and used with different settings of -fpie"
 msgid "created and used with different settings of %<-fpie%>"
-msgstr "creado y usado con diferentes opciones de -fpie"
+msgstr "creado y usado con diferentes opciones de %<-fpie%>"
 
 #: tlink.c:387
 #, c-format
@@ -1703,16 +1685,14 @@ msgid "The maximum number of instructions when inlining for size."
 msgstr "El número máximo de instrucciones cuando se hace inclusión en línea por tamaño."
 
 #: params.def:97
-#, fuzzy, no-c-format
-#| msgid "Use subroutines for function prologues and epilogues."
+#, no-c-format
 msgid "Instruction accounted for function prologue, epilogue and other overhead."
-msgstr "Usa subrutinas para los prólogos y epílogos de función."
+msgstr "Instrucción contabilizada para el prólogo y epílogo de la función y otras sobrecargas."
 
 #: params.def:103
-#, fuzzy, no-c-format
-#| msgid "Use subroutines for function prologues and epilogues."
+#, no-c-format
 msgid "Time accounted for function prologue, epilogue and other overhead."
-msgstr "Usa subrutinas para los prólogos y epílogos de función."
+msgstr "Tiempo contabilizado para el prólogo y epílogo de la función y otras sobrecargas."
 
 #: params.def:109
 #, no-c-format
@@ -1946,10 +1926,9 @@ msgstr "El número máximo de eliminación de opciones en un solo bucle."
 
 # 'desfactorizar' no me gusta. ¿Alguna sugerencia? - cfuga
 #: params.def:393
-#, fuzzy, no-c-format
-#| msgid "The maximum number of insns to duplicate when unfactoring computed gotos."
+#, no-c-format
 msgid "The maximum number of insns in loop header duplicated by the copy loop headers pass."
-msgstr "El número máximo de insns a duplicar al desfactorizar gotos calculados."
+msgstr "El número máximo de instrucciones en encabezamiento de bucle a duplicar en el paso de encabezamientos de bucles."
 
 #: params.def:400
 #, no-c-format
@@ -1982,16 +1961,14 @@ msgid "A threshold on the average loop count considered by the swing modulo sche
 msgstr "Umbral en el número promedio de bucles considerado por el planificador de cambio de módulo."
 
 #: params.def:430
-#, fuzzy, no-c-format
-#| msgid "Select fraction of the maximal count of repetitions of basic block in program given basic block needs to have to be considered hot"
+#, no-c-format
 msgid "Select fraction of the maximal count of repetitions of basic block in program given basic block needs to have to be considered hot (used in non-LTO mode)."
-msgstr "La selección de fracción de la cuenta maximal de repeticiones del bloque básico en el bloque básico dado de programa que necesita para ser considerado caliente"
+msgstr "La selección de fracción de la cuenta maximal de repeticiones del bloque básico en el bloque básico dado de programa que necesita para ser considerado caliente (utilizado en modo no LTO)."
 
 #: params.def:435
-#, fuzzy, no-c-format
-#| msgid "A basic block profile count is considered hot if it contributes to the given permillage of the entire profiled execution."
+#, no-c-format
 msgid "A basic block profile count is considered hot if it contributes to the given permillage of the entire profiled execution (used in LTO mode)."
-msgstr "El número de perfiles de bloque básicos se considera caliente si contribuye al pormillaje dado de la ejecución perfilada completa."
+msgstr "El número de perfiles de bloque básicos se considera caliente si contribuye al pormillaje dado de la ejecución perfilada completa (utilizado en modo LTO)."
 
 #: params.def:440
 #, no-c-format
@@ -2009,8 +1986,7 @@ msgid "Select fraction of the maximal frequency of executions of basic block in
 msgstr "Selección de fracción de la frecuencia máxima de ejecuciones de bloque básico en la función dada para la que el bloque básico consigue alinear."
 
 #: params.def:455
-#, fuzzy, no-c-format
-#| msgid "Loops iterating at least selected number of iterations will get loop alignment.."
+#, no-c-format
 msgid "Loops iterating at least selected number of iterations will get loop alignment."
 msgstr "Iterar ciclos por lo menos el número seleccionado de iteraciones que logrará alineación de bucles."
 
@@ -2121,10 +2097,9 @@ msgid "Maximum size (in bytes) of objects tracked bytewise by dead store elimina
 msgstr "Número máximo (en bytes) de objetos rastreados en btyes por la eliminación de almacenamiento muerto."
 
 #: params.def:593
-#, fuzzy, no-c-format
-#| msgid "Maximum number of times that an insn could be scheduled."
+#, no-c-format
 msgid "Maximum number of queries into the alias oracle per store."
-msgstr "El número máximo de veces que se puede planificar una insns."
+msgstr "El número máximo de consultas al oráculo de alias por almacenamiento."
 
 #: params.def:598
 #, no-c-format
@@ -2495,22 +2470,19 @@ msgid "Maximum size of a list of values associated with each parameter for inter
 msgstr "Tamaño máximo de una lista de valores asociada con cada parámetro para propagación constante entre procedimientos."
 
 #: params.def:1092
-#, fuzzy, no-c-format
-#| msgid "Threshold ipa-cp opportunity evaluation that is still considered beneficial to clone.."
+#, no-c-format
 msgid "Threshold ipa-cp opportunity evaluation that is still considered beneficial to clone."
-msgstr "Rango de evaluación de oportunidad ipa-cp que aún se considera beneficioso para clonar.."
+msgstr "Rango de evaluación de oportunidad ipa-cp que aún se considera beneficioso para clonar."
 
 #: params.def:1098
-#, fuzzy, no-c-format
-#| msgid "Percentage penalty the recursive functions will receive when they are evaluated for cloning.."
+#, no-c-format
 msgid "Percentage penalty the recursive functions will receive when they are evaluated for cloning."
-msgstr "Penalización porcentual que recibirán las funciones recursivas cuando se evalúen para clonación.."
+msgstr "Penalización porcentual que recibirán las funciones recursivas cuando se evalúen para clonación."
 
 #: params.def:1104
-#, fuzzy, no-c-format
-#| msgid "Percentage penalty functions containing a single call to another function will receive when they are evaluated for cloning.."
+#, no-c-format
 msgid "Percentage penalty functions containing a single call to another function will receive when they are evaluated for cloning."
-msgstr "Penalización porcentual que recibirán las funciones que contien una sola llamada a otra función cuando se evalúen para clonación.."
+msgstr "Penalización porcentual que recibirán las funciones que contien una sola llamada a otra función cuando se evalúen para clonación."
 
 #: params.def:1110
 #, no-c-format
@@ -2518,16 +2490,14 @@ msgid "Maximum number of aggregate content items for a parameter in jump functio
 msgstr "Número máximo de elementos de contenido agregado de un parámetro en funciones de salto y celosías."
 
 #: params.def:1116
-#, fuzzy, no-c-format
-#| msgid "Compile-time bonus IPA-CP assigns to candidates which make loop bounds or strides known.."
+#, no-c-format
 msgid "Compile-time bonus IPA-CP assigns to candidates which make loop bounds or strides known."
-msgstr "Bonificación de tiempo de compilación que IPA-CP asigna a los candidatos que dan a conocer los límites o los pasos de los bucles.."
+msgstr "Bonificación de tiempo de compilación que IPA-CP asigna a los candidatos que dan a conocer los límites o los pasos de los bucles."
 
 #: params.def:1122
-#, fuzzy, no-c-format
-#| msgid "Compile-time bonus IPA-CP assigns to candidates which make an array index known.."
+#, no-c-format
 msgid "Compile-time bonus IPA-CP assigns to candidates which make an array index known."
-msgstr "Bonificación de tiempo de compilación que IPA-CP asigna a los candidatos que dan conocer el índice de un array.."
+msgstr "Bonificación de tiempo de compilación que IPA-CP asigna a los candidatos que dan conocer el índice de un array."
 
 #: params.def:1128
 #, no-c-format
@@ -2576,10 +2546,9 @@ msgid "Allow new data races on stores to be introduced."
 msgstr "Permite que se introduzcan carreras de datos nuevos en stores."
 
 #: params.def:1187
-#, fuzzy, no-c-format
-#| msgid "Set the maximum number of instructions executed in parallel in reassociated tree. If 0, use the target dependent heuristic.."
+#, no-c-format
 msgid "Set the maximum number of instructions executed in parallel in reassociated tree.  If 0, use the target dependent heuristic."
-msgstr "Establece el número máximo de instrucciones ejecutadas en paralelo en el árbol de reasociación. Si es 0, usa la heurística dependiente del objetivo.."
+msgstr "Establece el número máximo de instrucciones ejecutadas en paralelo en el árbol de reasociación. Si es 0, usa la heurística dependiente del objetivo."
 
 #: params.def:1193
 #, no-c-format
@@ -2748,10 +2717,9 @@ msgid "Maximum number of may-defs visited when devirtualizing speculatively."
 msgstr "Número máximo de definiciones posibles visitadas cuando se desvirtualiza especulativamente."
 
 #: params.def:1375
-#, fuzzy, no-c-format
-#| msgid "Maximum number of constant stores to merge in the store merging pass."
+#, no-c-format
 msgid "Maximum number of assertions to add along the default edge of a switch statement during VRP."
-msgstr "Número máximo de almacenamientos constantes que hay que mezclar en el paso de mezcla de almacenamientos."
+msgstr "Número máximo de aserciones que hay que añadir a lo largo del borde predefinido de una sentencia switch durante VRP."
 
 #: params.def:1381
 #, no-c-format
@@ -2766,7 +2734,7 @@ msgstr ""
 #: params.def:1391
 #, no-c-format
 msgid "Maximum unroll factor for the unroll-and-jam transformation."
-msgstr ""
+msgstr "Máximo factor de desenrrollado para la transformación unroll-and-jam."
 
 #: params.def:1396
 #, no-c-format
@@ -2776,19 +2744,17 @@ msgstr "Número máximo de bits para el cual evitamos crear FMAs."
 #: params.def:1401
 #, no-c-format
 msgid "True if a non-short-circuit operation is optimal."
-msgstr ""
+msgstr "Verdadero si una operación de non-short-circuit es óptima."
 
 #: params.def:1406
-#, fuzzy, no-c-format
-#| msgid "Maximum number of instructions in basic block to be considered for SLP vectorization."
+#, no-c-format
 msgid "The maximum number of instructions in an inner loop that is being considered for versioning."
-msgstr "El número máximo de instrucciones en bloque básico que se consideran para vectorización SLP."
+msgstr "El número máximo de instrucciones en un bucle interior que se consideran para versionar."
 
 #: params.def:1412
-#, fuzzy, no-c-format
-#| msgid "The maximum number of instructions to consider to unroll in a loop."
+#, no-c-format
 msgid "The maximum number of instructions in an outer loop that is being considered for versioning, on top of the instructions in inner loops."
-msgstr "El número máximo de instrucciones para considerar el desenrollo en un bucle."
+msgstr "El número máximo de instrucciones ien un bucle exterior que se consideran para versionar, por encima de las instrucciones en los bucles interiores."
 
 #: c-family/c-format.c:404
 msgid "format"
@@ -3655,15 +3621,14 @@ msgstr "operando output_condmove_single erróneo"
 #: config/gcn/gcn.c:5637 config/gcn/gcn.c:5648 config/gcn/gcn.c:5651
 #, c-format
 msgid "bad ADDR_SPACE_GLOBAL address"
-msgstr ""
+msgstr "dirección ADDR_SPACE_GLOBAL errónea"
 
 #: config/gcn/gcn.c:5423 config/gcn/gcn.c:5446 config/gcn/gcn.c:5475
 #: config/gcn/gcn.c:5491 config/gcn/gcn.c:5510 config/gcn/gcn.c:5586
 #: config/gcn/gcn.c:5782 config/gcn/gcn.c:5879
-#, fuzzy, c-format
-#| msgid "invalid operand to %%Z code"
+#, c-format
 msgid "invalid operand %%xn code"
-msgstr "operando no válido para el código %%Z"
+msgstr "operando no válido para el código %%xn"
 
 #: config/gcn/gcn.c:5949
 #, c-format
@@ -3962,22 +3927,19 @@ msgid "invalid zero extract"
 msgstr "extracto de cero no válido"
 
 #: config/or1k/or1k.c:1124 config/or1k/or1k.c:1132
-#, fuzzy, c-format
-#| msgid "invalid operation"
+#, c-format
 msgid "invalid relocation"
-msgstr "operación no válida"
+msgstr "reubicación no válida"
 
 #: config/or1k/or1k.c:1226
-#, fuzzy, c-format
-#| msgid "invalid %H value"
+#, c-format
 msgid "invalid %%H value"
-msgstr "valor %H no válido"
+msgstr "valor %%H no válido"
 
 #: config/or1k/or1k.c:1274
-#, fuzzy, c-format
-#| msgid "unknown punctuation '%c'"
+#, c-format
 msgid "unknown operand letter: '%c'"
-msgstr "puntuación '%c' desconocida"
+msgstr "letra de operando desconocida: '%c'"
 
 #: config/rl78/rl78.c:2009 config/rl78/rl78.c:2095
 #, c-format
@@ -3995,46 +3957,32 @@ msgid "Try running '%s' in the shell to raise its limit.\n"
 msgstr "Pruebe ejecutar '%s' en el intérprete de órdenes para elevar su límite.\n"
 
 #: config/rs6000/rs6000.c:3995
-#, fuzzy
-#| msgid "-mvsx requires hardware floating point"
 msgid "%<-mvsx%> requires hardware floating point"
-msgstr "-mvsx requiere coma flotante de hardware"
+msgstr "%<-mvsx%> requiere coma flotante de hardware"
 
 #: config/rs6000/rs6000.c:4003
-#, fuzzy
-#| msgid "-mvsx needs indexed addressing"
 msgid "%<-mvsx%> needs indexed addressing"
-msgstr "-mvsx necesita direccionamiento indizado"
+msgstr "%<-mvsx%> necesita direccionamiento indexado"
 
 #: config/rs6000/rs6000.c:4008
-#, fuzzy
-#| msgid "-mvsx and -mno-altivec are incompatible"
 msgid "%<-mvsx%> and %<-mno-altivec%> are incompatible"
-msgstr "-mvsx y -mno-altivec son incompatibles"
+msgstr "%<-mvsx%> y -%<mno-altivec%> son incompatibles"
 
 #: config/rs6000/rs6000.c:4010
-#, fuzzy
-#| msgid "-mno-altivec disables vsx"
 msgid "%<-mno-altivec%> disables vsx"
-msgstr "-mno-altivec desactiva vsx"
+msgstr "%<-mno-altivec%> desactiva vsx"
 
 #: config/rs6000/rs6000.c:4136
-#, fuzzy
-#| msgid "-mquad-memory requires 64-bit mode"
 msgid "%<-mquad-memory%> requires 64-bit mode"
-msgstr "-mquad-memory requiere modo de 64 bits"
+msgstr "%<-mquad-memory%> requiere modo de 64 bits"
 
 #: config/rs6000/rs6000.c:4139
-#, fuzzy
-#| msgid "-mquad-memory-atomic requires 64-bit mode"
 msgid "%<-mquad-memory-atomic%> requires 64-bit mode"
-msgstr "-mquad-memory-atomic requiere modo de 64 bits"
+msgstr "%<-mquad-memory-atomic%> requiere modo de 64 bits"
 
 #: config/rs6000/rs6000.c:4151
-#, fuzzy
-#| msgid "-mquad-memory is not available in little endian mode"
 msgid "%<-mquad-memory%> is not available in little endian mode"
-msgstr "-mquad-memory no está disponible en modo little endian"
+msgstr "%<-mquad-memory%> no está disponible en modo little endian"
 
 #: config/rs6000/rs6000.c:10374
 msgid "bad move"
@@ -4100,10 +4048,9 @@ msgid "invalid %%q value"
 msgstr "valor %%q no válido"
 
 #: config/rs6000/rs6000.c:21141
-#, fuzzy, c-format
-#| msgid "invalid %%J value"
+#, c-format
 msgid "invalid %%t value"
-msgstr "valor %%J no válido"
+msgstr "valor %%t no válido"
 
 #: config/rs6000/rs6000.c:21158
 #, c-format
@@ -4121,10 +4068,9 @@ msgid "invalid %%v value"
 msgstr "valor %%v no válido"
 
 #: config/rs6000/rs6000.c:21234
-#, fuzzy, c-format
-#| msgid "invalid %%J value"
+#, c-format
 msgid "invalid %%V value"
-msgstr "valor %%J no válido"
+msgstr "valor %%V no válido"
 
 #: config/rs6000/rs6000.c:21251 config/xtensa/xtensa.c:2439
 #, c-format
@@ -4696,10 +4642,8 @@ msgid "enters synchronized or atomic statement"
 msgstr "entra en la sentencia sincronizada o atómica"
 
 #: cp/decl.c:3254
-#, fuzzy
-#| msgid "expected statement"
 msgid "enters constexpr if statement"
-msgstr "se esperaba una declaración"
+msgstr "entre en la sentencia if de expresión constante"
 
 #: cp/error.c:375
 msgid "<missing>"
@@ -5032,10 +4976,8 @@ msgid "Integer outside symmetric range implied by Standard Fortran at %L"
 msgstr "Rango simétrico fuera de entero implicado por Standard Fortran en %L"
 
 #: fortran/arith.c:118
-#, fuzzy
-#| msgid "Illegal character in BOZ constant at %C"
 msgid "Illegal type in character concatenation at %L"
-msgstr "Carácter ilegal en la constante BOZ en %C"
+msgstr "Typo ilegal en concatenación de caracteres en %L"
 
 #: fortran/arith.c:1384
 msgid "elemental binary operation"
@@ -5397,10 +5339,9 @@ msgid "Operand of unary numeric operator %%<%s%%> at %%L is %s"
 msgstr "El operando del operador numérico unitario %%<%s%%> en %%L es %s"
 
 #: fortran/resolve.c:3949
-#, fuzzy, c-format
-#| msgid "Operands of binary numeric operator %%<%s%%> at %%L are %s/%s"
+#, c-format
 msgid "Unexpected derived-type entities in binary intrinsic numeric operator %%<%s%%> at %%L"
-msgstr "Los operandos del operador numérico binario %%<%s%%> en %%L son %s/%s"
+msgstr "Entidades de tipos derivados no esperadas en el operador numérico intrínseco binario %%<%s%%> en %%L"
 
 #: fortran/resolve.c:3954
 #, c-format
@@ -5517,7 +5458,7 @@ msgstr "Desborde entero al calcular la cantidad de memoria a reservar"
 #: fortran/trans-array.c:9544
 #, c-format
 msgid "The value of the PDT LEN parameter '%s' does not agree with that in the dummy declaration"
-msgstr ""
+msgstr "El valor del parámetro PDT LEN '%s' no concuerda con el de la declaración «dummy»"
 
 #: fortran/trans-decl.c:6025
 #, c-format
@@ -5719,10 +5660,8 @@ msgid "-E or -x required when input is from standard input"
 msgstr "se requiere -E ó -x cuando la entrada es de entrada estándar"
 
 #: config/darwin.h:126 config/darwin.h:427
-#, fuzzy
-#| msgid "-pg not supported on this platform"
 msgid "gsplit-dwarf is not supported on this platform"
-msgstr "-pg no se admite en esta plataforma"
+msgstr "gsplit-dwarf no se admite en esta plataforma"
 
 #: config/darwin.h:170
 msgid "rdynamic is not supported"
@@ -5788,8 +5727,6 @@ msgstr "-Xbind-now y -Xbind-lazy son incompatibles"
 
 #: config/aarch64/aarch64-freebsd.h:37 config/arm/freebsd.h:49
 #: config/riscv/freebsd.h:44
-#, fuzzy
-#| msgid "consider using `-pg' instead of `-p' with gprof (1) "
 msgid "consider using `-pg' instead of `-p' with gprof (1)"
 msgstr "considere usar `-pg' en lugar de `-p' con gprof (1)"
 
@@ -5868,7 +5805,7 @@ msgstr "considere usar `-pg' en lugar de `-p' con gprof(1)"
 
 #: config/rs6000/rs6000.h:139
 msgid "Missing -mcpu option in ASM_CPU_SPEC?"
-msgstr ""
+msgstr "¿Falta la opción -mcpu en ASM_CPU_SPEC?"
 
 #: config/rx/rx.h:80
 msgid "-mas100-syntax is incompatible with -gdwarf"
@@ -5891,10 +5828,8 @@ msgid "SH2a does not support little-endian"
 msgstr "SH2a no se admite para little-endian"
 
 #: config/sparc/linux64.h:148
-#, fuzzy
-#| msgid "-pie is not supported in this configuration"
 msgid "-fsanitize=address is not supported in this configuration"
-msgstr "-pie no se admite en esta configuración"
+msgstr "-fsanitize=dirección no se admite en esta configuración"
 
 #: config/sparc/linux64.h:162 config/sparc/linux64.h:168
 #: config/sparc/netbsd-elf.h:108 config/sparc/netbsd-elf.h:117
@@ -5960,7 +5895,7 @@ msgstr "Avisa sobre la creación de matrices temporales."
 
 #: fortran/lang.opt:214
 msgid "Warn about type and rank mismatches between arguments and parameters."
-msgstr ""
+msgstr "Avisa sobre discordancias de tipo y rango entre argumentos y parámetros."
 
 #: fortran/lang.opt:218
 msgid "Warn if the type of a variable might be not interoperable with C."
@@ -6243,7 +6178,7 @@ msgstr "-ffree-line-length-<n>\tUsa n como ancho de línea de carácter en modo
 
 #: fortran/lang.opt:565
 msgid "Try to interchange loops if profitable."
-msgstr ""
+msgstr "Intenta intercambiar bucles si es provechoso."
 
 #: fortran/lang.opt:569
 msgid "Enable front end optimization."
@@ -6259,7 +6194,7 @@ msgstr "-finit-character=<n>\tInicializa las variables de carácter locales al v
 
 #: fortran/lang.opt:581
 msgid "Initialize components of derived type variables according to other init flags."
-msgstr ""
+msgstr "Inicializa componentes de variables de tipo derivado en conformidad con otros indicadores de inicialización."
 
 #: fortran/lang.opt:585
 msgid "-finit-integer=<n>\tInitialize local integer variables to n."
@@ -6315,7 +6250,7 @@ msgstr "Protege paréntesis en las expresiones."
 
 #: fortran/lang.opt:675
 msgid "Path to header file that should be pre-included before each compilation unit."
-msgstr ""
+msgstr "Ruta de fichero de cabecera que debería preincluirse antes de cada unidad de compilación."
 
 #: fortran/lang.opt:679
 msgid "Enable range checking during compilation."
@@ -6517,7 +6452,7 @@ msgstr "Avisa si un subojeto tiene un atributo abi_tag que el objeto completo no
 
 #: c-family/c.opt:276
 msgid "Warn on suspicious calls of standard functions computing absolute values."
-msgstr ""
+msgstr "Advierte de llamadas sospechosas de funciones estándar que calculan valores absolutos."
 
 #: c-family/c.opt:280
 msgid "Warn about suspicious uses of memory addresses."
@@ -6545,7 +6480,7 @@ msgstr "-Walloc-size-larger-than=<bytes> Avierte de llamadas a funciones de rese
 
 #: c-family/c.opt:317
 msgid "-Wno-alloc-size-larger-than Disable Walloc-size-larger-than= warning.  Equivalent to Walloc-size-larger-than=<SIZE_MAX> or larger."
-msgstr ""
+msgstr "-Wno-alloc-size-larger-than Desactiva el aviso Walloc-size-larger-than=.  Equivalente a Walloc-size-larger-than=<MAX_TAMAÑO> o mayor."
 
 #: c-family/c.opt:321
 msgid "-Walloc-zero Warn for calls to allocation functions that specify zero bytes."
@@ -6557,7 +6492,7 @@ msgstr "-Walloca-larger-than=<número>\tAdvierte de usos no acotados de alloca y
 
 #: c-family/c.opt:331
 msgid "-Wno-alloca-larger-than Disable Walloca-larger-than= warning.  Equivalent to Walloca-larger-than=<SIZE_MAX> or larger."
-msgstr ""
+msgstr "-Wno-alloca-larger-than Desactiva el aviso Walloca-larger-than=.  Equivalente a Walloca-larger-than=<MAX_TAMAÑO> o mayor."
 
 #: c-family/c.opt:343
 msgid "Warn whenever an Objective-C assignment is being intercepted by the garbage collector."
@@ -6588,10 +6523,8 @@ msgid "Warn when a built-in preprocessor macro is undefined or redefined."
 msgstr "Avisa cuando una macro de preprocesador interna está sin definir o redefinida."
 
 #: c-family/c.opt:371
-#, fuzzy
-#| msgid "Warn about features not present in ISO C99, but present in ISO C11."
 msgid "Warn about features not present in ISO C11, but present in ISO C2X."
-msgstr "Avisa sobre características no presentes en ISO C99, pero presentes en ISO C11."
+msgstr "Avisa sobre características no presentes en ISO C11, pero presentes en ISO C2X."
 
 #: c-family/c.opt:375
 msgid "Warn about features not present in ISO C90, but present in ISO C99."
@@ -6641,10 +6574,8 @@ msgstr "Avisa sobre subíndices cuyo tipo es \"char\"."
 #: c-family/c.opt:1369 c-family/c.opt:1373 c-family/c.opt:1377
 #: c-family/c.opt:1381 c-family/c.opt:1385 c-family/c.opt:1389
 #: config/i386/i386.opt:967
-#, fuzzy
-#| msgid "Deprecated in GCC 8.  This switch has no effect."
 msgid "Deprecated in GCC 9.  This switch has no effect."
-msgstr "Obsoleto en GCC 8.  Esta opción no tiene efecto."
+msgstr "Obsoleto en GCC 9.  Esta opción no tiene efecto."
 
 #: c-family/c.opt:429
 msgid "Warn about variables that might be changed by \"longjmp\" or \"vfork\"."
@@ -6676,7 +6607,7 @@ msgstr "Avisa cuando todos los constructores y destructores son privados."
 
 #: c-family/c.opt:461
 msgid "Warn about dangling else."
-msgstr "Avisa sobre else colgados."
+msgstr "Avisa sobre else congante."
 
 #: c-family/c.opt:465
 msgid "Warn about __TIME__, __DATE__ and __TIMESTAMP__ usage."
@@ -6696,11 +6627,11 @@ msgstr "Avisa al borrar objetos polimórficos con destructores que no son virtua
 
 #: c-family/c.opt:485
 msgid "Mark implicitly-declared copy operations as deprecated if the class has a user-provided copy operation."
-msgstr ""
+msgstr "Marca las operaciones de copia declaradas implícitamente como obsoletas si la clase tiene una operación de copia definida por el usuario."
 
 #: c-family/c.opt:490
 msgid "Mark implicitly-declared copy operations as deprecated if the class has a user-provided copy operation or destructor."
-msgstr ""
+msgstr "Marca las operaciones de copia declaradas implícitamente como obsoletas si la clase tiene una operación de copia o un destructor definidos por el usuario."
 
 #: c-family/c.opt:495
 msgid "Warn about positional initialization of structs requiring designated initializers."
@@ -6776,7 +6707,7 @@ msgstr "Avisa sobre el uso de cadenas de formato que no son literales."
 
 #: c-family/c.opt:575
 msgid "Warn about function calls with format strings that write past the end of the destination region.  Same as -Wformat-overflow=1."
-msgstr ""
+msgstr "Advierte de llamadas a función con cadenas de formato que escriben más allá del final de la región de destino.  Igual que -Wformat-overflow=1."
 
 #: c-family/c.opt:580
 msgid "Warn about possible security problems with format functions."
@@ -6788,7 +6719,7 @@ msgstr "Advierte de diferencias de signo en funciones de formato."
 
 #: c-family/c.opt:588
 msgid "Warn about calls to snprintf and similar functions that truncate output. Same as -Wformat-truncation=1."
-msgstr ""
+msgstr "Advierte de llamadas a snprintf y funciones similares que truncan la salida. Igual que -Wformat-truncation=1."
 
 #: c-family/c.opt:593
 msgid "Warn about strftime formats yielding 2-digit years."
@@ -6824,7 +6755,7 @@ msgstr "Avisa cuando hay conversión entre punteros de tipos incompatibles."
 
 #: c-family/c.opt:630
 msgid "Warn when the address of packed member of struct or union is taken."
-msgstr ""
+msgstr "Avisa cuando se toma la dirección del miembro empaquetado de una estructura o unión."
 
 #: c-family/c.opt:634
 msgid "Warn about variables which are initialized to themselves."
@@ -6832,7 +6763,7 @@ msgstr "Avisa sobre variables que se inicialicen ellas mismas."
 
 #: c-family/c.opt:638
 msgid "Warn about uses of std::initializer_list that can result in dangling pointers."
-msgstr ""
+msgstr "Avisa sobre usos de std::initializer_list que pueden resultar en punteros "
 
 #: c-family/c.opt:642
 msgid "Warn about implicit declarations."
@@ -6864,7 +6795,7 @@ msgstr "Advierte de conversiones de entero a puntero y viceversa incompatibles."
 
 #: c-family/c.opt:677
 msgid "Warn for suspicious integer expressions in boolean context."
-msgstr ""
+msgstr "Advierte de expresiones enteras sospechosas en contexto booleano."
 
 #: c-family/c.opt:681
 msgid "Warn when there is a cast to a pointer from an integer of a different size."
@@ -6928,7 +6859,7 @@ msgstr "Avisa sobre campos faltantes en los inicializadores de struct."
 
 #: c-family/c.opt:745
 msgid "Warn about unsafe macros expanding to multiple statements used as a body of a clause such as if, else, while, switch, or for."
-msgstr ""
+msgstr "Advierte de expansiones de macros no seguras a sentencias múltiples utilizadas como cuerpo de una cláusula como if, while, switch o for."
 
 #: c-family/c.opt:749
 msgid "Warn on direct multiple inheritance."
@@ -6940,7 +6871,7 @@ msgstr "Advierta de la definición de espacios de nombres."
 
 #: c-family/c.opt:757
 msgid "Warn when fields in a struct with the packed attribute are misaligned."
-msgstr ""
+msgstr "Avisa cuando un struct con el atributo «packed» tiene campos desalineados."
 
 #: c-family/c.opt:761
 msgid "Warn about missing sized deallocation functions."
@@ -6948,7 +6879,7 @@ msgstr "Advierte de funciones de desasignación con tamaño ausentes."
 
 #: c-family/c.opt:765
 msgid "Warn about suspicious divisions of two sizeof expressions that don't work correctly with pointers."
-msgstr ""
+msgstr "Advierte de divisiones sospechosas de dos expresiones sizeof que no funcionan correctamente con punteros."
 
 #: c-family/c.opt:769
 msgid "Warn about suspicious length parameters to certain string functions if the argument uses sizeof."
@@ -6960,7 +6891,7 @@ msgstr "Avisa cuando se aplica sizeof a parámetros declarados como array."
 
 #: c-family/c.opt:777
 msgid "Warn about buffer overflow in string manipulation functions like memcpy and strcpy."
-msgstr ""
+msgstr "Advierte de desbordamiento de búfer en funciones que manipulan cadenas, como memcpy y strcpy."
 
 #: c-family/c.opt:782
 msgid "Under the control of Object Size type, warn about buffer overflow in string manipulation functions like memcpy and strcpy."
@@ -7039,14 +6970,12 @@ msgid "Warn when non-templatized friend functions are declared within a template
 msgstr "Avisa cuando las funciones friend sin plantillas se declaran dentro de una plantilla."
 
 #: c-family/c.opt:868
-#, fuzzy
-#| msgid "conversion to void will never use a type conversion operator"
 msgid "Warn when a conversion function will never be called due to the type it converts to."
-msgstr "la conversión a void nunca usará un operador de conversión de tipo"
+msgstr "Avisa cuando una función de conversión nunca será llamada debido al tipo al que convierte."
 
 #: c-family/c.opt:872
 msgid "Warn for unsafe raw memory writes to objects of class types."
-msgstr ""
+msgstr "Avisa en caso de escrituras de memoria en bruto no seguras a objetivos de tipos de clase."
 
 #: c-family/c.opt:876
 msgid "Warn about non-virtual destructors."
@@ -7130,7 +7059,7 @@ msgstr "Avisa sobre malos usos de pragmas."
 
 #: c-family/c.opt:991
 msgid "Warn if constructor or destructors with priorities from 0 to 100 are used."
-msgstr ""
+msgstr "Avisa si se usan constructores o destructores con prioridades entre 0 y 100."
 
 #: c-family/c.opt:995
 msgid "Warn if a property for an Objective-C object has no assign semantics specified."
@@ -7150,7 +7079,7 @@ msgstr "Avisa sobre declaraciones múltiples del mismo objeto."
 
 #: c-family/c.opt:1015
 msgid "Warn about redundant calls to std::move."
-msgstr ""
+msgstr "Advierte de llamadas redundantes a std::move."
 
 #: c-family/c.opt:1019
 msgid "Warn about uses of register storage specifier."
@@ -7293,14 +7222,12 @@ msgid "Warn if a variable length array is used."
 msgstr "Avisa si se usa una matriz de longitud variable."
 
 #: c-family/c.opt:1199
-#, fuzzy
-#| msgid "-Wvla-larger-than=<number>\tWarn on unbounded uses of variable-length arrays, and on bounded uses of variable-length arrays whose bound can be larger than <number> bytes."
 msgid "-Wvla-larger-than=<number>\tWarn on unbounded uses of variable-length arrays, and on bounded uses of variable-length arrays whose bound can be larger than <number> bytes. <number> bytes."
-msgstr "-Wvla-larger-than=<número>\tAdvierte de usos no acotados de arrays de longitud variable y de usos acotados de arrays de longitud variable cuyo límite pueda ser más grande que <número> bytes."
+msgstr "-Wvla-larger-than=<número>\tAdvierte de usos no acotados de arrays de longitud variable y de usos acotados de arrays de longitud variable cuyo límite pueda ser más grande que <número> bytes. <número> bytes"
 
 #: c-family/c.opt:1206
 msgid "-Wno-vla-larger-than Disable Wvla-larger-than= warning.  Equivalent to Wvla-larger-than=<SIZE_MAX> or larger."
-msgstr ""
+msgstr "-Wno-vla-larger-than Desactiva el aviso Wvla-larger-than=.  Equivalente a Wvla-larger-than=<MAX_TAMAÑO> o mayor."
 
 #: c-family/c.opt:1210
 msgid "Warn when a register variable is declared volatile."
@@ -7356,11 +7283,11 @@ msgstr "-fada-spec-parent=unidad  Vuelca specs de Ada como unidades hijas del pa
 
 #: c-family/c.opt:1267
 msgid "Support C++17 allocation of over-aligned types."
-msgstr ""
+msgstr "Admite alojamiento C++17 de tipos sobrealineados."
 
 #: c-family/c.opt:1271
 msgid "-faligned-new=<N> Use C++17 over-aligned type allocation for alignments greater than N."
-msgstr ""
+msgstr "-faligned-new=<N> Usa alojamiento de tipo sobrealineado de C++17 para alineamientos mayores que N."
 
 #: c-family/c.opt:1278
 msgid "Allow variadic functions without named parameter."
@@ -7385,7 +7312,7 @@ msgstr "Donde acorte, usar rutas canonicalizadas para cabeceras de sistemas."
 
 #: c-family/c.opt:1305
 msgid "Enable the char8_t fundamental type and use it as the type for UTF-8 string and character literals."
-msgstr ""
+msgstr "Habilita el tipo fundamental char8_t y lo usa como el tipo para los literales de cadenas UTF-8 y de caracteres."
 
 #: c-family/c.opt:1393
 msgid "Deprecated in GCC 8.  This switch has no effect."
@@ -7412,10 +7339,8 @@ msgid "-fconstexpr-loop-limit=<number>\tSpecify maximum constexpr loop iteration
 msgstr "-fconstexpr-loop-limit=<número>\tEspecifica el número de iteraciones de bucle constexpr máximo."
 
 #: c-family/c.opt:1421
-#, fuzzy
-#| msgid "-fconstexpr-loop-limit=<number>\tSpecify maximum constexpr loop iteration count."
 msgid "-fconstexpr-ops-limit=<number>\tSpecify maximum number of constexpr operations during a single constexpr evaluation."
-msgstr "-fconstexpr-loop-limit=<número>\tEspecifica el número de iteraciones de bucle constexpr máximo."
+msgstr "-fconstexpr-ops-limit=<número>\tEspecifica el número máximo de operaciones constexpr durante una evaluación de constexpr."
 
 #: c-family/c.opt:1425
 msgid "Emit debug annotations during preprocessing."
@@ -7431,7 +7356,7 @@ msgstr "Factoriza constructores y destructores complejos para favorecer el espac
 
 #: c-family/c.opt:1441
 msgid "Print hierarchical comparisons when template types are mismatched."
-msgstr ""
+msgstr "Imprime comparaciones jerárquicas cuando los tipos de plantilla no coinciden."
 
 #: c-family/c.opt:1445
 msgid "Preprocess directives only."
@@ -7443,7 +7368,7 @@ msgstr "Permite '$' como un identificador de carácter."
 
 #: c-family/c.opt:1453
 msgid "-fmacro-prefix-map=<old>=<new> Map one directory name to another in __FILE__, __BASE_FILE__, and __builtin_FILE()."
-msgstr ""
+msgstr "-fmacro-prefix-map=<viejo>=<nuevo> Asocia un nombre de directorio a otro en __FILE__, __BASE_FILE__, y __builtin_FILE()."
 
 #: c-family/c.opt:1457
 msgid "Write all declarations as Ada code transitively."
@@ -7851,16 +7776,12 @@ msgstr "Obsoleto en favor de -std=c11."
 
 #: c-family/c.opt:2017 c-family/c.opt:2021 c-family/c.opt:2139
 #: c-family/c.opt:2143
-#, fuzzy
-#| msgid "Conform to the ISO 2017 C standard (expected to be published in 2018)."
 msgid "Conform to the ISO 2017 C standard (published in 2018)."
-msgstr "Conforma al estándar ISO 2017 C (publicación prevista en 2018)."
+msgstr "Conforma al estándar ISO 2017 C (publicado en 2018)."
 
 #: c-family/c.opt:2025
-#, fuzzy
-#| msgid "Conform to the ISO 2011 C standard (experimental and incomplete support)"
 msgid "Conform to the ISO 202X C standard draft (experimental and incomplete support)."
-msgstr "Conforma al estándar ISO 2011 C (soporte experimental e incompleto)"
+msgstr "Conforma al borrador del estándar ISO 202X C (soporte experimental e incompleto)"
 
 #: c-family/c.opt:2029 c-family/c.opt:2033 c-family/c.opt:2119
 msgid "Conform to the ISO 1990 C standard."
@@ -7915,16 +7836,12 @@ msgid "Deprecated in favor of -std=gnu11."
 msgstr "Obsoleto en favor de -std=gnu11."
 
 #: c-family/c.opt:2091 c-family/c.opt:2095
-#, fuzzy
-#| msgid "Conform to the ISO 2017 C standard (expected to be published in 2018) with GNU extensions."
 msgid "Conform to the ISO 2017 C standard (published in 2018) with GNU extensions."
-msgstr "Conforma al estándar ISO 2017 C (publicación prevista en 2018) con extensiones GNU."
+msgstr "Conforma al estándar ISO 2017 C (publicado en 2018) con extensiones GNU."
 
 #: c-family/c.opt:2099
-#, fuzzy
-#| msgid "Conform to the ISO 2011 C standard with GNU extensions (experimental and incomplete support)"
 msgid "Conform to the ISO 202X C standard draft with GNU extensions (experimental and incomplete support)."
-msgstr "Conforma al estándar ISO 2011 C con extensiones GNU (soporte experimental e incompleto)"
+msgstr "Conforma al borrador del estándar ISO 202X C con extensiones GNU (soporte experimental e incompleto)."
 
 #: c-family/c.opt:2103 c-family/c.opt:2107
 msgid "Conform to the ISO 1990 C standard with GNU extensions."
@@ -7992,99 +7909,79 @@ msgstr "No considerada."
 
 #: d/lang.opt:51
 msgid "-Hd <dir>\tWrite D interface files to directory <dir>."
-msgstr ""
+msgstr "-Hd <dir>\tEscribe los ficheros de interfaz de D en el directorio <dir>."
 
 #: d/lang.opt:55
-#, fuzzy
-#| msgid "-o <file>\tPlace output into <file>."
 msgid "-Hf <file>\tWrite D interface to <file>."
-msgstr "-o <fichero>\tColoca la salida en el <fichero>."
+msgstr "-Hf <fichero>\tEscribe el interfaz de D en el <fichero>."
 
 #: d/lang.opt:123
-#, fuzzy
-#| msgid "Warn about casts which discard qualifiers."
 msgid "Warn about casts that will produce a null result."
-msgstr "Avisa sobre conversiones que descartan calificadores."
+msgstr "Avisa sobre conversiones que darán resultado nulo."
 
 #: d/lang.opt:139
 msgid "Warn from speculative compiles such as __traits(compiles)."
 msgstr ""
 
 #: d/lang.opt:151
-#, fuzzy
-#| msgid "Generate H8S code."
 msgid "Generate JSON file."
-msgstr "Genera código H8S."
+msgstr "Genera fichero JSON."
 
 #: d/lang.opt:155
-#, fuzzy
-#| msgid "-MF <file>\tWrite dependency output to the given file."
 msgid "-Xf <file>\tWrite JSON output to the given <file>."
-msgstr "-MF <fichero>\tEscribe la salida de dependencias al fichero dado."
+msgstr "-Xf <fichero>\tEscribe salida JSON al <fichero> dado."
 
 #: d/lang.opt:159
 msgid "Debug library to use instead of phobos."
-msgstr ""
+msgstr "Biblioteca de depuración que se utilizará en lugar de phobos."
 
 #: d/lang.opt:163
 msgid "Default library to use instead of phobos."
-msgstr ""
+msgstr "Biblioteca predefinida que se utilizará en lugar de phobos."
 
 #: d/lang.opt:167
 msgid "Do link the standard D startup files in the compilation."
 msgstr ""
 
 #: d/lang.opt:174
-#, fuzzy
-#| msgid "Generate code for built-in atomic operations."
 msgid "Generate code for all template instantiations."
-msgstr "Genera código para operaciones atómicas internas."
+msgstr "Genera código para todas las instanciaciones de plantillas."
 
 #: d/lang.opt:178
-#, fuzzy
-#| msgid "Generate code for GNU assembler (gas)."
 msgid "Generate code for assert contracts."
-msgstr "Genera código para el ensamblador de GNU (gas)."
+msgstr "Genera código para contratos de assert."
 
 #: d/lang.opt:186
 msgid "-fbounds-check=[on|safeonly|off]\tTurn array bounds checks on, in @safe code only, or off."
-msgstr ""
+msgstr "-fbounds-check=[on|safeonly|off]\tActiva o desactiva las comprobaciones de límites de matrices, solo en código @safe."
 
 #: d/lang.opt:210
-#, fuzzy
-#| msgid "incompatible index mode"
 msgid "Compile in debug code."
-msgstr "modo de índices incompatibles"
+msgstr "Compila en código de depuración."
 
 #: d/lang.opt:214
 msgid "-fdebug=<level|ident>\tCompile in debug code, code <= <level>, or code identified by <ident>."
-msgstr ""
+msgstr "-fdebug=<level|ident>\tCompila en código de depuración, código <= <nivel>, o código identificado por <ident>."
 
 #: d/lang.opt:218
-#, fuzzy
-#| msgid "Generate norm instruction."
 msgid "Generate documentation."
-msgstr "Genera instrucciones norm."
+msgstr "Genera documentación."
 
 #: d/lang.opt:222
 msgid "-fdoc-dir=<dir>\tWrite documentation file to directory <dir>."
-msgstr ""
+msgstr "-fdoc-dir=<dir>\tEscribe el fichero de documentación en el directorio <dir>."
 
 #: d/lang.opt:226
-#, fuzzy
-#| msgid "-o <file>\tPlace output into <file>."
 msgid "-fdoc-file=<file>\tWrite documentation to <file>."
-msgstr "-o <fichero>\tColoca la salida en el <fichero>."
+msgstr "-fdoc-file=<fichero>\tEscribe la documentación en <fichero>."
 
 #: d/lang.opt:230
 msgid "-fdoc-inc=<file>\tInclude a Ddoc macro <file>."
-msgstr ""
+msgstr "-fdoc-inc=<fichero>\tIncluye un <fichero> de macros Ddoc."
 
 #: d/lang.opt:234
-#, fuzzy
-#| msgid "Do not assume that standard C libraries and \"main\" exist."
 msgid "Assume that standard D runtime libraries and \"D main\" exist."
-msgstr "No asume que existen las bibliotecas C estándar y \"main\"."
+msgstr "Asume que existen bibliotecas D estándar de tiempo de ejecución y \"D main\"."
 
 #: d/lang.opt:238
 #, fuzzy
@@ -8094,7 +7991,7 @@ msgstr "Muestra el árbol del código después de analizar; opción obsoleta."
 
 #: d/lang.opt:242
 msgid "Ignore unsupported pragmas."
-msgstr ""
+msgstr "Hace caso omiso de pragmas no admitidas."
 
 #: d/lang.opt:246
 #, fuzzy
@@ -8104,11 +8001,11 @@ msgstr "Genera código para operaciones atómicas internas."
 
 #: d/lang.opt:250
 msgid "Generate a default D main() function when compiling."
-msgstr ""
+msgstr "Genera una función main() de D predefinida al compilar."
 
 #: d/lang.opt:254
 msgid "-fmodule-file=<package.module>=<filespec>\tuse <filespec> as source file for <package.module>."
-msgstr ""
+msgstr "-fmodule-file=<paquete.módulo>=<especfich>\tutiliza <especfich> como fichero fuente para <paquete.módulo>."
 
 #: d/lang.opt:258
 #, fuzzy
@@ -8118,19 +8015,15 @@ msgstr "Genera código para el modo de usuario."
 
 #: d/lang.opt:262
 msgid "Process all modules specified on the command line, but only generate code for the module specified by the argument."
-msgstr ""
+msgstr "Procesa todos los módulos especificados en la línea de órdenes, pero solo genera código para el módulo especificado por el argumento."
 
 #: d/lang.opt:266
-#, fuzzy
-#| msgid "Generate code for built-in atomic operations."
 msgid "Generate code for postcondition contracts."
-msgstr "Genera código para operaciones atómicas internas."
+msgstr "Genera código para contratos de postcondiciones."
 
 #: d/lang.opt:270
-#, fuzzy
-#| msgid "Generate code for built-in atomic operations."
 msgid "Generate code for precondition contracts."
-msgstr "Genera código para operaciones atómicas internas."
+msgstr "Genera código para contratos de precondiciones."
 
 #: d/lang.opt:274
 #, fuzzy
@@ -8139,14 +8032,12 @@ msgid "Compile release version."
 msgstr "Muestra la versión del compilador."
 
 #: d/lang.opt:282
-#, fuzzy
-#| msgid "Generate code for the supervisor mode (default)."
 msgid "Generate code for switches without a default case."
-msgstr "Genera código para el modo supervisor (predeterminado)."
+msgstr "Genera código para las opciones sin caso predefinido."
 
 #: d/lang.opt:286
 msgid "List information on all language changes."
-msgstr ""
+msgstr "Muestra información sobre todos los cambios del lenguaje."
 
 #: d/lang.opt:290
 msgid "Give deprecation messages about -ftransition=import anomalies."
@@ -8154,7 +8045,7 @@ msgstr ""
 
 #: d/lang.opt:294
 msgid "List all usages of complex or imaginary types."
-msgstr ""
+msgstr "Enumera todos los usos de los tipos complejo o imaginario."
 
 #: d/lang.opt:298
 msgid "Implement DIP1000: Scoped pointers (experimental)."
@@ -8166,21 +8057,19 @@ msgstr ""
 
 #: d/lang.opt:306
 msgid "List all non-mutable fields which occupy an object instance."
-msgstr ""
+msgstr "Enumera todos los campos no mutables que ocupan la instancia de un objeto."
 
 #: d/lang.opt:310
 msgid "Revert to single phase name lookup."
-msgstr ""
+msgstr "Revierta a búsqueda de nombres de una sola fase."
 
 #: d/lang.opt:314
 msgid "List all hidden GC allocations."
 msgstr ""
 
 #: d/lang.opt:318
-#, fuzzy
-#| msgid "Use given thread-local storage dialect."
 msgid "List all variables going into thread local storage."
-msgstr "Usa el dialecto de almacenamiento thread-local dado."
+msgstr "Enumera todas las variables que van al almacenamiento local del hilo."
 
 #: d/lang.opt:322
 #, fuzzy
@@ -8193,18 +8082,16 @@ msgid "-fversion=<level|ident>\tCompile in version code >= <level> or identified
 msgstr ""
 
 #: d/lang.opt:350
-#, fuzzy
-#| msgid "Do not assume that standard C libraries and \"main\" exist."
 msgid "Do not link the standard D library in the compilation."
-msgstr "No asume que existen las bibliotecas C estándar y \"main\"."
+msgstr "No enlaza la biblioteca D estándar en la compilación."
 
 #: d/lang.opt:358
 msgid "Link the standard D library statically in the compilation."
-msgstr ""
+msgstr "Enlaza la biblioteca D estándar estáticamente en la compilación."
 
 #: d/lang.opt:362
 msgid "Link the standard D library dynamically in the compilation."
-msgstr ""
+msgstr "Enlaza la biblioteca D estándar dinámicamente en la compilación."
 
 #: go/lang.opt:42
 msgid "-fgo-c-header=<file>\tWrite Go struct definitions to file as C code."
@@ -8271,16 +8158,12 @@ msgid "-mpointer-size=[no,32,short,64,long]\tSet the default pointer size."
 msgstr "-mpointer-size=[no,32,short,64,long]\tEstablece el tamaña predeterminado de los punteros."
 
 #: config/mcore/mcore.opt:23
-#, fuzzy
-#| msgid "Generate code for the M*Core M210"
 msgid "Generate code for the M*Core M210."
-msgstr "Genera código para el M*Core M210"
+msgstr "Genera código para el M*Core M210."
 
 #: config/mcore/mcore.opt:27
-#, fuzzy
-#| msgid "Generate code for the M*Core M340"
 msgid "Generate code for the M*Core M340."
-msgstr "Genera código para el M*Core M340"
+msgstr "Genera código para el M*Core M340."
 
 #: config/mcore/mcore.opt:31
 msgid "Force functions to be aligned to a 4 byte boundary."
@@ -8650,7 +8533,7 @@ msgstr "Activa la biblioteca compartida basada en ID."
 
 #: config/m68k/m68k.opt:147
 msgid "Use 32-bit offsets in jump tables rather than 16-bit offsets."
-msgstr ""
+msgstr "Usa desplazamientos de 32 bits en las tablas de saltos en lugar de desplazamientos de 16 bits."
 
 #: config/m68k/m68k.opt:151
 msgid "Do not use the bit-field instructions."
@@ -8761,11 +8644,11 @@ msgstr "Utiliza operadores %reloc() en vez de macros de ensamblador para cargar
 
 #: config/riscv/riscv.opt:114
 msgid "Take advantage of linker relaxations to reduce the number of instructions required to materialize symbol addresses."
-msgstr ""
+msgstr "Aprovecha los descansos del enlazador para reducir el número de instrucciones requeridas para materializar direcciones de símbolos."
 
 #: config/riscv/riscv.opt:133
 msgid "Emit RISC-V ELF attribute."
-msgstr ""
+msgstr "Emite el atributo ELF de RISC-V."
 
 #: config/m32c/m32c.opt:23
 msgid "-msim\tUse simulator runtime."
diff --git a/gcc/po/fi.po b/gcc/po/fi.po
index c66de8afab4..b4b27c40017 100644
--- a/gcc/po/fi.po
+++ b/gcc/po/fi.po
@@ -33,7 +33,7 @@ msgstr ""
 "Project-Id-Version: gcc 9.1.0\n"
 "Report-Msgid-Bugs-To: https://gcc.gnu.org/bugs/\n"
 "POT-Creation-Date: 2019-05-02 20:28+0000\n"
-"PO-Revision-Date: 2019-05-29 18:58+0300\n"
+"PO-Revision-Date: 2019-10-11 20:03+0300\n"
 "Last-Translator: Lauri Nurmi <lanurmi@iki.fi>\n"
 "Language-Team: Finnish <translation-team-fi@lists.sourceforge.net>\n"
 "Language: fi\n"
@@ -67,9 +67,9 @@ msgid "[cannot find %s]"
 msgstr "lähdetiedostoa %s ei löydy"
 
 #: collect2.c:1632
-#, fuzzy, c-format
+#, c-format
 msgid "collect2 version %s\n"
-msgstr "gcc-versio %s %s\n"
+msgstr "collect2-versio %s\n"
 
 #: collect2.c:1737
 #, c-format
@@ -118,9 +118,9 @@ msgid "const/copy propagation disabled"
 msgstr "const-/kopioinnin-eteneminen poistettu käytöstä"
 
 #: diagnostic.c:145
-#, fuzzy, c-format
+#, c-format
 msgid "%s: all warnings being treated as errors"
-msgstr "Käsittele kaikki varoitukset virheinä"
+msgstr "%s: kaikki varoitukset käsitellään virheinä"
 
 #: diagnostic.c:150
 #, c-format
@@ -6142,9 +6142,8 @@ msgid "gfortran does not support -E without -cpp"
 msgstr "gfortran ei tue valitsinta -E ilman valitsinta -cpp"
 
 #: objc/lang-specs.h:30 objc/lang-specs.h:41
-#, fuzzy
 msgid "GNU Objective C no longer supports traditional compilation"
-msgstr "GCC ei enää tue valitsinta -traditional ilman valitsinta -E"
+msgstr "GNU Objective C ei enää tue perinteistä kääntämistä"
 
 #: objc/lang-specs.h:55
 msgid "objc-cpp-output is deprecated; please use objective-c-cpp-output instead"
@@ -6688,9 +6687,8 @@ msgid "Conform to the ISO Fortran 95 standard."
 msgstr "Noudata ISO Fortran 95 -standardia"
 
 #: fortran/lang.opt:827
-#, fuzzy
 msgid "Conform to nothing in particular."
-msgstr "Älä noudata mitään erityisesti"
+msgstr "Älä noudata mitään erityisesti."
 
 #: fortran/lang.opt:831
 msgid "Accept extensions to support legacy code."
@@ -6732,24 +6730,20 @@ msgid "-I <dir>\tAdd <dir> to the end of the main include path."
 msgstr "-isystem <hakemisto>\tLisää <hakemisto> järjestelmän include-polun alkuun"
 
 #: c-family/c.opt:217
-#, fuzzy
 msgid "Generate make dependencies."
-msgstr "Luo make-riippuvuudet"
+msgstr "Luo make-riippuvuudet."
 
 #: c-family/c.opt:221
-#, fuzzy
 msgid "Generate make dependencies and compile."
-msgstr "Luo make-riippuvuudet ja käännä"
+msgstr "Luo make-riippuvuudet ja käännä."
 
 #: c-family/c.opt:225
-#, fuzzy
 msgid "-MF <file>\tWrite dependency output to the given file."
-msgstr "Kirjoita riippuvuustuloste annettuun tiedostoon"
+msgstr "-MF <tiedosto>\tKirjoita riippuvuustuloste annettuun tiedostoon."
 
 #: c-family/c.opt:229
-#, fuzzy
 msgid "Treat missing header files as generated files."
-msgstr "Käsittele puuttuvia otsikkotiedostoja luotavina tiedostoina"
+msgstr "Käsittele puuttuvia otsikkotiedostoja luotavina tiedostoina."
 
 #: c-family/c.opt:233
 msgid "Like -M but ignore system header files."
@@ -6773,9 +6767,8 @@ msgid "-MT <target>\tAdd an unquoted target."
 msgstr ""
 
 #: c-family/c.opt:253
-#, fuzzy
 msgid "Do not generate #line directives."
-msgstr "Älä luo #line-direktiivejä"
+msgstr "Älä luo #line-direktiivejä."
 
 #: c-family/c.opt:257
 #, fuzzy
@@ -6817,11 +6810,9 @@ msgstr ""
 msgid "Enable most warning messages."
 msgstr "Subject: Fetchmailin varoitus liian suuresta viestistä"
 
-# vähän fuzzy
 #: c-family/c.opt:308
-#, fuzzy
 msgid "Warn on any use of alloca."
-msgstr "Varoita pragmain väärästä käytöstä."
+msgstr "Varoita kaikesta allocan käytöstä."
 
 #: c-family/c.opt:312
 #, fuzzy
@@ -6931,9 +6922,8 @@ msgstr "Varoita ”char”-tyypillä indeksoinnista."
 #: c-family/c.opt:1369 c-family/c.opt:1373 c-family/c.opt:1377
 #: c-family/c.opt:1381 c-family/c.opt:1385 c-family/c.opt:1389
 #: config/i386/i386.opt:967
-#, fuzzy
 msgid "Deprecated in GCC 9.  This switch has no effect."
-msgstr "Vanhentunut. Tämä valitsin ei vaikuta mihinkään."
+msgstr "Vanhentunut GCC 9:ssä. Tämä valitsin ei vaikuta mihinkään."
 
 #: c-family/c.opt:429
 msgid "Warn about variables that might be changed by \"longjmp\" or \"vfork\"."
@@ -6964,9 +6954,8 @@ msgid "Warn when all constructors and destructors are private."
 msgstr "Varoita kun kaikki muodostimet ja hajottimet ovat yksityisiä."
 
 #: c-family/c.opt:461
-#, fuzzy
 msgid "Warn about dangling else."
-msgstr "Varoita implisiittisistä funktioesittelyistä."
+msgstr "Varoita orvosta elsestä."
 
 #: c-family/c.opt:465
 msgid "Warn about __TIME__, __DATE__ and __TIMESTAMP__ usage."
@@ -7119,9 +7108,8 @@ msgid "Warn whenever type qualifiers are ignored."
 msgstr "Varoita tyyppimääreiden huomiotta jättämisestä."
 
 #: c-family/c.opt:622
-#, fuzzy
 msgid "Warn whenever attributes are ignored."
-msgstr "Varoita tyyppimääreiden huomiotta jättämisestä."
+msgstr "Varoita attribuuttien huomiotta jättämisestä."
 
 #: c-family/c.opt:626
 #, fuzzy
@@ -7196,9 +7184,8 @@ msgid "Warn when a string or character literal is followed by a ud-suffix which
 msgstr ""
 
 #: c-family/c.opt:701
-#, fuzzy
 msgid "Warn when a logical operator is suspiciously always evaluating to true or false."
-msgstr "Varoita vertailusta, joka on aina tosi tai aina epätosi."
+msgstr "Varoita, kun looginen operaattori on aina tosi tai aina epätosi."
 
 #: c-family/c.opt:705
 msgid "Warn when logical not is used on the left hand side operand of a comparison."
@@ -7429,9 +7416,8 @@ msgid "Warn about packed bit-fields whose offset changed in GCC 4.4."
 msgstr "Varoita pakatuista bittikentistä, joiden siirrososoite vaihtui GCC 4.4:ssä"
 
 #: c-family/c.opt:955
-#, fuzzy
 msgid "Warn about possibly missing parentheses."
-msgstr "Varoita mahdollisesti puuttuvista sulkeista"
+msgstr "Varoita mahdollisesti puuttuvista sulkeista."
 
 #: c-family/c.opt:963
 msgid "Warn about calling std::move on a local object in a return statement preventing copy elision."
@@ -7975,9 +7961,8 @@ msgid "Enable OpenMP's SIMD directives."
 msgstr "Luokittelematon lause IF-lauseessa kohdassa %C"
 
 #: c-family/c.opt:1681
-#, fuzzy
 msgid "Recognize C++ keywords like \"compl\" and \"xor\"."
-msgstr "Tunnista C++:n avainsanat kuten ”compl” ja ”xor”"
+msgstr "Tunnista C++:n avainsanat kuten ”compl” ja ”xor”."
 
 #: c-family/c.opt:1692
 msgid "Look for and use PCH files even when preprocessing."
@@ -8732,9 +8717,8 @@ msgid "Set the maximum amount for a single stack increment operation."
 msgstr ""
 
 #: config/mcore/mcore.opt:75
-#, fuzzy
 msgid "Always treat bitfields as int-sized."
-msgstr "Käsittele bittikenttiä aina int-kokoisina"
+msgstr "Käsittele bittikenttiä aina int-kokoisina."
 
 #: config/linux-android.opt:23
 msgid "Generate code for the Android platform."
@@ -19730,7 +19714,7 @@ msgstr "%qs-attribuuttia ei huomioida %qs:lle"
 #: cgraphunit.c:976 c/c-decl.c:11507
 #, fuzzy, gcc-internal-format
 msgid "%q+F used but never defined"
-msgstr "nimike %q+D määritelty mutta käytettämättä"
+msgstr "nimike %q+D määritelty mutta käyttämättä"
 
 #: cgraphunit.c:978 c/c-decl.c:11517
 #, fuzzy, gcc-internal-format
@@ -29294,7 +29278,7 @@ msgstr "%<X<=Y<=Z%> -tyylisillä vertailuilla on eri merkitys kuin matematiikass
 #: c-family/c-warn.c:2021
 #, gcc-internal-format
 msgid "label %q+D defined but not used"
-msgstr "nimike %q+D määritelty mutta käytettämättä"
+msgstr "nimike %q+D määritelty mutta käyttämättä"
 
 #: c-family/c-warn.c:2023
 #, gcc-internal-format
@@ -68642,7 +68626,7 @@ msgstr "(%qs:n alustuksen lähistöllä)"
 
 #, fuzzy
 #~ msgid "variable %q+D set but not used"
-#~ msgstr "nimike %q+D määritelty mutta käytettämättä"
+#~ msgstr "nimike %q+D määritelty mutta käyttämättä"
 
 #~ msgid "jump to label %q+D"
 #~ msgstr "hyppy nimiöön %q+D"
@@ -68659,7 +68643,7 @@ msgstr "(%qs:n alustuksen lähistöllä)"
 
 #, fuzzy
 #~ msgid "parameter %q+D set but not used"
-#~ msgstr "nimike %q+D määritelty mutta käytettämättä"
+#~ msgstr "nimike %q+D määritelty mutta käyttämättä"
 
 #~ msgid "%q+D declared here"
 #~ msgstr "%q+D esitelty täällä"
diff --git a/gcc/po/zh_CN.po b/gcc/po/zh_CN.po
index 5701d2a5d9e..f18c00a6ddb 100644
--- a/gcc/po/zh_CN.po
+++ b/gcc/po/zh_CN.po
@@ -4,6 +4,7 @@
 # Meng Jie <zuxy.meng@gmail.com>, 2005-2014.
 # Jeff Bai <jeffbai@aosc.xyz>, 2015.
 # Mingye Wang (Arthur2e5) <arthur200126@gmail.com>, 2015, 2016.
+# Boyuan Yang <073plan@gmail.com>, 2019.
 #
 # Fellow translatiors:
 # Many of the fuzzy strings are caused by an addition of a period (".")
@@ -30,20 +31,19 @@
 #
 msgid ""
 msgstr ""
-"Project-Id-Version: gcc 6.1.0\n"
+"Project-Id-Version: gcc 9.1.0\n"
 "Report-Msgid-Bugs-To: https://gcc.gnu.org/bugs/\n"
 "POT-Creation-Date: 2019-05-02 20:28+0000\n"
-"PO-Revision-Date: 2016-04-30 17:13-0400\n"
-"Last-Translator: Mingye Wang (Arthur2e5) <arthur200126@gmail.com>\n"
+"PO-Revision-Date: 2019-08-19 15:13-0400\n"
+"Last-Translator: Boyuan Yang <073plan@gmail.com>\n"
 "Language-Team: Chinese (simplified) <i18n-zh@googlegroups.com>\n"
 "Language: zh_CN\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "X-Bugs: Report translation errors to the Language-Team address.\n"
-"X-Poedit-Basepath: C:/MSYS/source/gcc-4.6.0/gcc\n"
 "Plural-Forms: nplurals=1; plural=0;\n"
-"X-Generator: Poedit 1.8.7\n"
+"X-Generator: Poedit 2.2.3\n"
 
 #: cfgrtl.c:2705
 msgid "flow control insn inside a basic block"
@@ -478,12 +478,10 @@ msgid "  -o <file>                Place the output into <file>.\n"
 msgstr "  -o <文件>                输出到 <文件>。\n"
 
 #: gcc.c:3597
-#, fuzzy
-#| msgid "  -pie                     Create a position independent executable.\n"
 msgid ""
 "  -pie                     Create a dynamically linked position independent\n"
 "                           executable.\n"
-msgstr "  -pie                     生成位置无关可执行文件。\n"
+msgstr "  -pie                     生成动态链接的位置无关可执行文件。\n"
 
 #: gcc.c:3599
 msgid "  -shared                  Create a shared library.\n"
@@ -668,10 +666,9 @@ msgid "  rewrite [options] <dir>               Rewrite coverage file contents\n"
 msgstr "  rewrite [选项] <目录>                  覆写测试覆盖率文件内容\n"
 
 #: gcov-tool.c:270
-#, fuzzy, c-format
-#| msgid "    -n, --normalize <long long>         Normalize the profile\n"
+#, c-format
 msgid "    -n, --normalize <int64_t>           Normalize the profile\n"
-msgstr "    -n, --normalize <long long>         归一化配置\n"
+msgstr "    -n, --normalize <int64_t>           归一化配置\n"
 
 #: gcov-tool.c:272
 #, c-format
@@ -774,10 +771,9 @@ msgstr ""
 "%s。\n"
 
 #: gcov-tool.c:528
-#, fuzzy, c-format
-#| msgid "Copyright %s 2014-2016 Free Software Foundation, Inc.\n"
+#, c-format
 msgid "Copyright %s 2019 Free Software Foundation, Inc.\n"
-msgstr "版权所有 %s 2014-2015 自由软件基金会。\n"
+msgstr "版权所有 %s 2019 自由软件基金会。\n"
 
 #: gcov-tool.c:531 gcov.c:925
 #, c-format
@@ -791,15 +787,12 @@ msgstr ""
 "包括没有适销性和某一专用目的下的适用性担保。\n"
 
 #: gcov.c:885
-#, fuzzy, c-format
-#| msgid ""
-#| "Usage: gcov [OPTION]... SOURCE|OBJ...\n"
-#| "\n"
+#, c-format
 msgid ""
 "Usage: gcov [OPTION...] SOURCE|OBJ...\n"
 "\n"
 msgstr ""
-"用法：gconv [选项]... 源文件|对象文件...\n"
+"用法：gconv [选项...] 源文件|对象文件...\n"
 "\n"
 
 #: gcov.c:886
@@ -844,22 +837,19 @@ msgid "  -h, --help                      Print this help, then exit\n"
 msgstr "  -h, --help                      打印此帮助并退出\n"
 
 #: gcov.c:894
-#, fuzzy, c-format
-#| msgid "  -n, --no-output                 Do not create an output file\n"
+#, c-format
 msgid "  -i, --json-format               Output JSON intermediate format into .gcov.json.gz file\n"
-msgstr "  -n, --no-output                 不创建输出文件\n"
+msgstr "  -i, --json-format               以 JSON 中间格式输出至 .gcov.json.gz 文件\n"
 
 #: gcov.c:895
-#, fuzzy, c-format
-#| msgid "  -m, --demangled-names           Output demangled function names\n"
+#, c-format
 msgid "  -j, --human-readable            Output human readable numbers\n"
-msgstr "  -m, --demangled-names           输出解码后的函数名\n"
+msgstr "  -j, --human-readable            输出人类可读的数字\n"
 
 #: gcov.c:896
-#, fuzzy, c-format
-#| msgid "  -n, --no-output                 Do not create an output file\n"
+#, c-format
 msgid "  -k, --use-colors                Emit colored output\n"
-msgstr "  -n, --no-output                 不创建输出文件\n"
+msgstr "  -k, --use-colors                使用带颜色的输出\n"
 
 #: gcov.c:897
 #, c-format
@@ -904,10 +894,9 @@ msgid "  -s, --source-prefix DIR         Source prefix to elide\n"
 msgstr "  -s, --source-prefix 目录        要略去的来源前缀\n"
 
 #: gcov.c:906
-#, fuzzy, c-format
-#| msgid "  -n, --no-output                 Do not create an output file\n"
+#, c-format
 msgid "  -t, --stdout                    Output to stdout instead of a file\n"
-msgstr "  -n, --no-output                 不创建输出文件\n"
+msgstr "  -t, --stdout                    输出至标准输出而非文件\n"
 
 #: gcov.c:907
 #, c-format
@@ -920,10 +909,9 @@ msgid "  -v, --version                   Print version number, then exit\n"
 msgstr "  -v, --version                    打印版本号并退出\n"
 
 #: gcov.c:909
-#, fuzzy, c-format
-#| msgid "    -v, --verbose                       Verbose mode\n"
+#, c-format
 msgid "  -w, --verbose                   Print verbose informations\n"
-msgstr "    -v, --verbo      se                 输出更多信息\n"
+msgstr "  -w, --verbose                   输出详细信息\n"
 
 #: gcov.c:910
 #, fuzzy, c-format
@@ -937,10 +925,9 @@ msgid "gcov %s%s\n"
 msgstr "gcov %s%s\n"
 
 #: gcov.c:1250
-#, fuzzy, c-format
-#| msgid "Treat the input file as already preprocessed"
+#, c-format
 msgid "'%s' file is already processed\n"
-msgstr "将输入文件当作已经预处理过的"
+msgstr ""
 
 #: gcov.c:1364
 #, c-format
@@ -968,16 +955,14 @@ msgid "\n"
 msgstr "\n"
 
 #: gcov.c:1489
-#, fuzzy, c-format
-#| msgid "%s: Cannot open output file: %s\n"
+#, c-format
 msgid "Cannot open JSON output file %s\n"
-msgstr "%s：无法打开输出文件：%s\n"
+msgstr "无法打开 JSON 输出文件 %s\n"
 
 #: gcov.c:1497
-#, fuzzy, c-format
-#| msgid "Error writing output file '%s'\n"
+#, c-format
 msgid "Error writing JSON output file %s\n"
-msgstr "写入到输出文件 '%s' 时出错\n"
+msgstr "写入到 JSON 输出文件 %s 时出错\n"
 
 #: gcov.c:1664
 #, c-format
@@ -3473,8 +3458,9 @@ msgid "unknown move insn:"
 msgstr "无效的 move 指令："
 
 #: config/avr/avr.c:6279
+#, fuzzy
 msgid "bad shift insn:"
-msgstr "错误的 shift 指令"
+msgstr "错误的 shift 指令:"
 
 #: config/avr/avr.c:6387 config/avr/avr.c:6868 config/avr/avr.c:7283
 msgid "internal compiler error.  Incorrect shift:"
@@ -4204,10 +4190,9 @@ msgid "invalid %%q value"
 msgstr "无效 %%q 值"
 
 #: config/rs6000/rs6000.c:21141
-#, fuzzy, c-format
-#| msgid "invalid %%J value"
+#, c-format
 msgid "invalid %%t value"
-msgstr "无效 %%J 值"
+msgstr "无效 %%t 值"
 
 #: config/rs6000/rs6000.c:21158
 #, c-format
@@ -4225,21 +4210,19 @@ msgid "invalid %%v value"
 msgstr "无效 %%v 值"
 
 #: config/rs6000/rs6000.c:21234
-#, fuzzy, c-format
-#| msgid "invalid %%J value"
+#, c-format
 msgid "invalid %%V value"
-msgstr "无效 %%J 值"
+msgstr "无效 %%V 值"
 
 #: config/rs6000/rs6000.c:21251 config/xtensa/xtensa.c:2439
 #, c-format
 msgid "invalid %%x value"
-msgstr "无效的 %%x 值"
+msgstr "无效 %%x 值"
 
 #: config/rs6000/rs6000.c:21308
-#, fuzzy, c-format
-#| msgid "invalid %%J value"
+#, c-format
 msgid "invalid %%z value"
-msgstr "无效 %%J 值"
+msgstr "无效 %%z 值"
 
 #: config/rs6000/rs6000.c:21377
 #, c-format
@@ -4626,7 +4609,7 @@ msgstr "或称"
 
 #: c/c-objc-common.c:213
 msgid "({anonymous})"
-msgstr "{{匿名}}"
+msgstr "({匿名})"
 
 #. If we have
 #. declaration-specifiers declarator decl-specs
@@ -4884,7 +4867,7 @@ msgstr "vtable for "
 
 #: cp/error.c:1186
 msgid "<return value> "
-msgstr "<返回值>"
+msgstr "<返回值> "
 
 #: cp/error.c:1201
 msgid "{anonymous}"
@@ -5196,9 +5179,8 @@ msgid "arguments '%s' and '%s' for intrinsic '%s'"
 msgstr "‘%s’和‘%s’用作内建函数‘%s’的参数"
 
 #: fortran/error.c:853
-#, fuzzy
 msgid "Fortran 2018 deleted feature:"
-msgstr "遵循 ISO Fortran 2008 标准"
+msgstr "Fortran 2018 删除的特性："
 
 #: fortran/error.c:855
 #, fuzzy
@@ -5207,7 +5189,7 @@ msgstr "遵循 ISO Fortran 2008 标准"
 
 #: fortran/error.c:857
 msgid "Fortran 2018:"
-msgstr ""
+msgstr "Fortran 2018："
 
 #: fortran/error.c:859
 #, fuzzy
@@ -5215,9 +5197,8 @@ msgid "Fortran 2008 obsolescent feature:"
 msgstr "遵循 ISO Fortran 2008 标准"
 
 #: fortran/error.c:865
-#, fuzzy
 msgid "GNU Extension:"
-msgstr "使用 PE 格式的 GNU 扩展来对齐 common 数据"
+msgstr "GNU 扩展："
 
 #: fortran/error.c:867
 #, fuzzy
@@ -5230,9 +5211,8 @@ msgid "Obsolescent feature:"
 msgstr "对声明中的过时用法给出警告"
 
 #: fortran/error.c:871
-#, fuzzy
 msgid "Deleted feature:"
-msgstr "%L处的 H 格式限定符已在 Fortran 95 中被删除"
+msgstr "删除的特性："
 
 #: fortran/expr.c:3632
 msgid "array assignment"
@@ -5919,10 +5899,8 @@ msgid "gsplit-dwarf is not supported on this platform"
 msgstr "%qE属性在此平台上不受支持"
 
 #: config/darwin.h:170
-#, fuzzy
-#| msgid "-fpic is not supported"
 msgid "rdynamic is not supported"
-msgstr "不支持 -fpic"
+msgstr "不支持 rdynamic"
 
 #: config/darwin.h:258
 msgid "-current_version only allowed with -dynamiclib"
@@ -6307,16 +6285,12 @@ msgid "Warn about zero-trip DO loops."
 msgstr "对长度为 0 的格式字符串给出警告"
 
 #: fortran/lang.opt:354
-#, fuzzy
-#| msgid "Enable preprocessing"
 msgid "Enable preprocessing."
-msgstr "启用预处理"
+msgstr "启用预处理。"
 
 #: fortran/lang.opt:362
-#, fuzzy
-#| msgid "Disable preprocessing"
 msgid "Disable preprocessing."
-msgstr "禁用预处理"
+msgstr "禁用预处理。"
 
 #: fortran/lang.opt:370
 #, fuzzy
@@ -6922,10 +6896,8 @@ msgid "Do not generate #line directives."
 msgstr "不生成 #line 指令"
 
 #: c-family/c.opt:257
-#, fuzzy
-#| msgid "-U<macro>\tUndefine <macro>"
 msgid "-U<macro>\tUndefine <macro>."
-msgstr "-U<宏>\t取消定义宏"
+msgstr "-U<宏>\t取消定义<宏>。"
 
 #: c-family/c.opt:261
 #, fuzzy
@@ -7116,10 +7088,8 @@ msgid "Warn about possibly nested block comments, and C++ comments spanning more
 msgstr "对可能嵌套的注释和长度超过一个物理行长的 C++ 注释给出警告"
 
 #: c-family/c.opt:437
-#, fuzzy
-#| msgid "Synonym for -Wcomment"
 msgid "Synonym for -Wcomment."
-msgstr "-Wcomment 的同义词"
+msgstr "-Wcomment 的同义词。"
 
 #: c-family/c.opt:441
 #, fuzzy
@@ -8054,16 +8024,12 @@ msgstr "可变参数函数必须使用基础的 AAPCS 变种"
 
 #: c-family/c.opt:1282 c-family/c.opt:1530 c-family/c.opt:1854
 #: c-family/c.opt:1858 c-family/c.opt:1874
-#, fuzzy
-#| msgid "No longer supported"
 msgid "No longer supported."
-msgstr "不再受支持"
+msgstr "不再支持。"
 
 #: c-family/c.opt:1286
-#, fuzzy
-#| msgid "Recognize the \"asm\" keyword"
 msgid "Recognize the \"asm\" keyword."
-msgstr "识别“asm”关键字"
+msgstr "识别“asm”关键字。"
 
 #: c-family/c.opt:1294
 #, fuzzy
@@ -8197,10 +8163,8 @@ msgid "Do not assume that standard C libraries and \"main\" exist."
 msgstr "不假定标准 C 库和“main”存在"
 
 #: c-family/c.opt:1505
-#, fuzzy
-#| msgid "Recognize GNU-defined keywords"
 msgid "Recognize GNU-defined keywords."
-msgstr "识别 GNU 定义的关键字"
+msgstr "识别 GNU 定义的关键字。"
 
 #: c-family/c.opt:1509
 #, fuzzy
@@ -8495,10 +8459,8 @@ msgid "When \"signed\" or \"unsigned\" is not given make the bitfield unsigned."
 msgstr "未指定“signed”或“unsigned”时默认位段为无符号的"
 
 #: c-family/c.opt:1834 ada/gcc-interface/lang.opt:85
-#, fuzzy
-#| msgid "Make \"char\" unsigned by default"
 msgid "Make \"char\" unsigned by default."
-msgstr "使“char”类型默认为无符号"
+msgstr "使“char”类型默认为无符号。"
 
 #: c-family/c.opt:1838
 #, fuzzy
@@ -8759,14 +8721,12 @@ msgid "Conform to the ISO 2011 C++ standard with GNU extensions."
 msgstr "遵循 ISO 1990 C 标准，也支持 GNU 扩展"
 
 #: c-family/c.opt:2059
-#, fuzzy
 msgid "Deprecated in favor of -std=gnu++11."
-msgstr "已弃用，请改用 -std=gnu99"
+msgstr "已弃用，请改用 -std=gnu++11。"
 
 #: c-family/c.opt:2063
-#, fuzzy
 msgid "Deprecated in favor of -std=gnu++14."
-msgstr "已弃用，请改用 -std=gnu99"
+msgstr "已弃用，请改用 -std=gnu++14。"
 
 #: c-family/c.opt:2067
 #, fuzzy
@@ -8775,9 +8735,8 @@ msgid "Conform to the ISO 2014 C++ standard with GNU extensions."
 msgstr "遵循 ISO 1990 C 标准，也支持 GNU 扩展"
 
 #: c-family/c.opt:2071
-#, fuzzy
 msgid "Deprecated in favor of -std=gnu++17."
-msgstr "已弃用，请改用 -std=gnu99"
+msgstr "已弃用，请改用 -std=gnu+17。"
 
 #: c-family/c.opt:2075
 #, fuzzy
@@ -8798,9 +8757,8 @@ msgid "Conform to the ISO 2011 C standard with GNU extensions."
 msgstr "遵循 ISO 1990 C 标准，也支持 GNU 扩展"
 
 #: c-family/c.opt:2087
-#, fuzzy
 msgid "Deprecated in favor of -std=gnu11."
-msgstr "已弃用，请改用 -std=gnu99"
+msgstr "已弃用，请改用 -std=gnu11。"
 
 #: c-family/c.opt:2091 c-family/c.opt:2095
 #, fuzzy
@@ -8845,16 +8803,12 @@ msgid "Deprecated in favor of -std=iso9899:1999."
 msgstr "已弃用，为 -std=iso9899:1999 所取代"
 
 #: c-family/c.opt:2150
-#, fuzzy
-#| msgid "Enable traditional preprocessing"
 msgid "Enable traditional preprocessing."
-msgstr "启用传统预处理"
+msgstr "启用传统预处理。"
 
 #: c-family/c.opt:2154
-#, fuzzy
-#| msgid "-trigraphs\tSupport ISO C trigraphs"
 msgid "-trigraphs\tSupport ISO C trigraphs."
-msgstr "-trigraphs\t支持 ISO C 三元符"
+msgstr "-trigraphs\t支持 ISO C 三元符。"
 
 #: c-family/c.opt:2158
 #, fuzzy
@@ -9004,7 +8958,7 @@ msgstr "解析后显示代码树"
 
 #: d/lang.opt:242
 msgid "Ignore unsupported pragmas."
-msgstr ""
+msgstr "忽略不支持的 pragma。"
 
 #: d/lang.opt:246
 #, fuzzy
@@ -9272,7 +9226,7 @@ msgstr "总认为位段长与 int 相同"
 
 #: config/linux-android.opt:23
 msgid "Generate code for the Android platform."
-msgstr "为 Android 操作系统生成代码。"
+msgstr "为 Android 平台生成代码。"
 
 #: config/mmix/mmix.opt:24
 #, fuzzy
@@ -9700,10 +9654,8 @@ msgid "Generate code for a ColdFire v4e."
 msgstr "为 ColdFire v4e 生成代码"
 
 #: config/m68k/m68k.opt:123
-#, fuzzy
-#| msgid "Specify the target CPU"
 msgid "Specify the target CPU."
-msgstr "选择目标 CPU"
+msgstr "指定目标 CPU。"
 
 #: config/m68k/m68k.opt:127
 #, fuzzy
@@ -11831,10 +11783,8 @@ msgid "Set the max size of data eligible for the TDA area."
 msgstr "为 TDA 区域合格的数据设置最大尺寸"
 
 #: config/v850/v850.opt:82
-#, fuzzy
-#| msgid "Do not enforce strict alignment"
 msgid "Do not enforce strict alignment."
-msgstr "不强制严格对齐"
+msgstr "不强制严格对齐。"
 
 #: config/v850/v850.opt:86
 #, fuzzy
@@ -11842,22 +11792,16 @@ msgid "Put jump tables for switch statements into the .data section rather than
 msgstr "置放跳跃式表格用于开关叙述进入.data 区段而非.code 区段"
 
 #: config/v850/v850.opt:93
-#, fuzzy
-#| msgid "Compile for the v850 processor"
 msgid "Compile for the v850 processor."
-msgstr "为 v850 处理器编译"
+msgstr "为 v850 处理器编译。"
 
 #: config/v850/v850.opt:97
-#, fuzzy
-#| msgid "Compile for the v850e processor"
 msgid "Compile for the v850e processor."
-msgstr "为 v850e 处理器编译"
+msgstr "为 v850e 处理器编译。"
 
 #: config/v850/v850.opt:101
-#, fuzzy
-#| msgid "Compile for the v850e1 processor"
 msgid "Compile for the v850e1 processor."
-msgstr "为 v850e1 处理器编译"
+msgstr "为 v850e1 处理器编译。"
 
 #: config/v850/v850.opt:105
 #, fuzzy
@@ -11866,21 +11810,16 @@ msgid "Compile for the v850es variant of the v850e1."
 msgstr "为 v850e1 的 v850es 变种编译"
 
 #: config/v850/v850.opt:109
-#, fuzzy
-#| msgid "Compile for the v850e2 processor"
 msgid "Compile for the v850e2 processor."
-msgstr "为 v850e2 处理器编译"
+msgstr "为 v850e2 处理器编译。"
 
 #: config/v850/v850.opt:113
-#, fuzzy
-#| msgid "Compile for the v850e2v3 processor"
 msgid "Compile for the v850e2v3 processor."
-msgstr "为 v850e2v3 处理器编译"
+msgstr "为 v850e2v3 处理器编译。"
 
 #: config/v850/v850.opt:117
-#, fuzzy
 msgid "Compile for the v850e3v5 processor."
-msgstr "为 v850e2v3 处理器编译"
+msgstr "为 v850e2v3 处理器编译。"
 
 #: config/v850/v850.opt:124
 #, fuzzy
@@ -11919,9 +11858,8 @@ msgid "Enable support for the RH850 ABI.  This is the default."
 msgstr "启用使用 RX FPU 指令。这是默认值。"
 
 #: config/v850/v850.opt:155
-#, fuzzy
 msgid "Enable support for the old GCC ABI."
-msgstr "启用对巨型对象的支持"
+msgstr "启用对旧有 GCC ABI 的支持。"
 
 #: config/v850/v850.opt:159
 msgid "Support alignments of up to 64-bits."
@@ -11940,26 +11878,20 @@ msgid "Support legacy multi-threading."
 msgstr "支持传统多线程"
 
 #: config/lynx.opt:27
-#, fuzzy
-#| msgid "Use shared libraries"
 msgid "Use shared libraries."
-msgstr "使用共享库"
+msgstr "使用共享库。"
 
 #: config/lynx.opt:31
-#, fuzzy
-#| msgid "Support multi-threading"
 msgid "Support multi-threading."
-msgstr "支持多线程"
+msgstr "支持多线程。"
 
 #: config/nvptx/nvptx.opt:22 config/gcn/gcn.opt:47
-#, fuzzy
 msgid "Generate code for a 32-bit ABI."
-msgstr "生成 32 位 SHmedia 代码"
+msgstr "为 32 位 ABI 生成代码。"
 
 #: config/nvptx/nvptx.opt:26 config/gcn/gcn.opt:51
-#, fuzzy
 msgid "Generate code for a 64-bit ABI."
-msgstr "生成 64 位代码"
+msgstr "为 64 位 ABI 生成代码。"
 
 #: config/nvptx/nvptx.opt:30
 #, fuzzy
@@ -12034,9 +11966,8 @@ msgid "Treat data references as near, far or medium. medium is default."
 msgstr "对待数据参考作为接近，far 或中。中是缺省"
 
 #: config/cr16/cr16.opt:42
-#, fuzzy
 msgid "Generate code for CR16C architecture."
-msgstr "为 Android 操作系统生成代码。"
+msgstr "为 CR16C 架构生成代码。"
 
 #: config/cr16/cr16.opt:46
 #, fuzzy
@@ -12157,22 +12088,16 @@ msgid "Do not link against the device-specific library lib<MCU>.a."
 msgstr ""
 
 #: config/m32r/m32r.opt:34
-#, fuzzy
-#| msgid "Compile for the m32rx"
 msgid "Compile for the m32rx."
-msgstr "为 m32rx 编译"
+msgstr "为 m32rx 编译。"
 
 #: config/m32r/m32r.opt:38
-#, fuzzy
-#| msgid "Compile for the m32r2"
 msgid "Compile for the m32r2."
-msgstr "为 m32r2 编译"
+msgstr "为 m32r2 编译。"
 
 #: config/m32r/m32r.opt:42
-#, fuzzy
-#| msgid "Compile for the m32r"
 msgid "Compile for the m32r."
-msgstr "为 m32r 编译"
+msgstr "为 m32r 编译。"
 
 #: config/m32r/m32r.opt:46
 #, fuzzy
@@ -12259,16 +12184,12 @@ msgid "Specify main object for TPF-OS."
 msgstr "指定 TPF-OS 的主对象"
 
 #: config/s390/s390.opt:48
-#, fuzzy
-#| msgid "31 bit ABI"
 msgid "31 bit ABI."
-msgstr "31 位 ABI"
+msgstr "31 位 ABI。"
 
 #: config/s390/s390.opt:52
-#, fuzzy
-#| msgid "64 bit ABI"
 msgid "64 bit ABI."
-msgstr "64 位 ABI"
+msgstr "64 位 ABI。"
 
 #: config/s390/s390.opt:120
 #, fuzzy
@@ -12284,9 +12205,8 @@ msgstr "附加的调试输出"
 
 #: config/s390/s390.opt:128
 #, fuzzy
-#| msgid "ESA/390 architecture"
 msgid "ESA/390 architecture."
-msgstr "ESA/390 结构"
+msgstr "ESA/390 结构。"
 
 #: config/s390/s390.opt:132
 #, fuzzy
@@ -12739,9 +12659,8 @@ msgstr "生成使用硬件浮点指令的代码"
 #: config/sparc/sparc.opt:30 config/sparc/sparc.opt:34
 #: config/visium/visium.opt:37
 #, fuzzy
-#| msgid "Use hardware FP"
 msgid "Use hardware FP."
-msgstr "使用硬件浮点单元"
+msgstr "使用硬件浮点单元。"
 
 #: config/sparc/sparc.opt:38 config/visium/visium.opt:41
 #, fuzzy
@@ -12785,10 +12704,8 @@ msgid "Enable Local Register Allocation."
 msgstr "启用 clip 指令"
 
 #: config/sparc/sparc.opt:66
-#, fuzzy
-#| msgid "Compile for V8+ ABI"
 msgid "Compile for V8+ ABI."
-msgstr "为 V8+ ABI 编译"
+msgstr "为 V8+ ABI 编译。"
 
 #: config/sparc/sparc.opt:70
 #, fuzzy
@@ -12851,16 +12768,12 @@ msgid "Pointers are 32-bit."
 msgstr "指针是 32 位"
 
 #: config/sparc/sparc.opt:118
-#, fuzzy
-#| msgid "Use 64-bit ABI"
 msgid "Use 64-bit ABI."
-msgstr "使用 64 位 ABI"
+msgstr "使用 64 位 ABI。"
 
 #: config/sparc/sparc.opt:122
-#, fuzzy
-#| msgid "Use 32-bit ABI"
 msgid "Use 32-bit ABI."
-msgstr "使用 32 位 ABI"
+msgstr "使用 32 位 ABI。"
 
 #: config/sparc/sparc.opt:126
 #, fuzzy
@@ -12967,10 +12880,8 @@ msgid "Compile for 32-bit pointers."
 msgstr "为 32 位指针编译"
 
 #: config/rs6000/aix64.opt:32 config/rs6000/linux64.opt:28
-#, fuzzy
-#| msgid "Select code model"
 msgid "Select code model."
-msgstr "选择代码模型"
+msgstr "选择代码模型。"
 
 #: config/rs6000/aix64.opt:49
 #, fuzzy
@@ -13033,10 +12944,8 @@ msgid "Use extended PowerPC V2.05 move floating point to/from GPR instructions."
 msgstr "使用扩展 PowerPC V2.05 通用寄存器浮点转移指令"
 
 #: config/rs6000/rs6000.opt:153
-#, fuzzy
-#| msgid "Use AltiVec instructions"
 msgid "Use AltiVec instructions."
-msgstr "使用 AltiVec 指令"
+msgstr "使用 AltiVec 指令。"
 
 #: config/rs6000/rs6000.opt:157
 #, fuzzy
@@ -13242,16 +13151,12 @@ msgid "Do not use the AltiVec ABI extensions."
 msgstr "不使用位段指令"
 
 #: config/rs6000/rs6000.opt:358
-#, fuzzy
-#| msgid "Use the ELFv1 ABI"
 msgid "Use the ELFv1 ABI."
-msgstr "使用 ELFv1 ABI"
+msgstr "使用 ELFv1 ABI。"
 
 #: config/rs6000/rs6000.opt:362
-#, fuzzy
-#| msgid "Use the ELFv2 ABI"
 msgid "Use the ELFv2 ABI."
-msgstr "使用 ELFv2 ABI"
+msgstr "使用 ELFv2 ABI。"
 
 #: config/rs6000/rs6000.opt:382
 #, fuzzy
@@ -13477,10 +13382,8 @@ msgid "Assume all variable arg functions are prototyped."
 msgstr "假设所有可变参数函数都有原型"
 
 #: config/rs6000/sysv4.opt:103
-#, fuzzy
-#| msgid "Use EABI"
 msgid "Use EABI."
-msgstr "使用 EABI"
+msgstr "使用 EABI。"
 
 #: config/rs6000/sysv4.opt:107
 #, fuzzy
@@ -13776,10 +13679,8 @@ msgid "Use divide emulation."
 msgstr "使用除法指令"
 
 #: config/or1k/or1k.opt:67
-#, fuzzy
-#| msgid "Use the soft multiply emulation (default)"
 msgid "Use multiply emulation."
-msgstr "使用软件模拟乘法(默认)"
+msgstr "使用乘法模拟。"
 
 #: config/nios2/elf.opt:26
 #, fuzzy
@@ -66815,14 +66716,14 @@ msgid "Include directory %qs: %s"
 msgstr "不包含子目录注释"
 
 #: fortran/scanner.c:336
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "Nonexistent include directory %qs"
-msgstr "忽略不存在的目录“%s”\n"
+msgstr "不存在的 include 目录 %qs"
 
 #: fortran/scanner.c:341
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qs is not a directory"
-msgstr "不是目录"
+msgstr "%qs 不是目录"
 
 #: fortran/scanner.c:744
 #, fuzzy, gcc-internal-format, gfc-internal-format
@@ -66893,9 +66794,9 @@ msgid "Illegal preprocessor directive"
 msgstr "%s:%d：无效的预处理指令"
 
 #: fortran/scanner.c:2471
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "Cannot open file %qs"
-msgstr "无法打开文件 %s\n"
+msgstr "无法打开文件 %qs"
 
 #: fortran/simplify.c:92
 #, gcc-internal-format, gfc-internal-format
@@ -69343,9 +69244,9 @@ msgid "%<-mfused-madd%> is deprecated; use %<-ffp-contract=%> instead"
 msgstr "已弃用%<-mfused-madd%>；请改用%<-ffp-contract=%>"
 
 #: config/microblaze/microblaze.opt:87
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qs is deprecated; use -fstack-check"
-msgstr "已弃用%qE：%s"
+msgstr "%qs 已弃用；请换用 -fstack-check"
 
 #: config/microblaze/microblaze.opt:95
 #, gcc-internal-format
@@ -69356,9 +69257,9 @@ msgstr "%qs 已弃用；请换用 -fno-zero-initialized-in-bss"
 #: config/arc/arc.opt:349 config/arc/arc.opt:353 config/arc/arc.opt:357
 #: config/arc/arc.opt:361 config/arc/arc.opt:364 config/arc/arc.opt:367
 #: config/arc/arc.opt:384
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "%qs is deprecated"
-msgstr "已弃用%qE"
+msgstr "%qs 已弃用"
 
 #: lto/lang.opt:28
 #, fuzzy, gcc-internal-format
@@ -69392,9 +69293,9 @@ msgid "unknown Control-Flow Protection Level %qs"
 msgstr "未知的栈重用级别%qs"
 
 #: common.opt:1777
-#, fuzzy, gcc-internal-format
+#, gcc-internal-format
 msgid "unknown IRA algorithm %qs"
-msgstr "未知的 TLS 模型%qs"
+msgstr "未知的 IRA 算法 %qs"
 
 #: common.opt:1790
 #, fuzzy, gcc-internal-format
@@ -69435,7 +69336,7 @@ msgstr "未知的 TLS 模型%qs"
 #: common.opt:2530
 #, gcc-internal-format
 msgid "unknown TLS model %qs"
-msgstr "未知的 TLS 模型%qs"
+msgstr "未知的 TLS 模型 %qs"
 
 #: common.opt:2862
 #, fuzzy, gcc-internal-format
diff --git a/gcc/rtlanal.c b/gcc/rtlanal.c
index 268a38799d6..01af063a222 100644
--- a/gcc/rtlanal.c
+++ b/gcc/rtlanal.c
@@ -4793,7 +4793,7 @@ nonzero_bits1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,
 	       || ((extend_op = load_extend_op (inner_mode)) == SIGN_EXTEND
 		   ? val_signbit_known_set_p (inner_mode, nonzero)
 		   : extend_op != ZERO_EXTEND)
-	       || (!MEM_P (SUBREG_REG (x)) && !REG_P (SUBREG_REG (x))))
+	       || !MEM_P (SUBREG_REG (x)))
 	      && xmode_width > inner_width)
 	    nonzero
 	      |= (GET_MODE_MASK (GET_MODE (x)) & ~GET_MODE_MASK (inner_mode));
diff --git a/gcc/symbol-summary.h b/gcc/symbol-summary.h
index 0219f3a81ea..74544fbf879 100644
--- a/gcc/symbol-summary.h
+++ b/gcc/symbol-summary.h
@@ -461,6 +461,8 @@ fast_function_summary<T *, V>::release ()
     if ((*m_vector)[i] != NULL)
       this->release ((*m_vector)[i]);
 
+  vec_free (m_vector);
+
   this->m_released = true;
 }
 
@@ -926,6 +928,8 @@ fast_call_summary<T *, V>::release ()
     if ((*m_vector)[i] != NULL)
       this->release ((*m_vector)[i]);
 
+  vec_free (m_vector);
+
   this->m_released = true;
 }
 
diff --git a/gcc/symtab.c b/gcc/symtab.c
index 29f6cdc4667..33b4be79c0f 100644
--- a/gcc/symtab.c
+++ b/gcc/symtab.c
@@ -2328,10 +2328,18 @@ symtab_node::output_to_lto_symbol_table_p (void)
      first place.  */
   if (VAR_P (decl) && DECL_HARD_REGISTER (decl))
     return false;
-  /* FIXME: Builtins corresponding to real functions probably should have
-     symbol table entries.  */
-  if (TREE_CODE (decl) == FUNCTION_DECL && fndecl_built_in_p (decl))
-    return false;
+  if (TREE_CODE (decl) == FUNCTION_DECL && !definition
+      && fndecl_built_in_p (decl))
+    {
+      /* Builtins like those for most math functions have actual implementations
+	 in libraries so make sure to output references into the symbol table to
+	 make those libraries referenced.  Note this is incomplete handling for
+	 now and only covers math functions.  */
+      if (builtin_with_linkage_p (decl))
+	return true;
+      else
+	return false;
+    }
 
   /* We have real symbol that should be in symbol table.  However try to trim
      down the refernces to libraries bit more because linker will otherwise
