diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1e236f9..239a6b4 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -123,4 +123,4 @@ add_subdirectory(include)
 add_subdirectory(share)
 add_subdirectory(src)
 add_subdirectory(tests)
-add_subdirectory(docs/old)
+
diff --git a/docs/.gitattributes b/docs/.gitattributes
deleted file mode 100644
index f33d463..0000000
--- a/docs/.gitattributes
+++ /dev/null
@@ -1,2 +0,0 @@
-*.graffle      -diff -whitespace
-/*.[1-9]       -diff -whitespace
diff --git a/docs/CMakeLists.txt b/docs/CMakeLists.txt
deleted file mode 100644
index cdda9e1..0000000
--- a/docs/CMakeLists.txt
+++ /dev/null
@@ -1,101 +0,0 @@
-# -*- coding: utf-8 -*-
-# ----------------------------------------------------------------------
-# Copyright © 2011-2014, RedJack, LLC.
-# All rights reserved.
-#
-# Please see the COPYING file in this distribution for license details.
-# ----------------------------------------------------------------------
-
-# Fill in this with the text that you want to include in the header and footer
-# of each man page.
-
-set(MAN_HEADER "${PROJECT_NAME} documentation")
-set(MAN_FOOTER "${PROJECT_NAME}")
-
-# Fill this in with any man pages that should be built from a pandoc source
-# file.  For a man page called foo.5, there should be a pandoc source file
-# called foo.5.pandoc.
-
-set(MAN_PAGES
-)
-
-#-----------------------------------------------------------------------
-# Everything below is boilerplate!
-
-find_program(
-    PANDOC_EXECUTABLE
-    NAMES pandoc
-    HINTS ENV PANDOC_DIR
-    PATH_SUFFIXES bin
-    DOC "Pandoc man page generator"
-)
-
-set(GENERATE_DOC TRUE CACHE BOOL
-    "Whether to rebuild documentation")
-
-if (NOT PANDOC_EXECUTABLE)
-    message(WARNING "Unable to find pandoc documentation generator")
-    set(GENERATE_DOC FALSE)
-endif (NOT PANDOC_EXECUTABLE)
-
-
-# Link man pages go in docs/links
-
-macro(install_links section)
-    file(GLOB links "links/*.${section}")
-    if (links)
-        install(
-            FILES ${links}
-            DESTINATION "share/man/man${section}"
-        )
-    endif (links)
-endmacro(install_links section)
-
-install_links(1)   # commands
-install_links(3)   # library API
-install_links(4)   # special files and drivers
-install_links(5)   # file formats and conventions
-install_links(7)   # miscellaneous
-install_links(8)   # system commands
-
-
-# Man pages with actual content go in docs
-
-set(ALL_MANS)
-
-macro(pandocify name)
-    set(src  "${CMAKE_CURRENT_SOURCE_DIR}/${name}.pandoc")
-    set(dest "${CMAKE_CURRENT_SOURCE_DIR}/${name}")
-    get_filename_component(section "${name}" EXT)
-    string(REPLACE "." "" section "${section}")
-
-    # Only compile the markdown source into groff man pages if requested.
-    if (GENERATE_DOC)
-        add_custom_command(
-            OUTPUT ${dest}
-            COMMAND ${PANDOC_EXECUTABLE}
-                -f markdown -t man -s --smart
-                -V header="${MAN_HEADER}"
-                -V footer="${MAN_FOOTER}"
-                -V date=${RELEASE_DATE}
-                -o ${dest} ${src}
-            MAIN_DEPENDENCY ${src}
-            COMMENT "Building ${name}"
-        )
-        list(APPEND ALL_MANS ${dest})
-    endif (GENERATE_DOC)
-
-    # We should always have an already-compiled copy of each man page in the
-    # source tree, which we can install even if we didn't build fresh new
-    # copies.
-    install(
-        FILES ${dest}
-        DESTINATION "share/man/man${section}"
-    )
-endmacro(pandocify)
-
-foreach(MAN_PAGE ${MAN_PAGES})
-    pandocify(${MAN_PAGE})
-endforeach(MAN_PAGE)
-
-add_custom_target(doc ALL DEPENDS ${ALL_MANS})
diff --git a/docs/old/CMakeLists.txt b/docs/old/CMakeLists.txt
deleted file mode 100644
index 58b19cd..0000000
--- a/docs/old/CMakeLists.txt
+++ /dev/null
@@ -1,87 +0,0 @@
-# -*- coding: utf-8 -*-
-# ----------------------------------------------------------------------
-# Copyright © 2011-2014, RedJack, LLC.
-# All rights reserved.
-#
-# Please see the COPYING file in this distribution for license details.
-# ----------------------------------------------------------------------
-
-find_program(
-  SPHINX_EXECUTABLE
-  NAMES sphinx-build
-  HINTS ENV SPHINX_DIR
-  PATH_SUFFIXES bin
-  DOC "Sphinx documentation generator"
-)
-
-set(GENERATE_DOC TRUE)
-
-if (TILERA)
-    message(STATUS "Note: We don't build documentation on the Tilera platform")
-    set(GENERATE_DOC FALSE)
-endif (TILERA)
-
-if (NOT SPHINX_EXECUTABLE)
-  message(WARNING "Unable to find Sphinx documentation generator")
-  set(GENERATE_DOC FALSE)
-endif (NOT SPHINX_EXECUTABLE)
-
-set(INTERSPHINX_OVERRIDES "")
-
-macro(find_prereq_doc LIB_NAME)
-  execute_process(
-    COMMAND ${PKG_CONFIG_EXECUTABLE} --variable=sphinxdir ${LIB_NAME}
-    OUTPUT_VARIABLE LIB_SPHINX_DIR
-    OUTPUT_STRIP_TRAILING_WHITESPACE
-  )
-
-  if (LIB_SPHINX_DIR)
-    message(STATUS "Using ${LIB_NAME} docs in ${LIB_SPHINX_DIR}")
-    set(
-      INTERSPHINX_OVERRIDES
-      "${INTERSPHINX_OVERRIDES}\nintersphinx_mapping['${LIB_NAME}'] = ('${LIB_SPHINX_DIR}', None)"
-    )
-  endif (LIB_SPHINX_DIR)
-endmacro(find_prereq_doc)
-
-if (GENERATE_DOC)
-  set(SPHINX_SRC_CONF_FILE "${CMAKE_CURRENT_SOURCE_DIR}/conf.py")
-  set(SPHINX_CONF_FILE "${CMAKE_CURRENT_BINARY_DIR}/conf.py")
-  set(SPHINX_CACHE_DIR "${CMAKE_CURRENT_BINARY_DIR}/_doctrees")
-  set(SPHINX_HTML_DIR "${CMAKE_CURRENT_BINARY_DIR}/html")
-
-  # If your Sphinx documentation references the Sphinx documentation of
-  # any of your prerequisite libraries, add some calls to
-  # find_prereq_doc here:
-  #
-  # find_prereq_doc(libcork)
-
-  set(
-    VERSION_FOR_CONF_PY
-    "\nrelease=\"${VERSION}\"\nversion=\"${BASE_VERSION}\""
-  )
-  configure_file(${SPHINX_SRC_CONF_FILE} ${SPHINX_CONF_FILE} @ONLY)
-  file(COPY _static DESTINATION ${CMAKE_CURRENT_BINARY_DIR})
-  file(COPY _templates DESTINATION ${CMAKE_CURRENT_BINARY_DIR})
-
-  add_custom_target(old-doc ALL
-    ${SPHINX_EXECUTABLE}
-      -b html
-      -d "${SPHINX_CACHE_DIR}"
-      -c "${CMAKE_CURRENT_BINARY_DIR}"
-      "${CMAKE_CURRENT_SOURCE_DIR}"
-      "${SPHINX_HTML_DIR}"
-    COMMENT "Building HTML documentation with Sphinx"
-  )
-
-  list(APPEND CLEAN_FILES "${SPHINX_CACHE_DIR}" "${SPHINX_HTML_DIR}")
-  set_directory_properties(
-    PROPERTIES
-    ADDITIONAL_MAKE_CLEAN_FILES "${CLEAN_FILES}"
-  )
-
-  install(
-    DIRECTORY "${SPHINX_HTML_DIR}"
-    DESTINATION "share/doc/${PROJECT_NAME}"
-  )
-endif (GENERATE_DOC)
diff --git a/docs/old/_static/.keep b/docs/old/_static/.keep
deleted file mode 100644
index e69de29..0000000
diff --git a/docs/old/_static/docco-sphinx.css b/docs/old/_static/docco-sphinx.css
deleted file mode 100644
index 30139f6..0000000
--- a/docs/old/_static/docco-sphinx.css
+++ /dev/null
@@ -1,305 +0,0 @@
-@import url("basic.css");
-
-/* -- page layout ----------------------------------------------------------- */
-
-body {
-    font-family: 'Palatino Linotype', Palatino, 'URW Palladio L', 'Book Antiqua', FreeSerif, serif;
-    /*font-size: 95%;*/
-    font-size: 95%;
-    color: #252519;
-    margin: 0;
-    padding: 0;
-}
-
-div.document {
-}
-
-div.documentwrapper {
-    float: left;
-    width: 100%;
-}
-
-div.bodywrapper {
-    margin: 0 0 0 19em;
-    background-color: #ffffff;
-}
-
-div.body {
-    color: #252519;
-    padding: 30px 0px 30px 60px;
-    width: 40em;
-}
-
-div.footer {
-    width: 100%;
-    padding: 9px 0 9px 0;
-    text-align: center;
-    font-size: 75%;
-}
-
-div.footer a {
-    color: #261a3b;
-    text-decoration: underline;
-}
-
-div.related {
-    background-color: #eee;
-    border: 1px solid #ccc;
-    line-height: 30px;
-}
-
-div.related a {
-    color: #261a3b;
-}
-
-div.sphinxsidebar {
-    padding: 30px 0px 0 20px;
-    width: 19em;
-    color: #555;
-}
-
-div.sphinxsidebar a {
-    color: #555;
-}
-
-div.sphinxsidebar h3 {
-    font-size: 1.4em;
-    margin: 0;
-    padding: 0;
-}
-
-div.sphinxsidebar h4 {
-    font-size: 1.3em;
-    margin: 5px 0 0 0;
-    padding: 0;
-}
-
-div.sphinxsidebar p {
-}
-
-div.sphinxsidebar p.topless {
-    margin: 5px 10px 10px 10px;
-}
-
-div.sphinxsidebar ul {
-    margin: 10px;
-    padding: 0;
-    color: #ffffff;
-}
-
-div.sphinxsidebar li {
-    padding-top: 5px;
-    line-height: 115%;
-}
-
-div.sphinxsidebar input {
-    border: 1px solid #ccc;
-    font-family: sans-serif;
-    font-size: 1em;
-}
-
-
-
-/* -- hyperlink styles ------------------------------------------------------ */
-
-a {
-    color: #306060;
-    text-decoration: none;
-}
-
-a:visited {
-    color: #306060;
-    text-decoration: none;
-}
-
-a:hover {
-    text-decoration: underline;
-}
-
-
-
-/* -- body styles ----------------------------------------------------------- */
-
-div.body h1,
-div.body h2 {
-    border-top: 1px solid #ccc;
-    margin: 40px -20px 10px -20px;
-    padding: 3px 0 3px 0;
-}
-
-div.body h3,
-div.body h4,
-div.body h5,
-div.body h6 {
-    margin: 20px 0px -10px 0px;
-}
-
-div.body h1 { margin-top: 0; font-size: 200%; border: 0px; }
-div.body h2 { font-size: 160%; }
-div.body h3 { font-size: 140%; }
-div.body h4 { font-size: 120%; }
-div.body h5 { font-size: 110%; }
-div.body h6 { font-size: 100%; }
-
-a.headerlink {
-    color: #c60f0f;
-    font-size: 0.8em;
-    padding: 0 4px 0 4px;
-    text-decoration: none;
-}
-
-a.headerlink:hover {
-    background-color: #c60f0f;
-    color: white;
-}
-
-div.body p, div.body dd, div.body li {
-    line-height: 130%;
-}
-
-p.admonition-title {
-    margin-right: 0.3em;
-}
-
-div.admonition p.admonition-title + p {
-    display: inline;
-}
-
-div.admonition p {
-    margin-bottom: 5px;
-}
-
-div.admonition pre {
-    margin-bottom: 5px;
-}
-
-div.admonition ul, div.admonition ol {
-    margin-bottom: 5px;
-}
-
-div.note {
-    background-color: #eee;
-    border: 1px solid #ccc;
-}
-
-div.seealso {
-    background-color: #ffc;
-    border: 1px solid #ff6;
-}
-
-div.tip {
-    background-color: #e4e4ff;
-    border: 1px solid #ccc;
-}
-
-div.topic {
-    background-color: #eee;
-}
-
-div.warning {
-    background-color: #ffe4e4;
-    border: 1px solid #f66;
-}
-
-p.admonition-title {
-    display: inline;
-}
-
-p.admonition-title:after {
-    content: ":";
-}
-
-pre {
-    font-family: Menlo, Monaco, Consolas, "Lucida Console", monospace;
-    font-size: 80%;
-    padding: 5px;
-    background-color: #f5f5ff;
-    color: #333333;
-    line-height: 130%;
-    border: 1px solid #e5e5ee;
-    border-left: none;
-    border-right: none;
-}
-
-tt {
-    font-family: Menlo, Monaco, Consolas, "Lucida Console", monospace;
-    background-color: #f8f8ff;
-    border: 1px solid #dedede;
-    padding: 0 0.2em;
-    font-size: 85%;
-}
-
-a tt {
-    background-color: transparent;
-    border: 0px;
-}
-
-dt {
-    font-family: Menlo, Monaco, Consolas, "Lucida Console", monospace;
-    font-size: 90%;
-    line-height: 130%;
-}
-
-table.indextable dt {
-    font-family: 'Palatino Linotype', Palatino, 'URW Palladio L', 'Book Antiqua', FreeSerif, serif;
-    font-size: 100%;
-}
-
-em.property {
-    font-size: 90%;
-}
-
-tt.descclassname {
-    background-color: transparent;
-    border: 0px;
-    padding: 0px;
-}
-
-tt.descname {
-    background-color: transparent;
-    border: 0px;
-    font-size: 100%;
-    padding: 0px;
-}
-
-dt big {
-    font-family: 'Palatino Linotype', Palatino, 'URW Palladio L', 'Book Antiqua', FreeSerif, serif;
-    font-size: 140%;
-    padding: 0 2px;
-}
-
-dt big.param_start_brace {
-    padding: 0 6px;
-}
-
-dt big.param_end_brace {
-    padding: 0 6px;
-}
-
-dt span.optional {
-    font-family: 'Palatino Linotype', Palatino, 'URW Palladio L', 'Book Antiqua', FreeSerif, serif;
-    font-size: 140%;
-    padding: 0 2px;
-}
-
-th {
-    background-color: #ede;
-}
-
-.warning tt {
-    background: #efc2c2;
-}
-
-.note tt {
-    background: #d6d6d6;
-}
-
-.viewcode-back {
-    font-family: sans-serif;
-}
-
-div.viewcode-block:target {
-    background-color: #f4debf;
-    border-top: 1px solid #ac9;
-    border-bottom: 1px solid #ac9;
-}
diff --git a/docs/old/_static/pygments.css b/docs/old/_static/pygments.css
deleted file mode 100644
index fa06454..0000000
--- a/docs/old/_static/pygments.css
+++ /dev/null
@@ -1,61 +0,0 @@
-.highlight .hll { background-color: #ffffcc }
-.highlight .c { color: #408080; font-style: italic }  /* Comment */
-.highlight .err { border: 1px solid #FF0000 }         /* Error */
-.highlight .k { color: #954121 }                      /* Keyword */
-.highlight .o { color: #666666 }                      /* Operator */
-.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
-.highlight .cp { color: #BC7A00 }                     /* Comment.Preproc */
-.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
-.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
-.highlight .gd { color: #A00000 }                     /* Generic.Deleted */
-.highlight .ge { font-style: italic }                 /* Generic.Emph */
-.highlight .gr { color: #FF0000 }                     /* Generic.Error */
-.highlight .gh { color: #000080; font-weight: bold }  /* Generic.Heading */
-.highlight .gi { color: #00A000 }                     /* Generic.Inserted */
-.highlight .go { color: #808080 }                     /* Generic.Output */
-.highlight .gp { color: #000080; font-weight: bold }  /* Generic.Prompt */
-.highlight .gs { font-weight: bold }                  /* Generic.Strong */
-.highlight .gu { color: #800080; font-weight: bold }  /* Generic.Subheading */
-.highlight .gt { color: #0040D0 }                     /* Generic.Traceback */
-.highlight .kc { color: #954121 }                     /* Keyword.Constant */
-.highlight .kd { color: #954121; font-weight: bold }  /* Keyword.Declaration */
-.highlight .kn { color: #954121; font-weight: bold }  /* Keyword.Namespace */
-.highlight .kp { color: #954121 }                     /* Keyword.Pseudo */
-.highlight .kr { color: #954121; font-weight: bold }  /* Keyword.Reserved */
-.highlight .kt { color: #B00040 }                     /* Keyword.Type */
-.highlight .m { color: #666666 }                      /* Literal.Number */
-.highlight .s { color: #219161 }                      /* Literal.String */
-.highlight .na { color: #7D9029 }                     /* Name.Attribute */
-.highlight .nb { color: #954121 }                     /* Name.Builtin */
-.highlight .nc { color: #0000FF; font-weight: bold }  /* Name.Class */
-.highlight .no { color: #880000 }                     /* Name.Constant */
-.highlight .nd { color: #AA22FF }                     /* Name.Decorator */
-.highlight .ni { color: #999999; font-weight: bold }  /* Name.Entity */
-.highlight .ne { color: #D2413A; font-weight: bold }  /* Name.Exception */
-.highlight .nf { color: #0000FF }                     /* Name.Function */
-.highlight .nl { color: #A0A000 }                     /* Name.Label */
-.highlight .nn { color: #0000FF; font-weight: bold }  /* Name.Namespace */
-.highlight .nt { color: #954121; font-weight: bold }  /* Name.Tag */
-.highlight .nv { color: #19469D }                     /* Name.Variable */
-.highlight .ow { color: #AA22FF; font-weight: bold }  /* Operator.Word */
-.highlight .w { color: #bbbbbb }                      /* Text.Whitespace */
-.highlight .mf { color: #666666 }                     /* Literal.Number.Float */
-.highlight .mh { color: #666666 }                     /* Literal.Number.Hex */
-.highlight .mi { color: #666666 }                     /* Literal.Number.Integer */
-.highlight .mo { color: #666666 }                     /* Literal.Number.Oct */
-.highlight .sb { color: #219161 }                     /* Literal.String.Backtick */
-.highlight .sc { color: #219161 }                     /* Literal.String.Char */
-.highlight .sd { color: #219161; font-style: italic } /* Literal.String.Doc */
-.highlight .s2 { color: #219161 }                     /* Literal.String.Double */
-.highlight .se { color: #BB6622; font-weight: bold }  /* Literal.String.Escape */
-.highlight .sh { color: #219161 }                     /* Literal.String.Heredoc */
-.highlight .si { color: #BB6688; font-weight: bold }  /* Literal.String.Interpol */
-.highlight .sx { color: #954121 }                     /* Literal.String.Other */
-.highlight .sr { color: #BB6688 }                     /* Literal.String.Regex */
-.highlight .s1 { color: #219161 }                     /* Literal.String.Single */
-.highlight .ss { color: #19469D }                     /* Literal.String.Symbol */
-.highlight .bp { color: #954121 }                     /* Name.Builtin.Pseudo */
-.highlight .vc { color: #19469D }                     /* Name.Variable.Class */
-.highlight .vg { color: #19469D }                     /* Name.Variable.Global */
-.highlight .vi { color: #19469D }                     /* Name.Variable.Instance */
-.highlight .il { color: #666666 }                     /* Literal.Number.Integer.Long */
diff --git a/docs/old/_templates/.keep b/docs/old/_templates/.keep
deleted file mode 100644
index e69de29..0000000
diff --git a/docs/old/allocation.rst b/docs/old/allocation.rst
deleted file mode 100644
index e7bb419..0000000
--- a/docs/old/allocation.rst
+++ /dev/null
@@ -1,344 +0,0 @@
-.. _allocation:
-
-*****************
-Memory allocation
-*****************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-One of the biggest hassles in writing C code is memory management.  libcork's
-memory allocation API tries to simplify this task as much as possible.  This is
-still C, so you still have to manage allocated memory manually — for instance,
-by keeping careful track of which section of code "owns" any memory that you've
-allocated from heap, and is therefore responsible for freeing it.  But we *can*
-make it easier to handle memory allocation failures, and provide helper macros
-for certain common allocation tasks.
-
-There is another `important use case`_ that we also want to support: giving
-application writers complete control over how the libraries they use allocate
-and deallocate memory.  libcork :ref:`provides <libcork-allocators>` this
-capability, giving you control over how, for instance, a hash table allocates
-its internal buckets.  If you're writing a library that links with libcork as a
-shared library, you'll get this behavior for free; if the application writer
-customizes how libcork allocates memory, your library will pick up that
-customization as well.  If you're embedding libcork, so that your library's
-clients can't tell (or care) that you're using libcork, then you'll want to
-expose your own similar customization interface.
-
-.. _important use case: https://blog.mozilla.org/nnethercote/2013/11/08/libraries-should-permit-custom-allocators/
-
-
-.. _allocation-api:
-
-Allocating memory
-=================
-
-The simplest part of the API is the part responsible for actually allocating and
-deallocating memory.  When using this part of the API, you don't have to worry
-about customization at all; the functions described here will automatically "do
-the right thing" based on how your library or application is configured.  The
-biggest thing to worry about is how to handle memory allocation failures.  We
-provide two strategies, "guaranteed" and "recoverable".
-
-The most common use case is that running out of memory is a Really Bad Thing,
-and there's nothing we can do to recover.  In this case, it doesn't make sense
-to check for memory allocation failures throughout your code, since you can't
-really do anything if it does happen.  The "guaranteed" family of functions
-handles that error checking for you, and guarantees that if the allocation
-function returns, it will return a valid piece of memory.  If the allocation
-fails, the function will never return.  That allows you to right simple and safe
-code like the following::
-
-    struct my_type  *instance = cork_new(struct my_type);
-    /* Just start using instance; don't worry about verifying that it's
-     * not NULL! */
-
-On the other hand, you might be writing some code that can gracefully handle a
-memory allocation failure.  You might try to allocate a super-huge cache, for
-instance; if you can't allocate the cache, your code will still work, it will
-just be a bit slower.  In this case, you *want* to be able to detect memory
-allocation failures, and handle them in whatever way is appropriate.  The
-"recoverable" family of functions will return a ``NULL`` pointer if allocation
-fails.
-
-.. note::
-
-   libcork itself uses the guaranteed functions for all internal memory
-   allocation.
-
-
-Guaranteed allocation
----------------------
-
-The functions in this section are guaranteed to return a valid newly allocated
-pointer.  If memory allocation fails, the functions will not return.
-
-.. function:: void \*cork_malloc(size_t size)
-              void \*cork_calloc(size_t count, size_t size)
-              void \*cork_realloc(void \*ptr, size_t old_size, size_t new_size)
-              type \*cork_new(TYPE type)
-
-   The first three functions mimic the standard ``malloc``, ``calloc``, and
-   ``realloc`` functions to allocate (or reallocate) some memory, with the added
-   guarantee that they will always return a valid newly allocated pointer.
-   ``cork_new`` is a convenience function for allocating an instance of a
-   particular type; it is exactly equivalent to::
-
-       cork_malloc(sizeof(type))
-
-   Note that with ``cork_realloc``, unlike the standard ``realloc`` function,
-   you must provide the old size of the memory region, in addition to the
-   requested new size.
-
-   Each allocation function has a corresponding deallocation function that you
-   must use to free the memory when you are done with it: use
-   :c:func:`cork_free` to free memory allocated using ``cork_malloc`` or
-   ``cork_realloc``; use :c:func:`cork_cfree` to free memory allocated using
-   ``cork_calloc``; and use :c:func:`cork_delete` to free memory allocated using
-   ``cork_new``.
-
-   .. note::
-
-      Note that the possible memory leak in the standard ``realloc``
-      function doesn't apply here, since we're going to abort the whole
-      program if the reallocation fails.
-
-
-Recoverable allocation
-----------------------
-
-The functions in this section will return a ``NULL`` pointer if any memory
-allocation fails, allowing you to recover from the error condition, if possible.
-
-.. function:: void \*cork_xmalloc(size_t size)
-              void \*cork_xcalloc(size_t count, size_t size)
-              void \*cork_xrealloc(void \*ptr, size_t old_size, size_t new_size)
-              void \*cork_xreallocf(void \*ptr, size_t old_size, size_t new_size)
-              type \*cork_xnew(TYPE type)
-
-   The first three functions mimic the standard ``malloc``, ``calloc``,
-   ``realloc`` functions.  ``cork_xreallocf`` mimics the common ``reallocf``
-   function from BSD.  These functions return ``NULL`` if the memory allocation
-   fails.  (Note that unlike the standard functions, they do **not** set
-   ``errno`` to ``ENOMEM``; the only indication you have of an error condition
-   is a ``NULL`` return value.)
-
-   Note that with ``cork_xrealloc`` and ``cork_xreallocf``, unlike the standard
-   ``realloc`` function, you must provide the old size of the memory region, in
-   addition to the requested new size.
-
-   ``cork_xreallocf`` is more safe than the standard ``realloc`` function.  A
-   common idiom when calling ``realloc`` is::
-
-       void  *ptr = /* from somewhere */;
-       /* UNSAFE!  Do not do this! */
-       ptr = realloc(ptr, new_size);
-
-   This is unsafe!  The ``realloc`` function returns a ``NULL`` pointer if the
-   reallocation fails.  By assigning directly into *ptr*, you'll get a memory
-   leak in these situations.  The ``cork_xreallocf`` function, on the other
-   hand, will automatically free the existing pointer if the reallocation fails,
-   eliminating the memory leak::
-
-       void  *ptr = /* from somewhere */;
-       /* This is safe.  Do this. */
-       ptr = cork_xreallocf(ptr, new_size);
-       /* Check whether ptr is NULL before using it! */
-
-   Each allocation function has a corresponding deallocation function that you
-   must use to free the memory when you are done with it: use
-   :c:func:`cork_free` to free memory allocated using ``cork_xmalloc``,
-   ``cork_xrealloc``, or ``cork_xreallocf``; use :c:func:`cork_cfree` to free
-   memory allocated using ``cork_xcalloc``; and use :c:func:`cork_delete` to
-   free memory allocated using ``cork_xnew``.
-
-
-Deallocation
-------------
-
-Since this is C, you must free any memory region once you're done with it.
-You must use one of the functions from this section to free any memory that you
-created using any of the allocation functions described previously.
-
-.. function:: void \*cork_free(void \*ptr, size_t size)
-              void \*cork_cfree(void \*ptr, size_t count, size_t size)
-              type \*cork_delete(void \*ptr, TYPE type)
-
-   Frees a region of memory allocated by one of libcork's allocation functions.
-
-   Note that unlike the standard ``free`` function, you must provide the size of
-   the allocated region when it's freed, as well as when it's created.  Most of
-   the time this isn't an issue, since you're either freeing a region whose size
-   is known at compile time, or you're already keeping track of the size of a
-   dynamically sized memory region for some other reason.
-
-   You should use ``cork_free`` to free memory allocated using
-   :c:func:`cork_malloc`, :c:func:`cork_realloc`, :c:func:`cork_xmalloc`,
-   :c:func:`cork_xrealloc`, or :c:func:`cork_xreallocf`.  You should use
-   ``cork_cfree`` to free memory allocated using :c:func:`cork_calloc` or
-   :c:func:`cork_xcalloc`.  You should use ``cork_delete`` to free memory
-   allocated using :c:func:`cork_new` or :c:func:`cork_xnew`.
-
-
-Duplicating strings
--------------------
-
-.. function:: const char \*cork_strdup(const char \*str)
-              const char \*cork_strndup(const char \*str, size_t size)
-              const char \*cork_xstrdup(const char \*str)
-              const char \*cork_xstrndup(const char \*str, size_t size)
-
-   These functions mimic the standard ``strdup`` function.  They create a copy
-   of an existing C string, allocating exactly as much memory is needed to hold
-   the copy.
-
-   The ``strdup`` variants calculate the size of *str* using ``strlen``.  For
-   the ``strndup`` variants, *str* does not need to be ``NUL``-terminated, and
-   you must pass in its *size*.  (Note that is different than the standard
-   ``strndup``, where *str* must be ``NUL``-terminated, and which copies **at
-   most** *size* bytes.  Our version always copies **exactly** *size* bytes.)
-   The result is guaranteed to be ``NUL``-terminated, even if the source *str*
-   is not.
-
-   You shouldn't modify the contents of the copied string.  You must use
-   :c:func:`cork_strfree()` to free the string when you're done with it.  The
-   ``x`` variant returns a ``NULL`` pointer if the allocation fails; the non-\
-   ``x`` variant is guaranteed to return a valid pointer to a copied string.
-
-.. function:: void cork_strfree(const char \*str)
-
-   Frees *str*, which must have been created using
-   :c:func:`cork_strdup()` or :c:func:`cork_xstrdup()`.
-
-
-.. _libcork-allocators:
-
-Customizing how libcork allocates
-=================================
-
-The ``cork_alloc`` type encapsulates a particular memory allocation scheme.  To
-customize how libcork allocates memory, you create a new instance of this type,
-and then use :c:func:`cork_set_allocator` to register it with libcork.
-
-.. function:: void cork_set_allocator(const struct cork_alloc \*alloc)
-
-   Override which :ref:`allocator instance <allocators>` libcork will use to
-   create and free memory.  We will take control of *alloc*; you must not free
-   it yourself after passing it to this function.
-
-   You can only call this function at most once.  This function is **not**
-   thread-safe; it's only safe to call before you've called **any** other
-   libcork function (or any function from any other library that uses libcork.
-   (The only exceptions are libcork functions that take in a
-   :c:type:`cork_alloc` parameter or return a :c:type:`cork_alloc` result; these
-   functions are safe to call before calling ``cork_set_allocator``.)
-
-.. var:: const struct cork_alloc \*cork_allocator
-
-   The current :ref:`allocator instance <allocators>` that libcork will use to
-   create and free memory.
-
-
-.. _allocators:
-
-Writing a custom allocator
---------------------------
-
-.. type:: struct cork_alloc
-
-   The ``cork_alloc`` type contains several methods for performing different
-   allocation and deallocation operations.
-
-   You are only required to provide implementations of ``xmalloc`` and ``free``;
-   we can provide default implementations of all of the other methods in terms
-   of those two.  You can provide optimized versions of the other methods, if
-   appropriate.
-
-
-.. function:: struct cork_alloc \*cork_alloc_new_alloc(const struct cork_alloc \*parent)
-
-   ``cork_alloc_new`` creates a new allocator instance.  The new instance will
-   itself be allocated using *parent*.  You must provide implementations of at
-   least the ``xmalloc`` and ``free`` methods.  You can also override our
-   default implementations of any of the other methods.
-
-   This function is **not** thread-safe; it's only safe to call before you've
-   called **any** other libcork function (or any function from any other library
-   that uses libcork.  (The only exceptions are libcork functions that take in a
-   :c:type:`cork_alloc` parameter or return a :c:type:`cork_alloc` result; these
-   functions are safe to call before calling ``cork_set_allocator``.)
-
-   The new allocator instance will automatically be freed when the process
-   exits.  If you registered a *user_data* pointer for your allocation methods
-   (via :c:func:`cork_alloc_set_user_data`), it will be freed using the
-   *free_user_data* method you provided.  If you create more than one
-   ``cork_alloc`` instance in the process, they will be freed in the reverse
-   order that they were created.
-
-   .. note::
-
-      In your allocator implementation, you cannot assume that the rest of the
-      libcork allocation framework has been set up yet.  So if your allocator
-      needs to allocate, you must not use the usual :c:func:`cork_malloc` family
-      of functions; instead you should use the ``cork_alloc_malloc`` variants to
-      explicitly allocate memory using your new allocator's *parent*.
-
-
-.. function:: void cork_alloc_set_user_data(struct cork_alloc \*alloc, void \*user_data, cork_free_f free_user_data)
-
-   Provide a *user_data* pointer, which will be passed unmodified to each
-   allocation method that you register.  You can also provide an optional
-   *free_user_data* method, which we will use to free the *user_data* instance
-   when the allocator itself is freed.
-
-
-.. function:: void cork_alloc_set_calloc(struct cork_alloc \*alloc, cork_alloc_calloc_f calloc)
-              void cork_alloc_set_xcalloc(struct cork_alloc \*alloc, cork_alloc_calloc_f calloc)
-
-   .. type:: void \*(\*cork_alloc_calloc_f)(const struct cork_alloc \*alloc, size_t count, size_t size)
-
-      These methods are used to implement the :c:func:`cork_calloc` and
-      :c:func:`cork_xcalloc` functions.  Your must allocate and return ``count *
-      size`` bytes of memory.  You must ensure that every byte in this region is
-      initialized to ``0``.  The ``calloc`` variant must always return a valid
-      pointer; if memory allocation fails, it must not return.  The ``xcalloc``
-      variant should return ``NULL`` if allocation fails.
-
-
-.. function:: void cork_alloc_set_malloc(struct cork_alloc \*alloc, cork_alloc_malloc_f malloc)
-              void cork_alloc_set_xmalloc(struct cork_alloc \*alloc, cork_alloc_malloc_f malloc)
-
-   .. type:: void \*(\*cork_alloc_malloc_f)(const struct cork_alloc \*alloc, size_t size)
-
-      These methods are used to implement the :c:func:`cork_malloc` and
-      :c:func:`cork_xmalloc` functions.  You must allocate and return *size*
-      bytes of memory.  The ``malloc`` variant must always return a valid
-      pointer; if memory allocation fails, it must not return.  The ``xmalloc``
-      variant should return ``NULL`` if allocation fails.
-
-
-.. function:: void cork_alloc_set_realloc(struct cork_alloc \*alloc, cork_alloc_realloc_f realloc)
-              void cork_alloc_set_xrealloc(struct cork_alloc \*alloc, cork_alloc_realloc_f realloc)
-
-   .. type:: void \*(\*cork_alloc_realloc_f)(const struct cork_alloc \*alloc, void \*ptr, size_t old_size, size_t new_size)
-
-      These methods are used to implement the :c:func:`cork_realloc`,
-      :c:func:`cork_xrealloc`, and :c:func:`cork_xreallocf` functions.  You
-      must reallocate *ptr* to contain *new_size* bytes of memory and return the
-      reallocated pointer.  *old_size* will be the previously allocated size of
-      *ptr*.  The ``realloc`` variant must always return a valid pointer; if
-      memory reallocation fails, it must not return.  The ``xrealloc`` variant
-      should return ``NULL`` if reallocation fails.
-
-
-.. function:: void cork_alloc_set_free(struct cork_alloc \*alloc, cork_alloc_free_f free)
-
-   .. type:: void \*(\*cork_alloc_free_f)(const struct cork_alloc \*alloc, void \*ptr, size_t size)
-
-      These methods are used to implement the :c:func:`cork_free`,
-      :c:func:`cork_cfree`, and :c:func:`cork_delete` functions.  You must
-      deallocate *ptr*.  *size* will be the allocated size of *ptr*.
diff --git a/docs/old/array.rst b/docs/old/array.rst
deleted file mode 100644
index bf765d6..0000000
--- a/docs/old/array.rst
+++ /dev/null
@@ -1,148 +0,0 @@
-.. _array:
-
-****************
-Resizable arrays
-****************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/ds.h>
-
-This section defines a resizable array class, similar to C++'s
-``std::vector`` or Java's ``ArrayList`` classes.  Our arrays can store
-any fixed-size element.  The arrays automatically resize themselves as
-necessary to store the elements that you add.
-
-
-.. type:: cork_array(element_type)
-
-   A resizable array that contains elements of type *element_type*.
-
-.. function:: void cork_array_init(cork_array(T) \*array)
-
-   Initializes a new array.  You should allocate *array* yourself,
-   presumably on the stack or directly within some other data type.  The
-   array will start empty.
-
-.. function:: void cork_array_done(cork_array(T) \*array)
-
-   Finalizes an array, freeing any storage that was allocated to hold
-   the arrays elements.
-
-.. function:: size_t cork_array_size(cork_array(T) \*array)
-
-   Returns the number of elements in *array*.
-
-.. function:: bool cork_array_is_empty(cork_array(T) \*array)
-
-   Returns whether *array* has any elements.
-
-.. function:: void cork_array_void(cork_array(T) \*array)
-
-   Removes all elements from *array*.
-
-.. function:: T* cork_array_elements(cork_array(T) \*array)
-
-   Returns a pointer to the underlying array of elements in *array*.  The
-   elements are guaranteed to be contiguous, just like in a normal C array, but
-   the particular pointer that is returned in **not** guaranteed to be
-   consistent across function calls that modify the contents of the array.
-
-.. function:: T cork_array_at(cork_array(T) \*array, size_t index)
-
-   Returns the element in *array* at the given *index*.  Like accessing
-   a normal C array, we don't do any bounds checking.  The result is a
-   valid lvalue, so it can be directly assigned to::
-
-     cork_array(int64_t)  array;
-     cork_array_append(array, 5, err);
-     cork_array_at(array, 0) = 12;
-
-.. function:: void cork_array_append(cork_array(T) \*array, T element)
-
-   Appends *element* to the end of *array*, reallocating the array's
-   storage if necessary.  If you have an ``init`` or ``reset`` callback for
-   *array*, it will be used to initialize the space that was allocated for the
-   new element, and then *element* will be directly copied into that space
-   (using ``memcpy`` or an equivalent).  If that is not the right copy behavior
-   for the elements of *array*, then you should use
-   :c:func:`cork_array_append_get` instead, and fill in the allocated element
-   directly.
-
-.. function:: T \*cork_array_append_get(cork_array(T) \*array)
-
-   Appends a new element to the end of *array*, reallocating the array's storage
-   if necessary, returning a pointer to the new element.
-
-.. function:: int cork_array_ensure_size(cork_array(T) \*array, size_t desired_count)
-
-   Ensures that *array* has enough allocated space to store *desired_count*
-   elements, reallocating the array's storage if needed.  The actual size and
-   existing contents of the array aren't changed.
-
-.. function:: int cork_array_copy(cork_array(T) \*dest, cork_array(T) \*src, cork_copy_f \*copy, void \*user_data)
-
-   Copy elements from *src* to *dest*.  If you provide a *copy* function, it
-   will be called on each element to perform the copy.  If not, we'll use
-   ``memcpy`` to bulk-copy the elements.
-
-   If you've provided :ref:`callbacks <array-callbacks>` for *dest*, then those
-   callbacks will be called appropriately.  We'll call the ``remove`` callback
-   for any existing entries (will be overwritten by the copy).  We'll call
-   ``init`` or ``reuse`` on each element entry before it's copied.
-
-   .. type:: typedef int (\*cork_copy_f)(void \*user_data, void \*dest, const void \*src)
-
-.. function:: size_t cork_array_element_size(cork_array(T) \*array)
-
-   Returns the size of the elements that are stored in *array*.  You
-   won't normally need to call this, since you can just use
-   ``sizeof(T)``.
-
-
-.. _array-callbacks:
-
-Initializing and finalizing elements
-------------------------------------
-
-You can provide callback functions that will be used to automatically initialize
-and finalize the elements of a resizable array.
-
-
-.. function:: void cork_array_set_init(cork_array(T) \*array, cork_init_f init)
-              void cork_array_set_done(cork_array(T) \*array, cork_done_f done)
-              void cork_array_set_reuse(cork_array(T) \*array, cork_init_f reuse)
-              void cork_array_set_remove(cork_array(T) \*array, cork_done_f remove)
-              void cork_array_set_callback_data(cork_array(T) \*array, void \*user_data, cork_free_f free_user_data)
-
-   Set one of the callback functions for *array*.  There are two pairs of
-   callbacks: ``init`` and ``done``, and ``reuse`` and ``remove``.  Within each
-   pair, one callback is used to initialize an element of the array, while the
-   other is used to finalize it.
-
-   The ``init`` callback is used to initialize an element when its array entry
-   is used for the first time.  If you then shrink the array (via
-   :c:func:`cork_array_clear`, for instance), and then append elements again,
-   you will reuse array entries; in this case, the ``reset`` callback is used
-   instead.  (Having separate ``init`` and ``reuse`` callbacks can be useful
-   when the elements are complex objects with deep memory requirements.  If you
-   use the ``init`` callback to allocate that memory, and use the ``reset``
-   callback to "clear" it, then you can reduce some of the memory allocation
-   overhead.)
-
-   Similarly, the ``remove`` callback is used when an element is removed from
-   the array, but the space that the element used isn't being reclaimed yet.
-   The ``done`` callback, on the other hand, is used when the array entry is
-   reclaimed and freed.
-
-   All of the callbacks take in an additional *user_data* parameter, in addition
-   to the array entries themselves.  You provide that parameter by calling the
-   :c:func:`cork_array_set_callback_data` function.  If you pass in a
-   *free_user_data* function, then we will use that function to free the
-   *user_data* when the array itself is finalized.
-
-   .. type:: typedef void (\*cork_init_f)(void \*user_data, void \*value)
-             typedef void (\*cork_done_f)(void \*user_data, void \*value)
-             typedef void (\*cork_free_f)(void \*value)
diff --git a/docs/old/attributes.rst b/docs/old/attributes.rst
deleted file mode 100644
index c3ab445..0000000
--- a/docs/old/attributes.rst
+++ /dev/null
@@ -1,119 +0,0 @@
-.. _attributes:
-
-*******************
-Compiler attributes
-*******************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-The macros in this section define compiler-agnostic versions of several
-common compiler attributes.
-
-
-.. function:: CORK_LIKELY(expression)
-              CORK_UNLIKELY(expression)
-
-   Indicate that the given Boolean *expression* is likely to be ``true``
-   or ``false``, respectively.  The compiler can sometimes use this
-   information to generate more efficient code.
-
-
-.. macro:: CORK_ATTR_CONST
-
-   Declare a “constant” function.  The return value of a constant
-   function can only depend on its parameters.  This is slightly more
-   strict than a “pure” function (declared by
-   :c:macro:`CORK_ATTR_PURE`); a constant function is not allowed to
-   read from global variables, whereas a pure function is.
-
-   .. note:: Note that the compiler won't verify that your function
-      meets the requirements of a constant function.  Instead, this
-      attribute notifies the compiler of your intentions, which allows
-      the compiler to assume more about your function when optimizing
-      code that calls it.
-
-   ::
-
-     int square(int x) CORK_ATTR_CONST;
-
-
-.. macro:: CORK_ATTR_MALLOC
-
-   Declare a function that returns a newly allocated pointer.  The
-   compiler can use this information to generate more accurate aliasing
-   information, since it can infer that the result of the function
-   cannot alias any other existing pointer.
-
-   ::
-
-     void *custom_malloc(size_t size) CORK_ATTR_MALLOC;
-
-
-.. macro:: CORK_ATTR_NOINLINE
-
-   Declare that a function shouldn't be eligible for inlining.
-
-
-.. macro:: CORK_ATTR_PRINTF(format_index, args_index)
-
-   Declare a function that takes in ``printf``\ -like parameters.
-   *format_index* is the index (starting from 1) of the parameter that
-   contains the ``printf`` format string.  *args_index* is the index of
-   the first parameter that contains the data to format.
-
-
-.. macro:: CORK_ATTR_PURE
-
-   Declare a “pure” function.  The return value of a pure function can
-   only depend on its parameters, and on global variables.
-
-   ::
-
-     static int  _next_id;
-     int get_next_id(void) CORK_ATTR_PURE;
-
-
-.. macro:: CORK_ATTR_SENTINEL
-
-   Declare a var-arg function whose last parameter must be a ``NULL``
-   sentinel value.  When the compiler supports this attribute, it will
-   check the actual parameters whenever this function is called, and
-   ensure that the last parameter is a ``NULL``.
-
-
-.. macro:: CORK_ATTR_UNUSED
-
-   Declare a entity that might not be used.  This lets you keep
-   ``-Wall`` activated in several cases where you're obligated to define
-   something that you don't intend to use.
-
-   ::
-
-     CORK_ATTR_UNUSED static void
-     unused_function(void)
-     {
-         CORK_ATTR_UNUSED int  unused_value;
-     }
-
-
-.. macro:: CORK_INITIALIZER(func_name)
-
-   Declare a ``static`` function that will be automatically called at program
-   startup.  If there are multiple initializer functions linked into a program,
-   there is no guarantee about the order in which the functions will be called.
-
-   ::
-
-     #include <libcork/core.h>
-     #include <libcork/ds.h>
-
-     static cork_array(int)  array;
-
-     CORK_INITIALIZER(init_array)
-     {
-        cork_array_init(&array);
-     }
diff --git a/docs/old/basic-types.rst b/docs/old/basic-types.rst
deleted file mode 100644
index 4a6fe8f..0000000
--- a/docs/old/basic-types.rst
+++ /dev/null
@@ -1,120 +0,0 @@
-.. _basic-types:
-
-***********
-Basic types
-***********
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-The types in this section ensure that the C99 integer types are
-available, regardless of platform.  We also define some preprocessor
-macros that give the size of the non-fixed-size standard types.  In
-addition, libcork defines some useful low-level types:
-
-.. toctree::
-   :maxdepth: 1
-
-   int128
-   net-addresses
-   timestamps
-   hash-values
-   unique-ids
-
-Integral types
-==============
-
-.. type:: bool
-
-   A boolean.  Where possible, we simply include ``<stdbool.h>`` to get
-   this type.  It might be ``typedef``\ ed to ``int``\ .  We also make
-   sure that the following constants are defined:
-
-   .. var:: bool false
-            bool true
-
-.. type:: int8_t
-          uint8_t
-          int16_t
-          uint16_t
-          int32_t
-          uint32_t
-          int64_t
-          uint64_t
-
-   Signed and unsigned, fixed-size integral types.
-
-.. type:: intptr_t
-          uintptr_t
-
-   Signed and unsigned integers that are guaranteed to be big enough to
-   hold a type-cast ``void *``\ .
-
-.. type:: size_t
-
-   An unsigned integer big enough to hold the size of a memory object,
-   or a maximal array index.
-
-.. type:: ptrdiff_t
-
-   A signed integer big enough to hold the difference between two
-   pointers.
-
-Size macros
-===========
-
-.. macro:: CORK_SIZEOF_SHORT
-           CORK_SIZEOF_INT
-           CORK_SIZEOF_LONG
-           CORK_SIZEOF_POINTER
-
-   The size (in bytes) of the ``short``, ``int``, ``long``, and ``void
-   *`` types, respectively.
-
-
-.. _embedded-struct:
-
-Embedded ``struct``\ s
-======================
-
-Quite often a callback function or API will take in a pointer to a
-particular ``struct``, with the expectation that you can embed that
-``struct`` into some other type for extension purposes.  Kind of a
-bastardized subclassing mechanism for C code.  The doubly-linked list
-module is a perfect example; you're meant to embed
-:c:type:`cork_dllist_item` within the linked list element type.  You can
-use the following macro to obtain the pointer to the containing
-(“subclass”) ``struct``, when given a pointer to the contained
-(“superclass”) ``struct``:
-
-.. function:: struct_type \*cork_container_of(field_type \*field, TYPE struct_type, FIELD field_name)
-
-   The *struct_type* parameter must be the name of a ``struct`` type,
-   *field_name* must be the name of some field within that
-   ``struct``, and *field* must be a pointer to an instance of that
-   field.  The macro returns a pointer to the containing ``struct``.
-   So, given the following definitions::
-
-     struct superclass {
-         int  a;
-     };
-
-     struct subclass {
-         int  b;
-         struct superclass  parent;
-     };
-
-     struct subclass  instance;
-
-   then the following identity holds::
-
-     cork_container_of(&instance.parent, struct subclass, parent) == &instance
-
-   .. note:: When the superclass ``struct`` appears as the first element
-      of the subclass ``struct``, you can obtain the same effect using a
-      simple type-cast.  However, the ``cork_container_of`` macro is
-      more robust, since it also works when the superclass ``struct``
-      appears later on in the subclass ``struct``.
diff --git a/docs/old/bitset.rst b/docs/old/bitset.rst
deleted file mode 100644
index cd7a679..0000000
--- a/docs/old/bitset.rst
+++ /dev/null
@@ -1,52 +0,0 @@
-.. _bits:
-
-********
-Bit sets
-********
-
-.. highlight:: c
-
-::
-
-  #include <libcork/ds.h>
-
-This sections defines a type for storing an array of bits.  This data structure
-is most often used to implement a set of integers.  It is particularly good when
-you expect your sets to be *dense*.  You should not use a bitset if the number
-of possibly elements is outrageously large, however, since that would cause your
-bitset to exhaust the available memory.
-
-.. type:: struct cork_bitset
-
-   An array of bits.  You should not allocate any instances of this type
-   yourself; use :c:func:`cork_bitset_new` instead.
-
-   .. member:: size_t bit_count
-
-      The number of bits that are included in this array.  (Each bit can be on
-      or off; this does not give you the number of bits that are *on*, it gives
-      you the number of bits in total, on or off.)
-
-
-.. function:: struct cork_bitset \*cork_bitset_new(size_t bit_count)
-
-   Create a new bitset with enough space to store the given number of bits.  All
-   bits will be initialized to ``0``.
-
-.. function:: void cork_bitset_free(struct cork_bitset \*set)
-
-   Free a bitset.
-
-.. function:: bool cork_bitset_get(struct cork_bitset \*set, size_t index)
-
-   Return whether the given bit is on or off in *set*.  It is your
-   responsibility to ensure that *index* is within the valid range for *set*.
-
-.. function:: void cork_bitset_set(struct cork_bitset \*set, size_t index, bool value)
-
-   Turn the given bit on or off in *set*.  It is your responsibility to ensure
-   that *index* is within the valid range for *set*.
-
-.. function:: void cork_bitset_clear(struct cork_bitset \*set)
-
-   Turn off of the bits in *set*.
diff --git a/docs/old/buffer.rst b/docs/old/buffer.rst
deleted file mode 100644
index 4399df7..0000000
--- a/docs/old/buffer.rst
+++ /dev/null
@@ -1,261 +0,0 @@
-.. _buffer:
-
-************************
-Resizable binary buffers
-************************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/ds.h>
-
-This section defines a resizable binary buffer type.  This class can
-also be used to construct C strings, when you don't know the size of
-the string in advance.
-
-This class is not reference counted; we assume that there's a single
-owner of the buffer.  The contents of a :c:type:`cork_buffer` are fully
-mutable.  If you want to turn the buffer into something that's safe to
-pass between threads, you can use the :c:func:`cork_buffer_to_slice()`
-or :c:func:`cork_buffer_to_managed_buffer()` functions to create an
-immutable managed wrapper around the buffer.
-
-You can read the contents of the buffer by accessing the :c:member:`buf
-<cork_buffer.buf>` and :c:member:`size <cork_buffer.size>` fields
-directly.  However, to modify the contents of a buffer, you should use
-the mutator functions described below, since they take care of
-automatically resizing the underlying buffer when necessary.
-
-.. note::
-
-   This class always creates its own copy of any data added to the
-   buffer; there aren't any methods for wrapping existing buffers
-   without copying.  If you want to do that, you should use
-   :ref:`managed-buffer` or :ref:`slice`.
-
-
-.. type:: struct cork_buffer
-
-   A resizable binary buffer.
-
-   .. member:: void \*buf
-
-      The current contents of the buffer.
-
-   .. member:: size_t  size
-
-      The current size of the buffer.
-
-
-.. function:: void cork_buffer_init(struct cork_buffer \*buffer)
-              struct cork_buffer CORK_BUFFER_INIT()
-
-   Initialize a new buffer instance that you've allocated yourself
-   (usually on the stack).  The ``CORK_BUFFER_INIT`` version can only be
-   used as a static initializer.
-
-   The preallocated ``cork_buffer`` instance that you provide doesn't
-   include space for the content of the buffer; this will be allocated
-   automatically as content is added.
-
-.. function:: struct cork_buffer \*cork_buffer_new(void)
-
-   Allocate and initialize a new buffer instance.
-
-.. function:: void cork_buffer_done(struct cork_buffer \*buffer)
-
-   Finalize a buffer, freeing any content that it contains.  This
-   function should only be used for buffers that you allocated yourself,
-   and initialized using :c:func:`cork_buffer_init()` or
-   :c:func:`CORK_BUFFER_INIT()`.  You must **not** use this function to
-   free a buffer allocated using :c:func:`cork_buffer_free()`.
-
-.. function:: void cork_buffer_free(struct cork_buffer \*buffer)
-
-   Finalize and deallocate a buffer, freeing any content that it
-   contains.  This function should only be used for buffers allocated
-   using :c:func:`cork_buffer_new()`.  You must **not** use this
-   function to free a buffer initialized using
-   :c:func:`cork_buffer_init()` or :c:func:`CORK_BUFFER_INIT()`.
-
-.. function:: bool cork_buffer_equal(const struct cork_buffer \*buffer1, const struct cork_buffer \*buffer2)
-
-   Compare two buffers for equality.
-
-.. function:: void cork_buffer_ensure_size(struct cork_buffer \*buffer, size_t desired_size)
-
-   Ensure that a buffer has allocated enough space to store at least
-   *desired_size* bytes.  We won't shrink the size of the buffer's
-   internal storage; if the buffer has already allocated at least
-   *desired_size* bytes, the function acts as a no-op.
-
-.. function:: uint8_t cork_buffer_byte(struct cork_buffer \*buffer, size_t index)
-              char cork_buffer_char(struct cork_buffer \*buffer, size_t index)
-
-   Return the byte or character at the given index in *buffer*.
-
-
-Mutator functions
------------------
-
-Most of the mutator functions defined in this section come in two
-variants: a ``_set`` function, which clears the buffer before adding new
-content, and an ``_append`` function, which retains the old content,
-adding the new content to the end of the buffer.
-
-Each mutator function will automatically append an extra ``NUL`` byte to
-the end of whatever content is placed into the buffer.  However, this
-``NUL`` byte will **not** be included in the :c:member:`size
-<cork_buffer.size>` of the buffer.  This ensures that the contents of
-any ``cork_buffer`` can be used as a ``NUL``\ -terminated C string
-(assuming that there aren't any internal ``NUL``\ s), even if the buffer
-is constructed from a data source that doesn't include ``NUL``
-terminators.
-
-.. function:: void cork_buffer_clear(struct cork_buffer \*buffer)
-
-   Clear a buffer.  This does not free any storage that the buffer has
-   allocated; this storage will be reused if you add contents back to the
-   buffer.
-
-.. function:: void cork_buffer_truncate(struct cork_buffer \*buffer, size_t length)
-
-   Truncate a buffer so that contains no more than *length* bytes.  If the
-   buffer is already shorter than this, it is not modified.
-
-.. function:: void cork_buffer_copy(struct cork_buffer \*dest, const struct cork_buffer \*src)
-              void cork_buffer_append_copy(struct cork_buffer \*dest, const struct cork_buffer \*src)
-
-   Copy the contents of the *src* buffer into *dest*.  The ``_set`` variant
-   clears the buffer first, while the ``_append`` variant adds *src* to whatever
-   content is already there.
-
-.. function:: void cork_buffer_set(struct cork_buffer \*buffer, const void \*src, size_t length)
-              void cork_buffer_append(struct cork_buffer \*buffer, const void \*src, size_t length)
-
-   Copy the contents of *src* into a buffer.  The ``_set`` variant
-   clears the buffer first, while the ``_append`` variant adds *src* to
-   whatever content is already there.
-
-.. function:: void cork_buffer_set_string(struct cork_buffer \*buffer, const char \*str)
-              void cork_buffer_append_string(struct cork_buffer \*buffer, const char \*str)
-              void cork_buffer_set_literal(struct cork_buffer \*buffer, const char \*str)
-              void cork_buffer_append_literal(struct cork_buffer \*buffer, const char \*str)
-
-   Copy the contents of *str* (which must be a ``NUL``\ -terminated C
-   string) into a buffer.  The ``_set`` variants clears the buffer first,
-   while the ``_append`` variants adds *str* to whatever content is
-   already there.  The ``_literal`` variants only work when *str* is a C string
-   literal; we use the ``sizeof`` operator to determine the length of the string
-   at compile time.  The ``_string`` variants work with any C string; we use the
-   builtin ``strlen`` function to determine the length of the string.
-
-.. function:: void cork_buffer_printf(struct cork_buffer \*buffer, const char \*format, ...)
-              void cork_buffer_vprintf(struct cork_buffer \*buffer, const char \*format, va_list args)
-              void cork_buffer_append_printf(struct cork_buffer \*buffer, const char \*format, ...)
-              void cork_buffer_append_vprintf(struct cork_buffer \*buffer, const char \*format, va_list args)
-
-   Format data according to a ``printf`` format string, placing the
-   result into a buffer.  The ``_append`` variants add the formatted
-   string to whatever content is already in the buffer; the non-\
-   ``_append`` variants clear the buffer first.  The ``_printf``
-   variants are vararg functions, and take in the format string's data
-   as direct parameters.  The ``_vprintf`` variants can be used within
-   another vararg function, and let you pass in the format string's data
-   as a C99-standard ``va_list`` instance.
-
-
-Pretty-printing
----------------
-
-We also provide several helper functions for adding pretty-printed content to a
-``cork_buffer``.
-
-.. function:: void cork_buffer_append_indent(struct cork_buffer \*buffer, size_t indent)
-
-   Append *indent* spaces to *buffer*.
-
-.. function:: void cork_buffer_append_c_string(struct cork_buffer \*buffer, const char \*str, size_t length)
-
-   Append the C string literal representation of *str* to *buffer*.  This will
-   include opening and closing double quotes, and any non-printable characters
-   will be escaped.  (We will use the standard letter-based escapes where
-   possible, and fall back on ``"\xXX"`` hexadecimal escapes for other
-   non-printable characters.)  The result is guaranteed to stay on a single
-   line, since any embedded newlines will be converted to a ``\n`` escape
-   sequence.
-
-.. function:: void cork_buffer_append_hex_dump(struct cork_buffer \*buffer, size_t indent, const char \*str, size_t length)
-              void cork_buffer_append_multiline(struct cork_buffer \*buffer, size_t indent, const char \*str, size_t length)
-              void cork_buffer_append_binary(struct cork_buffer \*buffer, size_t indent, const char \*str, size_t length)
-
-   Append a pretty-printed representation of *str* to *buffer*.  All of these
-   functions can produce multiple lines of output.  All lines except for the
-   first will be prefaced with *indent* space characters.  The final line will
-   **not** have a trailing newline.
-
-   The ``hex_dump`` variant will output a hex-dump representation of *str*.
-   This will include the hexadecimal representation of each byte, and the actual
-   character of any printable byte.
-
-   The ``multiline`` variant appends the raw content of *str* to the buffer,
-   without making any attempt to sanitize non-printable characters.  (That means
-   you should only call this variant if you know that *str* contains only
-   printable characters.)  If *str* itself spans multiple lines, then we'll
-   insert indentation to make sure that we satisfy the indentation rules
-   described above.
-
-   The ``binary`` variant autodetects how to best render *str*.  If it contains
-   any non-printable characters, then we'll use the ``hex_dump`` representation.
-   If it spans multiple lines, we'll use the ``multiline`` representation.
-   Otherwise, we'll append the content directly without any modification.
-
-
-Other binary data structures
-----------------------------
-
-The ``cork_buffer`` class is the only binary data class that is mutable;
-this comes at the cost of only being usable by a single owner thread or
-function at a time.  Once you have constructed a binary string or
-payload using a ``cork_buffer``, you can use the functions in this
-section to produce a corresponding instance of one of libcork's
-sharable, immutable binary data types.
-
-.. function:: struct cork_managed_buffer \*cork_buffer_to_managed_buffer(struct cork_buffer \*buffer)
-
-   Create a new :ref:`managed buffer <managed-buffer>` to manage the
-   contents of a ``cork_buffer`` instance.  *buffer* must have been
-   allocated on the heap (i.e., using :c:func:`cork_buffer_new()`, and
-   not :c:func:`cork_buffer_init()`).  We take ownership of *buffer*,
-   regardless of whether we're able to successfully create a new
-   :c:type:`cork_managed_buffer` instance.  You must **not** try to free
-   *buffer* yourself.
-
-.. function:: int cork_buffer_to_slice(struct cork_buffer \*buffer, struct cork_slice \*slice)
-
-   Initialize a new :ref:`slice <slice>` to manage the contents of
-   *buffer*.  *buffer* must have been allocated on the heap (i.e., using
-   :c:func:`cork_buffer_new()`, and not :c:func:`cork_buffer_init()`).
-   We take ownership of *buffer*, regardless of whether we're able to
-   successfully create a new :c:type:`cork_managed_buffer` instance.
-   You must **not** try to free *buffer* yourself.
-
-   The slice will point into the contents of a new :ref:`managed buffer
-   <managed-buffer>` instance.  The managed buffer isn't returned
-   directly, though you can create additional slices into it using the
-   usual :c:type:`cork_slice` methods.
-
-   Regardless of whether we can initialize the slice successfully, you
-   **must** call :c:func:`cork_slice_finish()` on *slice* when you're
-   done with the slice.
-
-.. function:: struct cork_stream_consumer \*cork_buffer_to_stream_consumer(struct cork_buffer \*buffer)
-
-   Create a new stream consumer that appends any received data into
-   *buffer*.
-
-   We do **not** take control of *buffer*.  You retain responsibility
-   for freeing the buffer, and you must ensure that it remains allocated
-   and valid for the entire lifetime of the stream consumer that we
-   return.
diff --git a/docs/old/byte-order.rst b/docs/old/byte-order.rst
deleted file mode 100644
index c95bf34..0000000
--- a/docs/old/byte-order.rst
+++ /dev/null
@@ -1,144 +0,0 @@
-.. _byte-order:
-
-**********
-Byte order
-**********
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-This section contains definitions for determining the endianness of the
-host system, and for byte-swapping integer values of various sizes.
-
-
-Endianness detection
-====================
-
-.. macro:: CORK_LITTLE_ENDIAN
-           CORK_BIG_ENDIAN
-           CORK_HOST_ENDIANNESS
-           CORK_OTHER_ENDIANNESS
-
-   The ``CORK_HOST_ENDIANNESS`` macro can be used to determine the
-   endianness of the host system.  It will be equal to either
-   ``CORK_LITTLE_ENDIAN`` or ``CORK_BIG_ENDIAN``.  (The actual values
-   don't matter; you should always compare against the predefined
-   constants.)  The ``CORK_OTHER_endianness`` macro is defined to be the
-   opposite endianness as ``CORK_HOST_ENDIANNESS``.  A common use case
-   would be something like::
-
-     #if CORK_HOST_endianness == CORK_LITTLE_ENDIAN
-     /* do something to little-endian values */
-     #else
-     /* do something to big-endian values */
-     #endif
-
-.. macro:: CORK_HOST_ENDIANNESS_NAME
-           CORK_OTHER_ENDIANNESS_NAME
-
-   These macros give you a human-readable name of the host's endianness.
-   You can use this in debugging messages.
-
-   .. note:: You should *not* use these macros to detect the
-      endianness of the system, since we might change their definitions
-      at some point to support localization.  For that,
-      use :macro:`CORK_LITTLE_ENDIAN` and :macro:`CORK_BIG_ENDIAN`.
-
-
-Byte swapping
-=============
-
-Swapping arbitrary expressions
-------------------------------
-
-All of the macros in this section take in an rvalue (i.e., any arbitrary
-expression) as a parameter.  The result of the swap is returned as the
-value of the macro.
-
-.. function:: uint16_t CORK_SWAP_UINT16(uint16_t value)
-              uint32_t CORK_SWAP_UINT32(uint32_t value)
-              uint64_t CORK_SWAP_UINT64(uint64_t value)
-
-   These functions always perform a byte-swap, regardless of the
-   endianness of the host system.
-
-.. function:: uint16_t CORK_UINT16_BIG_TO_HOST(uint16_t value)
-              uint32_t CORK_UINT32_BIG_TO_HOST(uint32_t value)
-              uint64_t CORK_UINT64_BIG_TO_HOST(uint64_t value)
-
-   These functions convert a big-endian (or network-endian) value into
-   host endianness.  (I.e., they only perform a swap if the current host
-   is little-endian.)
-
-.. function:: uint16_t CORK_UINT16_HOST_TO_BIG(uint16_t value)
-              uint32_t CORK_UINT32_HOST_TO_BIG(uint32_t value)
-              uint64_t CORK_UINT64_HOST_TO_BIG(uint64_t value)
-
-   These functions convert a host-endian value into big (or network)
-   endianness.  (I.e., they only perform a swap if the current host is
-   little-endian.)
-
-.. function:: uint16_t CORK_UINT16_LITTLE_TO_HOST(uint16_t value)
-              uint32_t CORK_UINT32_LITTLE_TO_HOST(uint32_t value)
-              uint64_t CORK_UINT64_LITTLE_TO_HOST(uint64_t value)
-
-   These functions convert a little-endian value into host endianness.
-   (I.e., they only perform a swap if the current host is big-endian.)
-
-.. function:: uint16_t CORK_UINT16_HOST_TO_LITTLE(uint16_t value)
-              uint32_t CORK_UINT32_HOST_TO_LITTLE(uint32_t value)
-              uint64_t CORK_UINT64_HOST_TO_LITTLE(uint64_t value)
-
-   These functions convert a host-endian value into little endianness.
-   (I.e., they only perform a swap if the current host is big-endian.)
-
-Swapping values in place
-------------------------
-
-The macros in this section swap an integer *in place*, which means that
-the original value is overwritten with the result of the swap.  To
-support this, you must pass in an *lvalue* as the parameter to the
-macro.  (Note that you don't pass in a *pointer* to the original value;
-these operations are implemented as macros, and you just need to provide
-a reference to the variable to be swapped.)
-
-.. function:: void CORK_SWAP_UINT16_IN_PLACE(uint16_t &value)
-              void CORK_SWAP_UINT32_IN_PLACE(uint32_t &value)
-              void CORK_SWAP_UINT64_IN_PLACE(uint64_t &value)
-
-   These functions always perform a byte-swap, regardless of the
-   endianness of the host system.
-
-.. function:: void CORK_UINT16_BIG_TO_HOST_IN_PLACE(uint16_t &value)
-              void CORK_UINT32_BIG_TO_HOST_IN_PLACE(uint32_t &value)
-              void CORK_UINT64_BIG_TO_HOST_IN_PLACE(uint64_t &value)
-
-   These functions convert a big-endian (or network-endian) value into
-   host endianness, and vice versa.  (I.e., they only perform a swap if
-   the current host is little-endian.)
-
-.. function:: void CORK_UINT16_HOST_TO_BIG_IN_PLACE(uint16_t &value)
-              void CORK_UINT32_HOST_TO_BIG_IN_PLACE(uint32_t &value)
-              void CORK_UINT64_HOST_TO_BIG_IN_PLACE(uint64_t &value)
-
-   These functions convert a host-endian value into big (or network)
-   endianness.  (I.e., they only perform a swap if the current host is
-   little-endian.)
-
-.. function:: void CORK_UINT16_LITTLE_TO_HOST_IN_PLACE(uint16_t &value)
-              void CORK_UINT32_LITTLE_TO_HOST_IN_PLACE(uint32_t &value)
-              void CORK_UINT64_LITTLE_TO_HOST_IN_PLACE(uint64_t &value)
-
-   These functions convert a little-endian value into host endianness, and
-   vice versa.  (I.e., they only perform a swap if the current host is
-   big-endian.)
-
-.. function:: void CORK_UINT16_HOST_TO_LITTLE_IN_PLACE(uint16_t &value)
-              void CORK_UINT32_HOST_TO_LITTLE_IN_PLACE(uint32_t &value)
-              void CORK_UINT64_HOST_TO_LITTLE_IN_PLACE(uint64_t &value)
-
-   These functions convert a host-endian value into little endianness.
-   (I.e., they only perform a swap if the current host is big-endian.)
diff --git a/docs/old/cli.rst b/docs/old/cli.rst
deleted file mode 100644
index 8abef49..0000000
--- a/docs/old/cli.rst
+++ /dev/null
@@ -1,342 +0,0 @@
-.. _cli:
-
-*********************
-Command-line programs
-*********************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/cli.h>
-
-The functions in this section let you easily create complex command-line
-applications that include subcommands, in the style of the ``git`` or ``svn``
-programs.
-
-
-Overview
-========
-
-If you're designing an application where you want to provide command-line access
-to many different operations or use cases, the simplest solution is to create a
-separate executable for each one.  This can clutter up the user's
-``$PREFIX/bin`` directory, however, and can add complexity to your code base.
-Many projects instead create a single “super-command” executable, which includes
-within it all of the operations that you want to support.  You choose specific
-operations by selecting a *subcommand* on the command line.
-
-.. type:: struct cork_command
-
-   An opaque type describing one of the subcommands in an executable.
-
-So, for instance, if you were writing a library for manipulating sets of
-objects, you could define several subcommands of a single ``set`` executable:
-
-.. code-block:: none
-
-    $ set add <filename> <element>
-    $ set query <filename> <element>
-    $ set remove <filename> <element>
-    $ set union -o <output file> <file1> <file2>
-    $ set print avro <filename>
-    $ set print json <filename>
-
-Each of these operations acts in exactly the same as if they were defined as
-separate executables:
-
-.. code-block:: none
-
-    $ set-add <filename> <element>
-    $ set-query <filename> <element>
-    $ set-remove <filename> <element>
-    $ set-union -o <output file> <file1> <file2>
-    $ set-print-avro <filename>
-    $ set-print-json <filename>
-
-Note that you're not limited to one level of subcommands.  The ``set print``
-subcommand, for instance, itself contains two subcommands: ``avro`` and
-``json``.
-
-
-Leaf commands
-=============
-
-A *leaf command* is a subcommand that represents one operation in your
-executable.  In the example above, there are six leaf commands: ``set add``,
-``set query``, ``set remove``, ``set union``, ``set print avro``, and ``set
-print json``.
-
-To define a leaf command, you use the following macro:
-
-.. macro:: cork_leaf_command(const char \*name, const char \*short_description, const char \*usage, const char \*full_help, cork_option_parser parse_options, run)
-
-   Returns :c:type:`cork_command` instance that defines a leaf command.  *name*
-   is the name of the leaf command; this is the word that the user must type on
-   the command-line to select this command.  (For ``set add``, this would be
-   ``add``; for ``set print avro``, this would be ``avro``.)
-
-   *short_description*, *usage*, and *full_help* should be static strings, and
-   will be used to produce various forms of :ref:`help text <cli-help>` for the
-   subcommand.  *short_description* should fit into one line; this will be used
-   as the short description of this leaf command when we print out a list of all
-   of the subcommands that are in the command set that this leaf belongs to.
-   *usage* will be printed whenever we need to print out a usage synopsis.  This
-   should describe the options and arguments to the leaf command; it will be
-   printed after the full name of the subcommand.  (For instance, using the
-   example above, the ``set add`` command's usage text would be ``<filename>
-   <element>``.)  *full_help* should be a longer, multi-line string that
-   describes the subcommand *in full detail*.  We will automatically preface the
-   help text with the usage summary for the command.
-
-   *parse_options* is a function that will be used to parse any command-line
-   options that appear *after* the subcommand's name on the command line.  (See
-   :ref:`below <cli-options>` for more details.)  This can be ``NULL`` if the
-   subcommand does not have any options.
-
-   *run* is the function that will be called to actually execute the command.
-   Any options will have already been processed by the *parse_options* function;
-   you should stash the option values into global or file-scope variables, and
-   then use the contents of those variables in this function.  Your *run*
-   function must be an instance of the :c:type:`cork_leaf_command_run` function
-   type:
-
-   .. type:: void (\*cork_leaf_command_run)(int argc, char \*\*argv)
-
-      The *argc* and *argv* parameters will describe any values that appear on
-      the command line after the name of the leaf command.  This will *not*
-      include any options that were processed by the command's *parse_options*
-      function.
-
-As an example, we could define the ``set add`` command as follows::
-
-    static void
-    set_add_run(int argc, char **argv);
-
-    #define SET_ADD_SHORT  "Adds an element to a set"
-    #define SET_ADD_USAGE  "<filename> <element>"
-    #define SET_ADD_FULL \
-        "Loads in a set from <filename>, and adds <element> to the set.  The\n" \
-        "new set will be written back out to <filename>.\n"
-
-    static struct cork_command  set_add =
-        cork_leaf_command("add", SET_ADD_SHORT, SET_ADD_USAGE, SET_ADD_FULL,
-                          NULL, set_add_run);
-
-    static void
-    set_add_run(int argc, char **argv)
-    {
-        /* Verify that the user gave both required options... */
-        if (argc < 1) {
-            cork_command_show_help(&set_add, "Missing set filename.");
-            exit(EXIT_FAILURE);
-        }
-        if (argc < 2) {
-            cork_command_show_help(&set_add, "Missing element to add.");
-            exit(EXIT_FAILURE);
-        }
-
-        /* ...and no others. */
-        if (argc > 2) {
-            cork_command_show_help(&set_add, "Too many values on command line.");
-            exit(EXIT_FAILURE);
-        }
-
-        /* At this point, <filename> will be in argv[0], <element> will be in
-         * argv[1]. */
-
-        /* Do what needs to be done */
-        exit(EXIT_SUCCESS);
-    }
-
-There are a few interesting points to make.  First, note that we use
-preprocessor macros to define all of the help text for the command.  Also, note
-that *each* line (including the last) of the full help text needs to have a
-trailing newline included in the string literal.
-
-Lastly, note that we still have to perform some final validation of the command
-line arguments given by the user.  If the user hasn't satisfied the subcommand's
-requirements, we use the :c:func:`cork_command_show_help` function to print out
-a nice error message (including a usage summary of the subcommand), and then we
-halt the executable using the standard ``exit`` function.
-
-
-Command sets
-============
-
-A *command set* is a collection of subcommands.  Every executable will have at
-least one command set, for the root executable itself.  It's also possible to
-have nested command sets.  In our example above, ``set`` and ``set print`` are
-both command sets.
-
-To define a command set, you use the following macro:
-
-.. macro:: cork_command_set(const char \*name, const char \*short_description, cork_option_parser parse_options, struct cork_command \*\*subcommands)
-
-   Returns :c:type:`cork_command` instance that defines a command set.  *name*
-   is the name of the command set; this is the word that the user must type on
-   the command-line to select this set of commands.  If the user only specifies
-   the name of the command set, then we'll print out a list of this set's
-   subcommands, along with their short descriptions.  (For instance, running
-   ``set`` on its own would describe the ``set add``, ``set query``, ``set
-   remove``, ``set union``, and ``set print`` subcommands.  Running ``set
-   print`` on its own would describe the ``set print avro`` and ``set print
-   json`` commands.)
-
-   *short_description*, should be a static strings, and will be used to produce
-   various forms of :ref:`help text <cli-help>` for the command set.
-   *short_description* should fit into one line; this will be used as the short
-   description of this command when we print out a list of all of the
-   subcommands that are in the command set that this command belongs to.
-
-   *parse_options* is a function that will be used to parse any command-line
-   options that appear *after* the command set's name on the command line, but
-   *before* the name of one of the set's subcommands.  (See :ref:`below
-   <cli-options>` for more details.)  This can be ``NULL`` if the command set
-   does not have any options.
-
-   *subcommands* should be an array of :c:type:`cork_command` pointers.  The
-   array **must** have a ``NULL`` pointer as its last element.  The order of the
-   subcommands in the array will effect the order that the commands are listed
-   in the command set's help text.
-
-As an example, we could define the ``set print`` command set as follows::
-
-    /* Assuming set_print_avro and set_print_json were already defined
-     * previously, using cork_leaf_command: */
-    struct cork_command  set_print_avro = cork_leaf_command(...);
-    struct cork_command  set_print_json = cork_leaf_command(...);
-
-    /* "set print" command set */
-    static struct cork_command  *set_print_subcommands[] = {
-        &set_print_avro,
-        &set_print_json,
-        NULL
-    };
-
-    #define SET_PRINT_SHORT \
-        "Print out the contents of a set in a variety of formats"
-
-    static struct cork_command  set_print =
-        cork_command_set("print", SET_PRINT_SHORT, NULL, &set_print_subcommands);
-
-You must define your executable's top level of subcommands as a command set as
-well.  For instance, we could define the ``set`` command set as follows::
-
-    static struct cork_command  *root_subcommands[] = {
-        &set_add,
-        &set_query,
-        &set_remove,
-        &set_union,
-        &set_print,
-        NULL
-    };
-
-    static struct cork_command  root =
-        cork_command_set("set", NULL, NULL, &root_subcommands);
-
-Note that we don't need to provide a short description for the root command,
-since it doesn't belong to any command sets.
-
-
-Running the commands
-====================
-
-Once you've defined all of your subcommands, your executable's ``main`` function
-is trivial::
-
-    int
-    main(int argc, char **argv)
-    {
-        return cork_command_main(&root, argc, argv);
-    }
-
-.. function:: int cork_command_main(struct cork_command \*root, int argc, char \*\*argv)
-
-   Runs a subcommand, as defined by the command-line arguments given by *argc*
-   and *argv*.  *root* should define the root command set for the executable.
-
-
-.. _cli-help:
-
-Help text
-=========
-
-The command-line programs created with this framework automatically support
-generating several flavors of help text for its subcommands.  You don't need to
-do anything special, except for ensuring that the actual help text that you
-provide to the :c:macro:`cork_leaf_command` and :c:macro:`cork_command_set`
-macros defined is intelligble and useful.
-
-Your executable will automatically include a ``help`` command in every command
-set, as well as ``--help`` and ``-h`` options in every command set and leaf
-command.  So all of the following would print out the help text for the ``set
-add`` command:
-
-.. code-block:: none
-
-    $ set help add
-    $ set add --help
-    $ set add -h
-
-And all of the following would print out the list of ``set print`` subcommands:
-
-.. code-block:: none
-
-    $ set help print
-    $ set print --help
-    $ set print -h
-
-You can also print out the help text for a command explicitly by calling the
-following function:
-
-.. function:: void cork_command_show_help(struct cork_command \*command, const char \*message)
-
-    Prints out help text for *command*.  (If it's a leaf command, this is the
-    full help text.  If it's a command set, it's a list of the set's
-    subcommands.)  We will preface the help text with *message* if it's
-    non-``NULL``.  (The message should not include a trailing newline.)
-
-
-.. _cli-options:
-
-Option parsing
-==============
-
-Leaf commands and command sets both let you provide a function that parse
-command-line options for the given command.  We don't prescribe any particular
-option parsing library, you just need to conform to the interface described in
-this section.  (Note that the standard ``getopt`` and ``getopt_long`` functions
-can easily be used in an option parsing function.)
-
-.. type:: int (\*cork_option_parser)(int argc, char \*\*argv)
-
-   Should parse any command-line options that can appear at this point in the
-   executable's command line.  (The options must appear immediately after the
-   name of the command that this function belongs to.  See below for several
-   examples.)
-
-   Your function must look for and process any options that appear at the
-   beginning of *argv*.  If there are any errors processing the options, you
-   should print out an error message (most likely via
-   :c:func:`cork_command_show_help`) and exit the program, using the standard
-   ``exit`` function, with an exit code of ``EXIT_FAILURE``.
-
-   If there aren't any errors processing the options, you should return the
-   number of *argv* elements that were consumed while processing the options.
-   We will use this return value to update *argc* and *argv* beforing continuing
-   with subcommand selection and argument processing.  (Note that ``getopt``'s
-   ``optind`` variable is exactly what you need for the return value.)
-
-As mentioned above, different option parsing functions are used to parse options
-from a particular point in the command line.  Given the following command:
-
-.. code-block:: none
-
-    $ set --opt1 print --opt2 avro --opt3 --opt4=foo <filename>
-
-The ``--opt1`` option would be parsed by the ``set`` command's parser.  The
-``--opt2`` option would be parsed by the ``set print`` command's parser.  The
-``--opt3`` and ``-opt4=foo`` options would be parsed by the ``set print avro``
-command's parser.  And the ``<filename>`` argument would be parsed by the ``set
-print avro`` command's *run* function.
diff --git a/docs/old/conf.py b/docs/old/conf.py
deleted file mode 100644
index 6484a5e..0000000
--- a/docs/old/conf.py
+++ /dev/null
@@ -1,80 +0,0 @@
-# -*- coding: utf-8 -*-
-
-import sys, os
-
-extensions = ['sphinx.ext.mathjax']
-source_suffix = '.rst'
-master_doc = 'index'
-project_name = u'libcork'
-project_slug = u'libcork'
-company = u'RedJack, LLC'
-copyright_years = u'2011-2012'
-
-default_role = 'c:func'
-primary_domain = 'c'
-
-rst_epilog = """
-.. |project_name| replace:: """ + project_name + """
-"""
-
-# Intersphinx stuff
-
-# If your documentation uses intersphinx to link to other Sphinx
-# documentation sets, uncomment and fill in the following.
-#
-#intersphinx_mapping = {
-#    'libcork': ('http://libcork.readthedocs.org/en/latest/', None),
-#}
-
-# Our CMake build scripts will insert overrides below if the prereq
-# libraries have installed their Sphinx documentation locally.  DO NOT
-# uncomment out the last line of this block; we need it commented so
-# that this conf.py file still works if CMake doesn't do its
-# substitution thing.
-# @INTERSPHINX_OVERRIDES@
-
-#----------------------------------------------------------------------
-# Everything below here shouldn't need to be changed.
-
-release = None
-version = None
-
-# Give CMake a chance to insert a version number
-# @VERSION_FOR_CONF_PY@
-
-# Otherwise grab version from git
-if version is None:
-    import re
-    import subprocess
-    release = str(subprocess.check_output(["git", "describe"]).rstrip())
-    version = re.sub(r"-dev.*$", "-dev", release)
-
-# Project details
-
-project = project_name
-copyright = copyright_years+u', '+company
-templates_path = ['_templates']
-exclude_patterns = ['_build']
-pygments_style = 'sphinx'
-
-html_theme = 'default'
-html_style = 'docco-sphinx.css'
-html_static_path = ['_static']
-htmlhelp_basename = project_slug+'-doc'
-
-
-latex_documents = [
-  ('index', project_slug+'.tex', project_name+u' Documentation',
-   company, 'manual'),
-]
-
-man_pages = [
-    ('index', 'libcork', u'libcork documentation',
-     [u'RedJack, LLC'], 1)
-]
-
-texinfo_documents = [
-  ('index', 'libcork', u'libcork documentation',
-   u'RedJack, LLC', 'libcork', 'One line description of project.',
-   'Miscellaneous'),
-]
diff --git a/docs/old/config.rst b/docs/old/config.rst
deleted file mode 100644
index d7baf6d..0000000
--- a/docs/old/config.rst
+++ /dev/null
@@ -1,176 +0,0 @@
-.. _config:
-
-*******************
-Configuring libcork
-*******************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/config.h>
-
-Several libcork features have different implementations on different
-platforms.  Since we want libcork to be easily embeddable into projects
-with a wide range of build systems, we try to autodetect which
-implementations to use, using only the C preprocessor and the predefined
-macros that are available on the current system.
-
-This module provides a layer of indirection, with all of the
-preprocessor-based autodetection in one place.  This module's task is to
-define a collection of libcork-specific configuration macros, which all
-other libcork modules will use to select which implementation to use.
-
-This design also lets you skip the autodetection, and provide values for
-the configuration macros directly.  This is especially useful if you're
-embedding libcork into another project, and already have a ``configure``
-step in your build system that performs platform detection.  See
-:c:macro:`CORK_CONFIG_SKIP_AUTODETECT` for details.
-
-.. note::
-
-   The autodetection logic is almost certainly incomplete.  If you need
-   to port libcork to another platform, this is where an important chunk
-   of edits will take place.  Patches are welcome!
-
-
-.. _configuration-macros:
-
-Configuration macros
-====================
-
-This section lists all of the macros that are defined by libcork's
-autodetection logic.  Other libcork modules will use the values of these
-macros to choose among the possible implementations.
-
-
-.. macro:: CORK_CONFIG_VERSION_MAJOR
-           CORK_CONFIG_VERSION_MINOR
-           CORK_CONFIG_VERSION_PATCH
-
-   The libcork library version, with each part of the version number separated
-   out into separate macros.
-
-
-.. macro:: CORK_CONFIG_VERSION_STRING
-
-   The libcork library version, encoded as a single string.
-
-
-.. macro:: CORK_CONFIG_REVISION
-
-   The git SHA-1 commit identifier of the libcork version that you're using.
-
-
-.. macro:: CORK_CONFIG_ARCH_X86
-           CORK_CONFIG_ARCH_X64
-           CORK_CONFIG_ARCH_PPC
-
-   Exactly one of these macros should be defined to ``1`` to indicate
-   the architecture of the current platform.  All of the other macros
-   should be defined to ``0`` or left undefined.  The macros correspond
-   to the following architectures:
-
-   ============ ================================================
-   Macro suffix Architecture
-   ============ ================================================
-   ``X86``      32-bit Intel (386 or greater)
-   ``X64``      64-bit Intel/AMD (AMD64/EM64T, *not* IA-64)
-   ``PPC``      32-bit PowerPC
-   ============ ================================================
-
-
-.. macro:: CORK_CONFIG_HAVE_GCC_ASM
-
-   Whether the GCC `inline assembler`_ syntax is available.  (This
-   doesn't imply that the compiler is specifically GCC.)  Should be
-   defined to ``0`` or ``1``.
-
-   .. _inline assembler: http://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html
-
-
-.. macro:: CORK_CONFIG_HAVE_GCC_ATTRIBUTES
-
-   Whether the GCC-style syntax for `compiler attributes`_ is available.
-   (This doesn't imply that the compiler is specifically GCC.)  Should
-   be defined to ``0`` or ``1``.
-
-   .. _compiler attributes: http://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html
-
-
-.. macro:: CORK_CONFIG_HAVE_GCC_ATOMICS
-
-   Whether GCC-style `atomic intrinsics`_ are available.  (This doesn't
-   imply that the compiler is specifically GCC.)  Should be defined to
-   ``0`` or ``1``.
-
-   .. _atomic intrinsics: http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html
-
-
-
-.. macro:: CORK_CONFIG_HAVE_GCC_INT128
-
-   Whether the GCC-style `128-bit integer`_ types (``__int128`` and ``unsigned
-   __int128``) are available.  (This doesn't imply that the compiler is
-   specifically GCC.)  Should be defined to ``0`` or ``1``.
-
-   .. _128-bit integer: http://gcc.gnu.org/onlinedocs/gcc/_005f_005fint128.html
-
-
-.. macro:: CORK_CONFIG_HAVE_GCC_MODE_ATTRIBUTE
-
-   Whether GCC-style `machine modes`_ are available.  (This doesn't imply that
-   the compiler is specifically GCC.)  Should be defined to ``0`` or ``1``.
-
-   .. _machine modes: http://gcc.gnu.org/onlinedocs/gcc-4.8.1/gccint/Machine-Modes.html#Machine-Modes
-
-
-.. macro:: CORK_CONFIG_HAVE_GCC_STATEMENT_EXPRS
-
-   Whether GCC-style `statement expressions`_ are available.
-   (This doesn't imply that the compiler is specifically GCC.)  Should
-   be defined to ``0`` or ``1``.
-
-   .. _statement expressions: http://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html
-
-
-.. macro:: CORK_CONFIG_HAVE_REALLOCF
-
-   Whether this platform defines a ``reallocf`` function in
-   ``stdlib.h``.  ``reallocf`` is a BSD extension to the standard
-   ``realloc`` function that frees the existing pointer if a
-   reallocation fails.  If this function exists, we can use it to
-   implement :func:`cork_realloc`.
-
-
-.. macro:: CORK_CONFIG_IS_BIG_ENDIAN
-           CORK_CONFIG_IS_LITTLE_ENDIAN
-
-   Whether the current system is big-endian or little-endian.  Exactly
-   one of these macros should be defined to ``1``; the other should be
-   defined to ``0``.
-
-
-.. _skipping-autodetection:
-
-Skipping autodetection
-======================
-
-
-.. macro:: CORK_CONFIG_SKIP_AUTODETECT
-
-   If you want to skip libcork's autodetection logic, then you are
-   responsible for providing the appropriate values for all of the
-   macros defined in :ref:`configuration-macros`.  To do this, have your
-   build system define this macro, with a value of ``1``.  This will
-   override the default value of ``0`` provided in the
-   ``libcork/config/config.h`` header file.
-
-   Then, create (or have your build system create) a
-   ``libcork/config/custom.h`` header file.  You can place this file
-   anywhere in your header search path.  We will load that file instead
-   of libcork's autodetection logic.  Place the appropriate definitions
-   for each of the configuration macros into this file.  If needed, you
-   can generate this file as part of the ``configure`` step of your
-   build system; the only requirement is that it's available once you
-   start compiling the libcork source files.
diff --git a/docs/old/dllist.rst b/docs/old/dllist.rst
deleted file mode 100644
index 313cdd1..0000000
--- a/docs/old/dllist.rst
+++ /dev/null
@@ -1,296 +0,0 @@
-.. _dllist:
-
-*******************
-Doubly-linked lists
-*******************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/ds.h>
-
-This section defines a doubly-linked list data structure.  The structure
-is “invasive”, since you must place an instance of the
-:c:type:`cork_dllist_item` type into the type whose instances will be
-stored in the list.  The list itself is represented by the
-:c:type:`cork_dllist` type.
-
-As an example, we could define the following types for storing groups,
-as well as the users within each group::
-
-  struct group {
-      const char  *group_name;
-      struct cork_dllist  members;
-  };
-
-  struct user {
-      const char  *username;
-      const char  *real_name;
-      struct cork_dllist_item  list;
-  };
-
-Note that both ``cork_dllist`` and ``cork_dllist_item`` are embedded
-directly into our domain-specific types.  This means that every list
-operation defined in this section is guaranteed to succeed, since no
-memory operations will be involved.  (The list and any items will have
-already been allocated before you try to call the list function.)
-
-Like with any embedded ``struct``, you can use the
-:c:func:`cork_container_of` macro to obtain a pointer to a ``struct
-user`` if you're given a pointer to a :c:type:`cork_dllist_item`.
-
-
-.. type:: struct cork_dllist
-
-   A doubly-linked list.  The list itself is represented by a sentinel
-   element, representing the empty list.
-
-
-.. type:: struct cork_dllist_item
-
-   An element of a doubly-linked list.  This type will usually be
-   embedded within the type whose instances will be stored in the list.
-
-   .. member:: struct cork_dllist_item \*next
-               struct cork_dllist_item \*prev
-
-      A pointer to the next (or previous) element in the list.  If this
-      element marks the end (or beginning) of the list, then *next* (or
-      *prev*) will point to the list's sentinel value.
-
-
-.. function:: void cork_dllist_init(struct cork_dllist \*list)
-              struct cork_dllist CORK_DLLIST_INIT(SYMBOL name)
-
-   Initializes a doubly-linked list.  The list will initially be empty.
-
-   The second variant is a static initializer, that lets you initialize a list
-   at compile time, rather than runtime.  You must pass in the name of the list
-   for this to work, since we need to be able to extract pointers into the list
-   object.
-
-
-Querying a list
----------------
-
-.. function:: size_t cork_dllist_size(const struct cork_dllist \*list)
-
-   Returns the number of elements in *list*.
-   
-   This operation runs in :math:`O(n)` time.
-
-
-.. function:: bool cork_dllist_is_empty(struct cork_dllist \*list)
-
-   Returns whether *list* is empty.
-
-   This operation runs in :math:`O(1)` time.
-
-
-Editing a list
---------------
-
-.. function:: void cork_dllist_add_to_head(struct cork_dllist \*list, struct cork_dllist_item \*element)
-              void cork_dllist_add_to_tail(struct cork_dllist \*list, struct cork_dllist_item \*element)
-
-   Adds *element* to *list*.  The ``_head`` variant adds the new element to the
-   beginning of the list; the ``_tail`` variant adds it to the end.
-   
-   You are responsible for allocating the list element yourself, most likely by
-   allocating the ``struct`` that you've embedded :c:type:`cork_dllist_item`
-   into.
-
-   .. note::
-
-      This function assumes that *element* isn't already a member of a different
-      list.  You're responsible for calling :c:func:`cork_dllist_remove()` if
-      this isn't the case.  (If you don't, the other list will become
-      malformed.)
-
-   This operation runs in :math:`O(1)` time.
-
-
-.. function:: void cork_dllist_add_after(struct cork_dllist_item \*pred, struct cork_dllist_item \*element)
-              void cork_dllist_add_before(struct cork_dllist_item \*succ, struct cork_dllist_item \*element)
-
-   Adds *element* to the same list that *pred* or *succ* belong to.  The
-   ``_after`` variant ensures that *element* appears in the list immediately
-   after *pred*.  The ``_before`` variant ensures that *element* appears in the
-   list immediately before *succ*.
-
-   .. note::
-
-      This function assumes that *element* isn't already a member of a different
-      list.  You're responsible for calling :c:func:`cork_dllist_remove()` if
-      this isn't the case.  (If you don't, the other list will become
-      malformed.)
-
-   This operation runs in :math:`O(1)` time.
-
-
-.. function:: void cork_dllist_add_list_to_head(struct cork_dllist \*dest, struct cork_dllist \*src)
-              void cork_dllist_add_list_to_tail(struct cork_dllist \*dest, struct cork_dllist \*src)
-
-   Moves all of the elements in *src* to *dest*.  The ``_head`` variant moves
-   the elements to the beginning of *dest*; the ``_tail`` variant moves them to
-   the end.  After these functions return, *src* will be empty.
-
-   This operation runs in :math:`O(1)` time.
-
-
-.. function:: void cork_dllist_remove(struct cork_dllist_item \*element)
-
-   Removes *element* from the list that it currently belongs to.  (Note
-   that you don't have to pass in a pointer to that list.)
-
-   .. note::
-
-      You must not call this function on a list's sentinel element.
-
-   This operation runs in :math:`O(1)` time.
-
-
-Iterating through a list
-------------------------
-
-There are two strategies you can use to access all of the elements in a
-doubly-linked list: *visiting* and *iterating*.  With visiting, you write
-a visitor function, which will be applied to each element in the list.
-(In this case, libcork controls the loop that steps through each
-element.)
-
-.. function:: int cork_dllist_visit(struct cork_dllist \*list, void \*user_data, cork_dllist_visit_f \*func)
-
-   Apply a function to each element in *list*.  The function is allowed
-   to remove the current element from the list; this will not affect our
-   ability to iterate through the remainder of the list.  The function
-   will be given a pointer to the :c:type:`cork_dllist_item` for each
-   element; you can use :c:func:`cork_container_of()` to get a pointer to the
-   actual element type.
-
-   If your visitor function ever returns a non-zero value, we will abort the
-   iteration and return that value from ``cork_dllist_visit``.  If your function
-   always returns ``0``, then you will visit all of the elements in *list*, and
-   we'll return ``0`` from ``cork_dllist_visit``.
-
-   .. type:: int cork_dllist_visit_f(void \*user_data, struct cork_dllist_item \*element)
-
-      A function that can be applied to each element in a doubly-linked list.
-
-For instance, you can manually calculate the number of elements in a
-list as follows (assuming you didn't want to use the built-in
-:c:func:`cork_dllist_size()` function, of course)::
-
-  static int
-  count_elements(void *user_data, struct cork_dllist_item *element)
-  {
-      size_t  *count = ud;
-      (*count)++;
-      return 0;
-  }
-
-  struct cork_dllist  *list = /* from somewhere */;
-  size_t  count = 0;
-  cork_dllist_visit(list, &count, count_elements);  /* returns 0 */
-  /* the number of elements is now in count */
-
-
-The second strategy is to iterate through the elements yourself.
-
-.. macro:: cork_dllist_foreach(struct cork_dllist \*list, struct cork_dllist_item &\*curr, struct cork_dllist_item &\*next, TYPE element_type, TYPE &\*element, FIELD item_field)
-           cork_dllist_foreach_void(struct cork_dllist \*list, struct cork_dllist_item &\*curr, struct cork_dllist_item &\*next)
-
-   Iterate through each element in *list*, executing a statement for each one.
-   You must declare two variables of type ``struct cork_dllist_item *``, and
-   pass in their names as *curr* and *next*.  (You'll usually call the variables
-   ``curr`` and ``next``, too.)
-
-   For the ``_void`` variant, your statement can only use these
-   :c:type:`cork_dllist_item` variables to access the current list element.  You
-   can use :c:func:`cork_container_of` to get a pointer to the actual element
-   type.
-
-   For the non-``_void`` variant, we'll automatically call
-   :c:func:`cork_container_of` for you.  *element_type* should be the actual
-   element type, which must contain an embedded :c:func:`cork_dllist_item`
-   field.  *item_field* should be the name of this embedded field.  You must
-   allocate a pointer to the element type, and pass in its name as *element*.
-
-For instance, you can use these macros calculate the number of elements as
-follows::
-
-  struct cork_dllist  *list = /* from somewhere */;
-  struct cork_dllist  *curr;
-  struct cork_dllist  *next;
-  size_t  count = 0;
-  cork_dllist_foreach_void(list, curr, next) {
-      count++;
-  }
-  /* the number of elements is now in count */
-
-We're able to use :c:macro:`cork_dllist_foreach_void` since we don't need to
-access the contents of each element to calculate how many of theo there are.  If
-we wanted to calculuate a sum, however, we'd have to use
-:c:macro:`cork_dllist_foreach`::
-
-  struct element {
-      unsigned int  value;
-      struct cork_dllist_item  item;
-  };
-
-  struct cork_dllist  *list = /* from somewhere */;
-  struct cork_dllist  *curr;
-  struct cork_dllist  *next;
-  struct element  *element;
-  unsigned int  sum = 0;
-  cork_dllist_foreach(list, curr, next, struct element, element, item) {
-      sum += element->value;
-  }
-  /* the sum of the elements is now in sum */
-
-
-If the ``foreach`` macros don't provide what you need, you can also iterate
-through the list manually.
-
-.. function:: struct cork_dllist_item \*cork_dllist_head(struct cork_dllist \*list)
-              struct cork_dllist_item \*cork_dllist_start(struct cork_dllist \*list)
-
-   Returns the element at the beginning of *list*.  If *list* is empty,
-   then the ``_head`` variant will return ``NULL``, while the ``_start``
-   variant will return the list's sentinel element.
-
-
-.. function:: struct cork_dllist_item \*cork_dllist_tail(struct cork_dllist \*list)
-              struct cork_dllist_item \*cork_dllist_end(struct cork_dllist \*list)
-
-   Returns the element at the end of *list*.  If *list* is empty, then
-   the ``_tail`` variant will return ``NULL``, while the ``_end``
-   variant will return the list's sentinel element.
-
-.. function:: bool cork_dllist_is_start(struct cork_dllist \*list, struct cork_dllist_item \*element)
-              bool cork_dllist_is_end(struct cork_dllist \*list, struct cork_dllist_item \*element)
-
-   Returns whether *element* marks the start (or end) of *list*.
-
-With these functions, manually counting the list elements looks like::
-
-  struct cork_dllist  *list = /* from somewhere */;
-  struct cork_dllist_item  *curr;
-  size_t  count = 0;
-  for (curr = cork_dllist_start(list); !cork_dllist_is_end(list, curr);
-       curr = curr->next) {
-      count++;
-  }
-  /* the number of elements is now in count */
-
-You can also count the elements in reverse order::
-
-  struct cork_dllist  *list = /* from somewhere */;
-  struct cork_dllist_item  *curr;
-  size_t  count = 0;
-  for (curr = cork_dllist_end(list); !cork_dllist_is_start(list, curr);
-       curr = curr->prev) {
-      count++;
-  }
-  /* the number of elements is now in count */
diff --git a/docs/old/ds.rst b/docs/old/ds.rst
deleted file mode 100644
index b6276db..0000000
--- a/docs/old/ds.rst
+++ /dev/null
@@ -1,26 +0,0 @@
-.. _ds:
-
-***************
-Data structures
-***************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/ds.h>
-
-libcork includes implementations of a number of useful data structures.
-
-.. toctree::
-   :maxdepth: 1
-
-   array
-   bitset
-   slice
-   managed-buffer
-   buffer
-   stream
-   dllist
-   hash-table
-   ring-buffer
diff --git a/docs/old/errors.rst b/docs/old/errors.rst
deleted file mode 100644
index 434e203..0000000
--- a/docs/old/errors.rst
+++ /dev/null
@@ -1,479 +0,0 @@
-.. _errors:
-
-***************
-Error reporting
-***************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-This section defines an API for reporting error conditions.  It's loosely
-modeled on the POSIX ``errno`` mechanism.
-
-The standard POSIX approach for reporting errors is to return an integer status
-code, and to store error codes into the ``errno`` global variable.  This
-approach has a couple of drawbacks.  The first is that you --- or really, your C
-library --- has to ensure that ``errno`` is placed in thread-local storage, so
-that separate threads have their own error condition variables.  The second, and
-in our mind more important, is that the set of error codes is fixed and
-platform-dependent.  It's difficult to add new error codes to represent
-application-level error conditions.
-
-The libcork error API is a way around this.  Like standard POSIX-conforming
-functions, you return an integer status code from any function that might need
-to report an error to its caller.  The status return code is simple: ``0``
-indicates success, ``-1`` indicates failure.
-
-When an error occurs, you can use the functions in this section to get more
-information about the error: an *error code*, and human-readable string
-description of the error.  The POSIX ``errno`` values, while hard to extend, are
-perfectly well-defined for most platforms; therefore, any ``errno`` value
-supported by your system's C library is a valid libcork error code.  To support
-new application-specific error codes, an error code can also be the hash of some
-string describing the error.  This “hash of a string” approach makes it easy to
-define new error codes without needing any centralized mechanism for assigning
-IDs to the various codes.  Moreover, it's very unlikely that a hashed error code
-will conflict with some existing POSIX ``errno`` value, or with any other hashed
-error codes.
-
-.. note::
-
-   We correctly maintain a separate error condition for each thread in
-   the current process.  This is all hidden by the functions in this
-   section; it's safe to call them from multiple threads simultaneously.
-
-
-Calling a function that can return an error
--------------------------------------------
-
-There are two basic forms for a function that can produce an error.  The
-first is if the function returns a single pointer as its result::
-
-  TYPE *
-  my_function(/* parameters */);
-
-The second is for any other function::
-
-  int
-  my_function(/* parameters */);
-
-If an error occurs, the function will return either ``NULL`` or ``-1``,
-depending on its return type.  Success will be indicated by a non-\
-``NULL`` pointer or a ``0``.  (More complex return value schemes are
-possible, if the function needs to signal more than a simple “success”
-or “failure”; in that case, you'll need to check the function's
-documentation for details.)
-
-If you want to know specifics about the error, there are several
-functions that you can use to interrogate the current error condition.
-
-.. function:: bool cork_error_occurred(void)
-
-   Returns whether an error has occurred.
-
-.. function:: cork_error cork_error_code(void)
-
-   Returns the error code of the current error condition.  If no error has
-   occurred, the result will be :c:macro:`CORK_ERROR_NONE`.
-
-.. function:: const char \*cork_error_message(void)
-
-   Returns the human-readable string description the current error
-   condition.  If no error occurred, the result of this function is
-   undefined.
-
-You can use the ``cork_error_prefix`` family of functions to add additional
-context to the beginning of an error message.
-
-.. function:: void cork_error_prefix_printf(const char \*format, ...)
-              void cork_error_prefix_string(const char \*string)
-              void cork_error_prefix_vprintf(const char \*format, va_list args)
-
-   Prepends some additional text to the current error condition.
-
-When you're done checking the current error condition, you clear it so
-that later calls to :c:func:`cork_error_occurred` and friends don't
-re-report this error.
-
-.. function:: void cork_error_clear(void)
-
-   Clears the current error condition.
-
-
-Writing a function that can return an error
--------------------------------------------
-
-When writing a function that might produce an error condition, your
-function signature should follow one of the two standard patterns
-described above::
-
-  int
-  my_function(/* parameters */);
-
-  TYPE *
-  my_function(/* parameters */);
-
-You should return ``-1`` or ``NULL`` if an error occurs, and ``0`` or a
-non-\ ``NULL`` pointer if it succeeds.  If ``NULL`` is a valid
-“successful” result of the function, you should use the first form, and
-define a ``TYPE **`` output parameter to return the actual pointer
-value.  (If you're using the first form, you can use additional return
-codes if there are other possible results besides a simple “success” and
-“failure”.)
-
-If your function results in an error, you need to fill in the current
-error condition using the ``cork_error_set`` family of functions:
-
-.. function:: void cork_error_set_printf(cork_error ecode, const char \*format, ...)
-              void cork_error_set_string(cork_error ecode, const char \*string)
-              void cork_error_set_vprintf(cork_error ecode, const char \*format, va_list args)
-
-   Fills in the current error condition.  The error condition is defined
-   by the error code *ecode*.  The human-readable description is constructed
-   from *string*, or from *format* and any additional parameters, depending on
-   which variant you use.
-
-As an example, the :ref:`IP address <net-addresses>` parsing functions fill in
-:c:macro:`CORK_PARSE_ERROR` error conditions when you try to parse a malformed
-address::
-
-  const char  *str = /* the string that's being parsed */;
-  cork_error_set_printf
-      (CORK_PARSE_ERROR, "Invalid IP address: %s", str);
-
-If a particular kind of error can be raised in several places
-throughout your code, it can be useful to define a helper function for
-filling in the current error condition::
-
-  static void
-  cork_ip_address_parse_error(const char *version, const char *str)
-  {
-      cork_error_set_printf
-          (CORK_PARSE_ERROR, "Invalid %s address: %s", version, str);
-  }
-
-
-Error-checking macros
----------------------
-
-There can be a lot of repetitive code when calling functions that return
-error conditions.  We provide a collection of helper macros that make it
-easier to write this code.
-
-.. note::
-
-   Unlike most libcork modules, these macros are **not** automatically
-   defined when you include the ``libcork/core.h`` header file, since
-   they don't include a ``cork_`` prefix.  Because of this, we don't
-   want to pollute your namespace unless you ask for the macros.  To do
-   so, you must explicitly include their header file::
-
-     #include <libcork/helpers/errors.h>
-
-Additional debugging output
-~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-.. macro:: CORK_PRINT_ERRORS
-
-   If you define this macro to ``1`` before including
-   :file:`libcork/helpers/errors.h`, then we'll output the current
-   function name, file, and line number, along with the description of
-   the error, to stderr whenever an error is detected by one of the
-   macros described in this section.
-
-Returning a default error code
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-If you follow one of the standard function signature patterns described
-above, then your function will either return an ``int`` or some pointer
-type, and errors will be signalled by a return value of ``-1`` or
-``NULL``.  If so, you can use the macros in this section to
-automatically return the appropriate error return value if a nested
-function call returns an error.
-
-With these macros, you won't have a chance to inspect the error
-condition when an error occurs, so you should pass in your own *err*
-parameter when calling the nested function.
-
-(The mnemonic for remembering these macro names is that they all start
-with ``rXY_``.  The ``r`` indicates that they automatically “return”.
-The second character indicates whether *your* function returns an
-``int`` or a pointer.  The third character indicates whether the
-function you're *calling* returns an ``int`` or a pointer.)
-
-.. function:: void rie_check(call)
-
-   Call a function whose return value isn't enough to check for an error, when
-   your function returns an ``int``.  We'll use :c:func:`cork_error_occurred` to
-   check for an error.  If the nested function call returns an error, we
-   propagate that error on.
-
-.. function:: void rii_check(call)
-
-   Call a function that returns an ``int`` error indicator, when your
-   function also returns an ``int``.  If the nested function call
-   returns an error, we propagate that error on.
-
-.. function:: void rip_check(call)
-
-   Call a function that returns a pointer, when your function returns an
-   ``int``.  If the nested function call returns an error, we propagate
-   that error on.
-
-.. function:: void rpe_check(call)
-
-   Call a function whose return value isn't enough to check for an error, when
-   your function returns a pointer.  We'll use :c:func:`cork_error_occurred` to
-   check for an error.  If the nested function call returns an error, we
-   propagate that error on.
-
-.. function:: void rpi_check(call)
-
-   Call a function that returns an ``int`` error indicator, when your
-   function returns a pointer.  If the nested function call returns an
-   error, we propagate that error on.
-
-.. function:: void rpp_check(call)
-
-   Call a function that returns a pointer, when your function also
-   returns a pointer.  If the nested function call returns an error, we
-   propagate that error on.
-
-Returning a non-standard return value
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-If your function doesn't have a standard signature, or it uses
-additional return values besides ``0``, ``1``, ``NULL``, and valid
-pointers, then you can use the macros in this section to return a custom
-return value in case of an error.
-
-With these macros, you won't have a chance to inspect the error
-condition when an error occurs, so you should pass in your own *err*
-parameter when calling the nested function.
-
-(The mnemonic for remembering these macro names is that they all start
-with ``xY_``.  The ``x`` doesn't standard for anything in particular.
-The second character indicates whether the function you're *calling*
-returns an ``int`` or a pointer.  We don't need separate macros for
-*your* function's return type, since you provide a return value
-explicitly.)
-
-.. function:: void xe_check(retval, call)
-
-   Call a function whose return value isn't enough to check for an error.  If
-   the nested function call raises an error, we propagate that error on, and
-   return *retval* from the current function.
-
-.. function:: void xi_check(retval, call)
-
-   Call a function that returns an ``int`` error indicator.  If the
-   nested function call raises an error, we propagate that error on, and
-   return *retval* from the current function.
-
-.. function:: void xp_check(retval, call)
-
-   Call a function that returns a pointer.  If the nested function call
-   raises an error, we propagate that error on, and return *retval* from
-   the current function.
-
-Post-processing when an error occurs
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-If you need to perform some post-processing when a nested function
-returns an error, you can use the functions in this section.  They will
-automatically jump to the current scope's ``error`` label whenever an
-error occurs.
-
-(The mnemonic for remembering these macro names is that they all start
-with ``eY_``.  The ``e`` indicates that they'll jump to the ``error``
-label.  The second character indicates whether the function you're
-*calling* returns an ``int`` or a pointer.  We don't need separate
-macros for *your* function's return type, since the macros won't
-automatically return anything.)
-
-.. function:: void ei_check(call)
-
-   Call a function whose return value isn't enough to check for an error.  If
-   the nested function call raises an error, we automatically jump to the
-   current scope's ``error`` label.
-
-.. function:: void ei_check(call)
-
-   Call a function that returns an ``int`` error indicator.  If the
-   nested function call raises an error, we automatically jump to the
-   current scope's ``error`` label.
-
-.. function:: void ep_check(call)
-
-   Call a function that returns a pointer.  If the nested function call
-   raises an error, we automatically jump to the current scope's
-   ``error`` label.
-
-
-Calling POSIX functions
-~~~~~~~~~~~~~~~~~~~~~~~
-
-The :c:func:`cork_system_error_set` function automatically translates a POSIX
-error (specified in the standard ``errno`` variable) into a libcork error
-condition (which will be reported by :c:func:`cork_error_occurred` and friends).
-We also define several helper macros for calling a POSIX function and
-automatically checking its result.
-
-::
-
-   #include <libcork/helpers/posix.h>
-
-.. note::
-
-   For all of these macros, the ``EINTR`` POSIX error is handled specially.
-   This error indicates that a system call was interrupted by a signal, and that
-   the call should be retried.  The macros do not translate ``EINTR`` errors
-   into libcork errors; instead, they will retry the ``call`` until the
-   statement succeeds or returns a non-``EINTR`` error.
-
-.. function:: void rii_check_posix(call)
-
-   Call a function that returns an ``int`` error indicator, when your function
-   also returns an ``int``.  If the nested function call returns a POSIX error,
-   we translate it into a libcork error and return a libcork error code.
-
-.. function:: void rip_check_posix(call)
-
-   Call a function that returns a pointer, when your function returns an
-   ``int``.  If the nested function call returns a POSIX error, we translate it
-   into a libcork error and return a libcork error code.
-
-.. function:: void rpi_check_posix(call)
-
-   Call a function that returns an ``int`` error indicator, when your function
-   returns a pointer.  If the nested function call returns a POSIX error, we
-   translate it into a libcork error and return a libcork error code.
-
-.. function:: void rpp_check_posix(call)
-
-   Call a function that returns a pointer, when your function also returns a
-   pointer.  If the nested function call returns a POSIX error, we translate it
-   into a libcork error and return a libcork error code.
-
-.. function:: void ei_check_posix(call)
-
-   Call a function that returns an ``int`` error indicator.  If the nested
-   function call raises a POSIX error, we translate it into a libcork error and
-   automatically jump to the current scope's ``error`` label.
-
-.. function:: void ep_check_posix(call)
-
-   Call a function that returns a pointer.  If the nested function call raises a
-   POSIX error, we translate it into a libcork error and automatically jump to
-   the current scope's ``error`` label.
-
-
-Defining new error codes
-------------------------
-
-If none of the built-in error codes suffice for an error condition that you need
-to report, you'll have to define our own.  As mentioned above, each libcork
-error code is either a predefined POSIX ``errno`` value, or a hash some of
-string identifying a custom error condition.
-
-Typically, you will create a macro in one of your public header files, whose
-value will be your new custom error code.  If this is the case, you can use the
-macro name itself to create the hash value for the error code.  This is what we
-do for the non-POSIX builtin errors; for instance, the value of the
-:c:macro:`CORK_PARSE_ERROR` error code macro is the hash of the string
-``CORK_PARSE_ERROR``.
-
-Given this string, you can produce the error code's hash value using the
-:ref:`cork-hash <cork-hash>` command that's installed with libcork::
-
-  $ cork-hash CORK_PARSE_ERROR
-  0x95dfd3c8
-
-It's incredibly unlikely that the hash value for your new error code will
-conflict with any other custom hash-based error codes, or with any predefined
-POSIX ``errno`` values.
-
-With your macro name and hash value ready, defining the new error code is
-simple::
-
-  #define CORK_PARSE_ERROR  0x95dfd3c8
-
-You should also provide a helper macro that makes it easier to report new
-instances of this error condition::
-
-  #define cork_parse_error(...) \
-      cork_error_set_printf(CORK_PARSE_ERROR, __VA_ARGS__)
-
-.. type:: uint32_t  cork_error
-
-   An identifier for a particular error condition.  This will either be a
-   predefined POSIX ``errno`` value, or the hash of a unique string describing
-   the error condition.
-
-With your error class and code defined, you can fill in error instances
-using :c:func:`cork_error_set_printf` and friends.
-
-
-Builtin errors
---------------
-
-In addition to all of the predefined POSIX ``errno`` values, we also provide
-error codes for a handful of common error conditions.  You should feel free to
-use these in your libraries and applications, instead of creating custom error
-codes, if they apply.
-
-.. macro:: CORK_ERROR_NONE
-
-   A special error code that signals that no error occurred.
-
-.. macro:: CORK_PARSE_ERROR
-
-   The provided input violates the rules of the language grammar or file format
-   (or anything else, really) that you're trying to parse.
-
-   .. function:: void cork_parse_error(const char *format*, ...)
-
-.. macro:: CORK_REDEFINED
-           CORK_UNDEFINED
-
-   Useful when you have a container type that must ensure that there is only one
-   entry for any given key.
-
-   .. function:: void cork_redefined(const char *format*, ...)
-                 void cork_undefined(const char *format*, ...)
-
-.. macro:: CORK_UNKNOWN_ERROR
-
-   Some error occurred, but we don't have any other information about the error.
-
-   .. function:: void cork_unknown_error(void)
-
-      The error description will include the name of the current function.
-
-
-We also provide some helper functions for setting these built-in errors:
-
-.. function:: void cork_system_error_set(void)
-              void cork_system_error_set_explicit(int err)
-
-   Fills in the current libcork error condition with information from a POSIX
-   ``errno`` value.  The human-readable description of the error will be
-   obtained from the standard ``strerror`` function.  With the ``_explicit``
-   variant, you provide the ``errno`` value directly; for the other variant, we
-   get the error code from the C library's ``errno`` variable.
-
-
-.. function:: void cork_abort(const char \*fmt, ...)
-
-   Aborts the current program with an error message given by *fmt* and any
-   additional parameters.
-
-.. function:: void cork_unreachable(void)
-
-   Aborts the current program with a message indicating that the code path
-   should be unreachable.  This can be useful in the ``default`` clause of a
-   ``switch`` statement if you can ensure that one of the non-``default``
-   branches will always be selected.
diff --git a/docs/old/files.rst b/docs/old/files.rst
deleted file mode 100644
index b726226..0000000
--- a/docs/old/files.rst
+++ /dev/null
@@ -1,414 +0,0 @@
-.. _files:
-
-*********************
-Files and directories
-*********************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/os.h>
-
-The functions in this section let you interact with files and directories in the
-local filesystem.
-
-
-Paths
-=====
-
-We provide several functions for constructing and handling paths into the local
-filesystem.
-
-.. type:: struct cork_path
-
-   Represents a path in the local filesystem.  The path can be relative or
-   absolute.  The paths don't have to refer to existing files or directories.
-
-.. function:: struct cork_path \*cork_path_new(const char \*path)
-              struct cork_path \*cork_path_clone(const struct cork_path \*other)
-
-   Construct a new path object from the given path string, or as a copy of
-   another path object.
-
-.. function:: void cork_path_free(struct cork_path \*path)
-
-   Free a path object.
-
-.. function:: const char \*cork_path_get(const struct cork_path \*path)
-
-   Return the string content of a path.  This is not normalized in any way.  The
-   result is guaranteed to be non-``NULL``, but may refer to an empty string.
-   The return value belongs to the path object; you must not modify the contents
-   of the string, nor should you try to free the underlying memory.
-
-.. function:: struct cork_path \*cork_path_absolute(const struct cork_path \*other)
-              int cork_path_make_absolute(struct cork_path \path)
-
-   Convert a relative path into an absolute path.  The first variant constructs
-   a new path object to hold the result; the second variant overwritesthe
-   contents of *path*.
-
-   If there is a problem obtaining the current working directory, these
-   functions will return an error condition.
-
-.. function:: struct cork_path \*cork_path_join(const struct cork_path \*path, const char \*more)
-              struct cork_path \*cork_path_join_path(const struct cork_path \*path, const struct cork_path \*more)
-              void \*cork_path_append(struct cork_path \path, const char \*more)
-              void \*cork_path_append_path(struct cork_path \*path, const struct cork_path \*more)
-
-   Concatenate two paths together.  The ``join`` variants create a new path
-   object containing the concatenated results.  The ``append`` variants
-   overwrite the contents of *path* with the concatenated results.
-
-
-.. function:: struct cork_path \*cork_path_basename(const struct cork_path \*path)
-              void \*cork_path_set_basename(struct cork_path \*path)
-
-   Extract the base name of *path*.  This is the portion after the final
-   trailing slash.  The first variant constructs a new path object to hold the
-   result; the second variant overwritesthe contents of *path*.
-
-   .. note::
-
-      These functions return a different result than the standard
-      ``basename(3)`` function.  We consider a trailing slash to be significant,
-      whereas ``basename(3)`` does not::
-
-          basename("a/b/c/") == "c"
-          cork_path_basename("a/b/c/") == ""
-
-.. function:: struct cork_path \*cork_path_dirname(const struct cork_path \*path)
-              void \*cork_path_set_dirname(struct cork_path \*path)
-
-   Extract the directory name of *path*.  This is the portion before the final
-   trailing slash.  The first variant constructs a new path object to hold the
-   result; the second variant overwritesthe contents of *path*.
-
-   .. note::
-
-      These functions return a different result than the standard ``dirname(3)``
-      function.  We consider a trailing slash to be significant, whereas
-      ``dirname(3)`` does not::
-
-          dirname("a/b/c/") == "a/b"
-          cork_path_dirname("a/b/c/") == "a/b/c"
-
-
-Lists of paths
-==============
-
-.. type:: struct cork_path_list
-
-   A list of paths in the local filesystem.
-
-.. function:: struct cork_path_list \*cork_path_list_new_empty(void)
-              struct cork_path_list \*cork_path_list_new(const char \*list)
-
-   Create a new list of paths.  The first variant creates a list that is
-   initially empty.  The second variant takes in a colon-separated list of paths
-   as a single string, and adds each of those paths to the new list.
-
-.. function:: void cork_path_list_free(struct cork_path_list \*list)
-
-   Free a path list.
-
-.. function:: void cork_path_list_add(struct cork_path_list \*list, struct cork_path \*path)
-
-   Add *path* to *list*.  The list takes control of the path instance; you must
-   not try to free *path* yourself.
-
-.. function:: size_t cork_path_list_size(const struct cork_path_list \*list)
-
-   Return the number of paths in *list*.
-
-.. function:: const struct cork_path \*cork_path_list_get(const struct cork_path_list \*list, size_t index)
-
-   Return the path in *list* at the given *index*.  The list still owns the path
-   instance that's returned; you must not try to free it or modify its contents.
-
-.. function:: const char \*cork_path_list_to_string(const struct cork_path_list \*list)
-
-   Return a string containing all of the paths in *list* separated by colons.
-
-
-.. function:: struct cork_file \*cork_path_list_find_file(const struct cork_path_list \*list, const char \*rel_path)
-              struct cork_file_list \*cork_path_list_find_files(const struct cork_path_list \*list, const char \*rel_file)
-
-   Search for a file in a list of paths.  *rel_path* gives the path of the
-   sought-after file, relative to each of the directories in *list*.
-
-   The first variant returns a :c:type:`cork_file` instance for the first match.
-   In no file can be found, it returns ``NULL`` and sets an error condition.
-
-   The second variant returns a :c:type:`cork_file_list` instance containing all
-   of the matches.  In no file can be found, we return an empty list.  (Unlike
-   the first variant, this is not considered an error.)
-
-
-Standard paths
-==============
-
-.. function:: struct cork_path \*cork_path_home(void)
-
-   Return a :c:type:`cork_path` that refers to the current user's home
-   directory.  If we can't determine the current user's home directory, we set
-   an error condition and return ``NULL``.
-
-   On POSIX systems, this directory is determined by the ``HOME`` environment
-   variable.
-
-.. function:: struct cork_path_list \*cork_path_config_paths(void)
-
-   Return a :c:type:`cork_path_list` that includes all of the standard
-   directories that can be used to store configuration files.  This includes a
-   user-specific directory that allows the user to override any global
-   configuration files.
-
-   On POSIX systems, these directories are defined XDG Base Directory
-   Specification.
-
-.. function:: struct cork_path_list \*cork_path_data_paths(void)
-
-   Return a :c:type:`cork_path_list` that includes all of the standard
-   directories that can be used to store application data files.  This includes
-   a user-specific directory that allows the user to override any global data
-   files.
-
-   On POSIX systems, these directories are defined XDG Base Directory
-   Specification.
-
-.. function:: struct cork_path \*cork_path_user_cache_path(void)
-
-   Return a :c:type:`cork_path` that refers to a directory that can be used to
-   store cache files created on behalf of the current user.  This directory
-   should only be used to store data that you can reproduce if needed.
-
-   On POSIX systems, these directories are defined XDG Base Directory
-   Specification.
-
-.. function:: struct cork_path \*cork_path_user_runtime_path(void)
-
-   Return a :c:type:`cork_path` that refers to a directory that can be used to
-   store small runtime management files on behalf of the current user.
-
-   On POSIX systems, these directories are defined XDG Base Directory
-   Specification.
-
-
-Files
-=====
-
-.. type:: struct cork_file
-
-   Represents a file on the local filesystem.  The file in question does not
-   necessarily have to exist; you can use :c:type:`cork_file` instances to refer
-   to files that you have not yet created, for instance.
-
-.. type:: typedef unsigned int  cork_file_mode
-
-   Represents a Unix-style file permission set.
-
-
-.. function:: struct cork_file \*cork_file_new(const char \*path)
-              struct cork_file \*cork_file_new_from_path(struct cork_path \*path)
-
-   Create a new :c:type:`cork_file` instance to represent the file with the
-   given *path*.  The ``_from_path`` variant uses an existing
-   :c:type:`cork_path` instance to specify the path.  The new file instance will
-   take control of the :c:type`cork_path` instance, so you should not try to
-   free it yourself.
-
-.. function:: void cork_file_free(struct cork_file \*file)
-
-   Free a file instance.
-
-.. function:: const struct cork_path \*cork_file_path(struct cork_file \*file)
-
-   Return the path of a file.  The :c:type:`cork_path` instance belongs to the
-   file; you must not try to modify or free the path instance.
-
-.. function:: int cork_file_exists(struct cork_file \*file, bool \*exists)
-
-   Check whether a file exists in the filesystem, storing the result in
-   *exists*.  The function returns an error condition if we are unable to
-   determine whether the file exists --- for instance, because you do not have
-   permission to look into one of the containing directories.
-
-.. function:: int cork_file_type(struct cork_file \*file, enum cork_file_type \*type)
-
-   Return what kind of file the given :c:type:`cork_file` instance refers to.
-   The function returns an error condition if there is an error accessing the
-   file --- for instance, because you do not have permission to look into one of
-   the containing directories.
-
-   If the function succeeds, it will fill in *type* with one of the following
-   values:
-
-   .. type:: enum cork_file_type
-
-      .. member:: CORK_FILE_MISSING
-
-         *file* does not exist.
-
-      .. member:: CORK_FILE_REGULAR
-
-         *file* is a regular file.
-
-      .. member:: CORK_FILE_DIRECTORY
-
-         *file* is a directory.
-
-      .. member:: CORK_FILE_SYMLINK
-
-         *file* is a symbolic link.
-
-      .. member:: CORK_FILE_UNKNOWN
-
-         We can access *file*, but we do not know what type of file it is.
-
-
-.. function:: int cork_file_remove(struct cork_file \*file, unsigned int flags)
-
-   Remove *file* from the filesystem.  *flags* must be the bitwise OR (``|``) of
-   the following flags.  (Use ``0`` if you do not want any of the flags.)
-
-   .. macro:: CORK_FILE_PERMISSIVE
-
-      If this flag is given, then it is not considered an error if *file* does
-      not exist.  If the flag is not given, then the function function returns
-      an error if *file* doesn't exist.  (This mimics the standard ``rm -f``
-      command.)
-
-   .. macro:: CORK_FILE_RECURSIVE
-
-      If this flag is given, and *file* refers to a directory, then the function
-      will automatically remove the directory and all of its contents.  If the
-      flag is not given, and *file* refers to a directory, then the directory
-      must be empty for this function to succeed.  If *file* does not refer to a
-      directory, this flag has no effect.  (This mimics the standard ``rmdir
-      -r`` command.)
-
-
-Directories
-===========
-
-Certain functions can only be applied to a :c:type:`cork_file` instance that
-refers to a directory.
-
-
-.. function:: int cork_file_mkdir(struct cork_file \*directory, cork_file_mode mode, unsigned int flags)
-
-   Create a new directory in the filesystem, with permissions given by *mode*.
-   *flags* must be the bitwise OR (``|``) of the following flags.  (Use ``0`` if
-   you do not want any of the flags.)
-
-   .. macro:: CORK_FILE_PERMISSIVE
-
-      If this flag is given, then it is not considered an error if *directory*
-      already exists.  If the flag is not given, then the function function
-      returns an error if *directory* exists.  (This mimics part of the standard
-      ``mkdir -p`` command.)
-
-   .. macro:: CORK_FILE_RECURSIVE
-
-      If this flag is given, then the function will ensure that all of the
-      parent directories of *directory* exist, creating them if necessary.  Each
-      directory created will have permissions given by *mode*.  (This mimics
-      part of the standard ``mkdir -p`` command.)
-
-
-.. function:: int cork_file_iterate_directory(struct cork_file \*directory, cork_file_directory_iterator iterator, void \*user_data)
-
-   Call *iterator* for each file or subdirectory contained in *directory* (not
-   including the directory's ``.`` and ``..`` entries).  This function does not
-   recurse into any subdirectories; it only iterates through the immediate
-   children of *directory*.
-
-   If your iteration function returns a non-zero result, we will abort the
-   iteration and return that value.  Otherwise, if each call to the iteration
-   function returns ``0``, then we will return ``0`` as well.
-
-   *iterator* must be an instance of the following function type:
-
-   .. type:: typedef int (\*cork_file_directory_iterator)(struct cork_file \*child, const char \*rel_name, void \*user_data)
-
-      Called for each child entry in *directory*.  *child* will be a file
-      instance referring to the child entry.  *rel_name* gives the relative name
-      of the child entry within its parent *directory*.
-
-
-Lists of files
-==============
-
-.. type:: struct cork_file_list
-
-   A list of files in the local filesystem.
-
-.. function:: struct cork_file_list \*cork_file_list_new_empty(void)
-              struct cork_file_list \*cork_file_list_new(struct cork_path_list \*path_list)
-
-   Create a new list of files.  The first variant creates a list that is
-   initially empty.  The second variant adds a new file instance for each of the
-   paths in *path_list*.
-
-.. function:: void cork_file_list_free(struct cork_file_list \*list)
-
-   Free a file list.
-
-.. function:: void cork_file_list_add(struct cork_file_list \*list, struct cork_file \*file)
-
-   Add *file* to *list*.  The list takes control of the file instance; you must
-   not try to free *file* yourself.
-
-.. function:: size_t cork_file_list_size(const struct cork_file_list \*list)
-
-   Return the number of files in *list*.
-
-.. function:: struct cork_file \*cork_file_list_get(const struct cork_file_list \*list, size_t index)
-
-   Return the file in *list* at the given *index*.  The list still owns the file
-   instance that's returned; you must not try to free it.
-
-
-
-Directory walking
-=================
-
-.. function:: int cork_walk_directory(const char \*path, struct cork_dir_walker \*walker)
-
-   Walk through the contents of a directory.  *path* can be an absolute or
-   relative path.  If it's relative, it will be interpreted relative to the
-   current directory.  If *path* doesn't exist, or there are any problems
-   reading the contents of the directory, we'll set an error condition and
-   return ``-1``.
-
-   To process the contents of the directory, you must provide a *walker* object,
-   which contains several callback methods that we will call when files and
-   subdirectories of *path* are encountered.  Each method should return ``0`` on
-   success.  Unless otherwise noted, if we receive any other return result, we
-   will abort the directory walk, and return that same result from the
-   :c:func:`cork_walk_directory` call itself.
-
-   In all of the following methods, *base_name* will be the base name of the
-   entry within its immediate subdirectory.  *rel_path* will be the relative
-   path of the entry within the *path* that you originally asked to walk
-   through.  *full_path* will the full path to the entry, including *path*
-   itself.
-
-   .. type:: struct cork_dir_walker
-
-      .. member:: int (\*file)(struct cork_dir_walker \*walker, const char \*full_path, const char \*rel_path, const char \*base_name)
-
-         Called when a regular file is encountered.
-
-      .. member:: int (\*enter_directory)(struct cork_dir_walker \*walker, const char \*full_path, const char \*rel_path, const char \*base_name)
-
-         Called when a subdirectory of *path* of encountered.  If you don't want
-         to recurse into this directory, return :c:data:`CORK_SKIP_DIRECTORY`.
-
-         .. macro:: CORK_SKIP_DIRECTORY
-
-      .. member:: int (\*leave_directory)(struct cork_dir_walker \*walker, const char \*full_path, const char \*rel_path, const char \*base_name)
-
-         Called when a subdirectory has been fully processed.
diff --git a/docs/old/gc.rst b/docs/old/gc.rst
deleted file mode 100644
index a5bff64..0000000
--- a/docs/old/gc.rst
+++ /dev/null
@@ -1,422 +0,0 @@
-.. _gc:
-
-************************************
-Reference-counted garbage collection
-************************************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-The functions in this section implement a reference counting garbage
-collector.  The garbage collector handles reference cycles correctly.
-It is **not** a conservative garbage collector — i.e., we don't assume
-that every word inside an object might be a pointer.  Instead, each
-garbage-collected object must provide a *recursion function* that knows
-how to delve down into any child objects that it references.
-
-The garbage collector is **not** thread-safe.  If your application is
-multi-threaded, each thread will (automatically) have its own garbage
-collection context.  There are two strategies that you can use when
-using the garbage collector in a multi-threaded application:
-
-* Have a single “master” thread be responsible for the lifecycle of
-  every object.  This thread is the only one allowed to interact with
-  the garbage collector.  **No** other threads are allowed to call any
-  of the functions in this section, including the
-  :c:func:`cork_gc_incref()` and :c:func:`cork_gc_decref()` functions.
-  Other threads are allowed to access the objects that are managed by
-  the garbage collector, but the master thread must ensure that all
-  objects are live whenever another thread attempts to use them.  This
-  will require some kind of thread-safe communication or synchronization
-  between the master thread and the worker threads.
-
-* Have a separate garbage collector per thread.  Each object is “owned”
-  by a single thread, and the object is managed by that thread's garbage
-  collector.  As with the first strategy, other threads can use any
-  object, as long as the object's owner thread is able to guarantee that
-  the object will be live for as long as it's needed.  (Eventually we'll
-  also support migrating an object from one garbage collector to
-  another, but that feature isn't currently implemented.)
-
-The garbage collection implementation is based on the algorithm
-described in §3 of [1]_.
-
-.. [1] Bacon, DF and Rajan VT.  *Concurrent cycle collection in
-   reference counted systems*.  Proc. ECOOP 2001.  LNCS 2072.
-
-
-Creating a garbage collector
-============================
-
-.. function:: void cork_gc_init(void)
-
-   Initalizes a garbage collection context for the current thread.
-   Usually, you can allocate this on the stack of your ``main``
-   function::
-
-     int
-     main(int argc, char ** argv)
-     {
-         cork_gc_init();
-
-         // use the GC context
-
-         // and free it when you're done
-         cork_gc_done();
-     }
-
-   It's not required that you call this function at all; if you don't,
-   we'll automatically initialize a garbage collection context for the
-   current thread the first time you try to allocate a garbage-collected
-   object.  You can call this function, though, if you want to have more
-   control over when the initialization occurs.
-
-.. function:: void cork_gc_done(void)
-
-   Finalize the garbage collection context for the current thread.  All
-   objects created in this thread will be freed when this function
-   returns.
-
-   You must call this function in each thread that allocates
-   garbage-collected objects, just before that thread finishes.  (If
-   your application is single-threaded, then you must call this function
-   before the ``main`` function finishes.)  If you don't, you'll almost
-   certainly get memory leaks.
-
-
-Managing garbage-collected objects
-==================================
-
-A garbage collection context can't be used to manage arbitrary objects,
-since each garbage-collected class must define some callback functions
-for interacting with the garbage collector.  (The :ref:`next section
-<new-gc-class>` contains more details.)
-
-Each garbage-collected class will provide its own constructor function
-for instantiating a new instance of that class.  There aren't any
-explicit destructors for garbage-collected objects; instead you manage
-“references” to the objects.  Each pointer to a garbage-collected object
-is a reference, and each object maintains a count of the references to
-itself.  A newly constructed object starts with a reference count of
-``1``.  Whenever you save a pointer to a garbage-collected object, you
-should increase the object's reference count.  When you're done with the
-pointer, you decrease its reference count.  When the reference count
-drops to ``0``, the garbage collector frees the object.
-
-.. function:: void \*cork_gc_incref(void \*obj)
-
-   Increments the reference count of an object *obj* that is managed by
-   the current thread's garbage collector.  We always return *obj* as a
-   result, which allows you to use the following idiom::
-
-     struct my_obj * my_copy_of_obj = cork_gc_incref(obj);
-
-.. function:: void cork_gc_decref(void \*obj)
-
-   Decrements the reference count of an object *obj* that is managed by
-   the current thread's garbage collector  If the reference count drops
-   to ``0``, then the garbage collector will free the object.
-
-   .. note::
-
-      It's safe to call this function with a ``NULL`` *obj* pointer; in
-      this case, the function acts as a no-op.
-
-.. _borrow-ref:
-
-Borrowing a reference
----------------------
-
-While the strategy mentioned above implies that you should call
-:c:func:`cork_gc_incref()` and :c:func:`cork_gc_decref()` for *every*
-pointer to a garbage-collected object, you can sometimes get away
-without bumping the reference count.  In particular, you can often
-*borrow* an existing reference to an object, if you can guarantee that
-the borrowed reference will exist for as long as you need access to the
-object.  The most common example of this when you pass in a
-garbage-collected object as the parameter to a function::
-
-  int
-  use_new_reference(struct my_obj *obj)
-  {
-      /* Here we're being pedantically correct, and incrementing obj's
-       * reference count since we've got our own pointer to the object. */
-      cork_gc_incref(obj);
-
-      /* Do something useful with obj */
-
-      /* And now that we're done with it, decrement the reference count. */
-      cork_gc_decref(obj);
-  }
-
-  int
-  borrowed_reference(struct my_obj *obj)
-  {
-      /* We can assume that the caller has a valid reference to obj, so
-       * we're just going to borrow that reference. */
-
-      /* Do something useful with obj */
-  }
-
-In this example, ``borrowed_reference`` doesn't need to update *obj*\ 's
-reference count.  We assume that the caller has a valid reference to
-*obj* when it makes the call to ``borrowed_reference``.  Moreover, we
-know that the caller can't possibly release this reference (via
-:c:func:`cork_gc_decref()`) until ``borrowed_reference`` returns.  Since
-we can guarantee that the caller's reference to *obj* will exist for the
-entire duration of ``borrowed_reference``, we don't need to protect it
-with an ``incref``/``decref`` pair.
-
-.. _steal-ref:
-
-Stealing a reference
---------------------
-
-Another common pattern is for a “parent” object to maintain a reference
-to a “child” object.  (For example, a container class might maintain
-references to all of the elements in the container, assuming that the
-container and elements are all garbage-collected objects.)  When you
-have a network of objects like this, the parent object's constructor
-will usually take in a pointer to the child object as a parameter.  If
-we strictly follow the basic referencing counting rules described above,
-you'll end up with something like::
-
-  struct child  *child = child_new();
-  struct parent  *parent = parent_new(child);
-  cork_gc_decref(child);
-
-The ``child_new`` constructor gives us a reference to *child*.  The
-``parent_new`` constructor then creates a new reference to *child*,
-which will be stored somewhere in *parent*.  We no longer need our own
-reference to *child*, so we immediately decrement its reference count.
-
-This is a common enough occurrence that many constructor functions will
-instead *steal* the reference passed in as a parameter.  This means that
-the constructor takes control of the caller's reference.  This allows us
-to rewrite the example as::
-
-  struct parent  *parent = parent_new_stealing(child_new());
-
-For functions that steal a reference, the caller **cannot** assume that
-the object pointed to by the stolen reference exists when the function
-returns.  (If there's an error in ``parent_new_stealing``, for instance,
-it must release the stolen reference to *child* to prevent a memory
-leak.)  If a function is going to steal a reference, but you also need
-to use the object after the function call returns, then you need to
-explicitly increment the reference count *before* calling the function::
-
-  struct child  *child = child_new();
-  struct parent  *parent = parent_new_stealing(cork_gc_incref(child));
-  /* Do something with child. */
-  /* And then release our reference when we're done. */
-  cork_gc_decref(child);
-
-.. note::
-
-   It's important to point out that not every constructor will steal the
-   references passed in as parameters.  Moreover, there are some
-   constructors that steal references for some parameters but not for
-   others.  It entirely depends on what the “normal” use case is for the
-   constructor.  If you're almost always going to pass in a child object
-   that was just created, and that will always be accessed via the
-   parent, then the constructor will usually steal the reference.  If
-   the child can be referenced by many parents, then the constructor
-   will usually *not* steal the reference.  The documentation for each
-   constructor function will explicitly state which references are
-   stolen and which objects it creates new references for.
-
-
-.. _new-gc-class:
-
-Writing a new garbage-collected class
-=====================================
-
-When you are creating a new class that you want to be managed by a
-garbage collector, there are two basic steps you need to follow:
-
-* Implement a set of callback functions that allow the garbage collector
-  to interact with objects of the new class.
-
-* Use the garbage collector's allocation functions to allocate storage
-  for instance of your class.
-
-You won't need to write a public destructor function, since objects of
-the new class will be destroyed automatically when the garbage collector
-determines that they're no longer needed.
-
-Garbage collector callback interface
-------------------------------------
-
-Each garbage-collected class must provide an implementation of the
-“callback interface”:
-
-.. type:: struct cork_gc_obj_iface
-
-   .. member:: void (\*free)(void \*obj)
-
-      This callback is called when a garbage-collected object is about
-      to be freed.  You can perform any special cleanup steps in this
-      callback.  You do **not** need to deallocate the object's storage,
-      and you do **not** need to release any references that you old to
-      other objects.  Both of these steps will be taken care of for you
-      by the garbage collector.
-
-      If your class doesn't need any additional finalization steps, this
-      entry in the callback interface can be ``NULL``.
-
-   .. member:: void (\*recurse)(struct cork_gc \*gc, void \*obj, cork_gc_recurser recurse, void \*ud)
-
-      This callback is how you inform the garbage collector of your
-      references to other garbage-collected objects.
-
-      The garbage collector will call this function whenever it needs to
-      traverse through a graph of object references.  Your
-      implementation of this callback should just call *recurse* with
-      each garbage-collected object that you hold a reference to.  You
-      must pass in *gc* as the first parameter to each call to
-      *recurse*, and *ud* as the third parameter.
-
-      Note that it's fine to call *recurse* with a ``NULL`` object
-      pointer, which makes it slightly easier to write implementations
-      of this callback.
-
-      If instances of your class can never contain references to other
-      garbage-collected objects, this entry in the callback interface
-      can be ``NULL``.
-
-.. type:: void (\*cork_gc_recurser)(struct cork_gc \*gc, void \*obj, void \*ud)
-
-   An opaque callback provided by the garbage collector when it calls an
-   object's :c:member:`~cork_gc_obj_iface.recurse` method.
-
-.. type:: struct cork_gc
-
-   An opaque type representing the current thread's garbage-collection
-   context.  You'll only need to use this type when implementing a
-   :c:member:`~cork_gc_obj_iface.recurse` function.
-
-
-.. _gc-macros:
-
-Helper macros
-~~~~~~~~~~~~~
-
-There are several macros declared in :file:`libcork/helpers/gc.h` that
-make it easier to define the garbage-collection interface for a new
-class.
-
-.. note::
-
-   Unlike most libcork modules, these macros are **not** automatically
-   defined when you include the ``libcork/core.h`` header file, since
-   they don't include a ``cork_`` prefix.  Because of this, we don't
-   want to pollute your namespace unless you ask for the macros.  To do
-   so, you must explicitly include their header file::
-
-     #include <libcork/helpers/gc.h>
-
-.. macro:: _free_(SYMBOL name)
-           _recurse_(SYMBOL name)
-
-   These macros declare the *free* and *recurse* methods for a new
-   class.  The functions will be declared with exactly the signatures
-   and parameter names shown in the entries for the
-   :c:member:`~cork_gc_obj_iface.free` and
-   :c:member:`~cork_gc_obj_iface.recurse` methods.
-
-   You will almost certainly not need to refer to the method
-   implementations directly, since you can use the :c:macro:`_gc_*_
-   <_gc_>` macros below to declare the interface struct.  But if you do,
-   they'll be called :samp:`{[name]}__free` and
-   :samp:`{[name]}__recurse`.  (Note the double underscore.)
-
-.. macro:: _gc_(SYMBOL name)
-           _gc_no_free_(SYMBOL name)
-           _gc_no_recurse_(SYMBOL name)
-           _gc_leaf_(SYMBOL name)
-
-   Define the garbage-collection interface struct for a new class.  If
-   you defined both ``free`` and ``recurse`` methods, you should use the
-   ``_gc_`` variant.  If you only defined one of the methods, you should
-   use ``_gc_no_free_`` or ``_gc_no_recurse_``.  If you didn't define
-   either method, you should use ``_gc_free_``.
-
-   Like the method definitions, you probably won't need to refer to the
-   interface struct directly, since you can use the
-   :c:func:`cork_gc_new` macro to allocate new instances of the new
-   class.  But if you do, it will be called :samp:`{[name]}__gc`.  (Note
-   the double underscore.)
-
-
-As an example, we can use these macros to define a new tree class::
-
-    #include <libcork/helpers/gc.h>
-
-    struct tree {
-        const char  *name;
-        struct tree  *left;
-        struct tree  *right;
-    };
-
-    _free_(tree) {
-        struct tree  *self = obj;
-        cork_strfree(self->name);
-    }
-
-    _recurse_(tree) {
-        struct tree  *self = obj;
-        recurse(self->left, ud);
-        recurse(self->right, ud);
-    }
-
-    _gc_(tree);
-
-
-Allocating new garbage-collected objects
-----------------------------------------
-
-In your garbage-collected class's constructor, you must use one of the
-following functions to allocate the object's storage.  (The garbage
-collector hides some additional state in the object's memory region, so
-you can't allocate the storage using ``malloc`` or :c:func:`cork_new()`
-directly.)
-
-.. function:: void \*cork_gc_alloc(size_t instance_size, struct cork_gc_obj_iface \*iface)
-
-   Allocates a new garbage-collected object that is *instance_size*
-   bytes large.  *iface* should be a pointer to a callback interface for
-   the object.  If there are any problems allocating the new instance,
-   the program will abort.
-
-.. function:: type \*cork_gc_new_iface(TYPE type, struct cork_gc_obj_iface \*iface)
-
-   Allocates a new garbage-collected instance of *type*.  The size of
-   the memory region to allocate is calculated using the ``sizeof``
-   operator, and the result will be automatically cast to ``type *``.
-   *iface* should be a pointer to a callback interface for the object.
-   If there are any problems allocating the new instance, the program
-   will abort.
-
-.. function:: struct name \*cork_gc_new(SYMBOL name)
-
-   Allocates a new garbage-collected instance of :samp:`struct
-   {[name]}`.  (Note that you don't pass in the ``struct`` part of the
-   type name.) We assume that the garbage collection interface was
-   created using one of the :c:macro:`_gc_*_ <_gc_>` macros, using the
-   same *name* parameter.
-
-Using these functions, could instantiate our example tree class as
-follows::
-
-    struct tree *
-    tree_new(const char *name)
-    {
-        struct tree  *self = cork_gc_new(tree);
-        self->name = cork_strdup(name);
-        self->left = NULL;
-        self->right = NULL;
-        return self;
-    }
diff --git a/docs/old/hash-table.rst b/docs/old/hash-table.rst
deleted file mode 100644
index a0586f9..0000000
--- a/docs/old/hash-table.rst
+++ /dev/null
@@ -1,398 +0,0 @@
-.. _hash-table:
-
-***********
-Hash tables
-***********
-
-.. highlight:: c
-
-::
-
-  #include <libcork/ds.h>
-
-This section defines a hash table class.  Our hash table implementation
-is based on the public domain hash table package written in the late
-1980's by Peter Moore at UC Berkeley.
-
-The keys and values of a libcork hash table are both represented by ``void *``
-pointers.  You can also store integer keys or values, as long as you use the
-:c:type:`intptr_t` or :c:type:`uintptr_t` integral types.  (These are the only
-integer types guaranteed by the C99 standard to fit within the space used by a
-``void *``.)  The keys of the hash table can be any arbitrary type; you must
-provide two functions that control how key pointers are used to identify entries
-in the table: the *hasher* (:c:type:`cork_hash_f`) and the *comparator*
-(:c:type:`cork_equals_f`).  It's your responsibility to ensure that these two
-functions are consistent with each other — i.e., if two keys are equal according
-to your comparator, they must also map to the same hash value.  (The inverse
-doesn't need to be true; it's fine for two keys to have the same hash value but
-not be equal.)
-
-.. type:: struct cork_hash_table
-
-   A hash table.
-
-.. function:: struct cork_hash_table \*cork_hash_table_new(size_t initial_size, unsigned int flags)
-
-   Creates a new hash table instance.
-
-   If you know roughly how many entries you're going to add to the hash
-   table, you can pass this in as the *initial_size* parameter.  If you
-   don't know how many entries there will be, you can use ``0`` for this
-   parameter instead.
-
-   You will most likely need to provide a hashing function and a comparison
-   function for the new hash table (using :c:func:`cork_hash_table_set_hash` and
-   :c:func:`cork_hash_table_set_equals`), which will be used to compare key
-   values of the entries in the table.  If you do not provide your own
-   functions, the default functions will compare key pointers as-is without
-   interpreting what they point to.
-
-   The *flags* field is currently unused, and should be ``0``.  In the future,
-   this parameter will be used to let you customize the behavior of the hash
-   table.
-
-
-.. function:: void cork_hash_table_free(struct cork_hash_table \*table)
-
-   Frees a hash table.  If you have provided a :c:func:`free_key
-   <cork_hash_table_set_free_key>` or :c:func:`free_value
-   <cork_hash_table_set_free_value>` callback for *table*, then we'll
-   automatically free any remaining keys and/or values.
-
-
-.. type:: struct cork_hash_table_entry
-
-   The contents of an entry in a hash table.
-
-   .. member:: void  \*key
-
-      The key for this entry.  There won't be any other entries in the
-      hash table with the same key, as determined by the comparator
-      function that you provide.
-
-   .. member:: void  \*value
-
-      The value for this entry.  The entry's value is completely opaque
-      to the hash table; we'll never need to compare or interrogate the
-      values in the table.
-
-   .. member:: cork_hash  hash
-
-      The hash value for this entry's key.  This field is strictly
-      read-only.
-
-
-Callback functions
-------------------
-
-You can use the callback functions in this section to customize the behavior of
-a hash table.
-
-.. function:: void cork_hash_table_set_user_data(struct cork_hash_table \*table, void \*user_data, cork_free_f free_user_data)
-
-   Lets you provide an opaque *user_data* pointer to each of the hash table's
-   callbacks.  This lets you provide additional state, other than the hash table
-   itself to those callbacks.  If *free_user_data* is not ``NULL``, then the
-   hash table will take control of *user_data*, and will use the
-   *free_user_data* function to free it when the hash table is destroyed.
-
-
-Key management
-~~~~~~~~~~~~~~
-
-.. function:: void cork_hash_table_set_hash(struct cork_hash_table \*table, void \*user_data, cork_hash_f hash)
-
-   The hash table will use the ``hash`` callback to calculate a hash value for
-   each key.
-
-   .. type:: cork_hash (\*cork_hash_f)(void \*user_data, const void \*key)
-
-      .. note::
-
-         It's important to use a hash function that has a uniform distribution
-         of hash values for the set of values you expect to use as hash table
-         keys.  In particular, you *should not* rely on there being a prime
-         number of hash table bins to get the desired uniform distribution.  The
-         :ref:`hash value functions <hash-values>` that we provide have uniform
-         distribution (and are fast), and should be safe to use for most key
-         types.
-
-.. function:: void cork_hash_table_set_equals(struct cork_hash_table \*table, void \*user_data, cork_equals_f equals)
-
-   The hash table will use the ``equals`` callback to compare keys.
-
-   .. type:: bool (\*cork_equals_f)(void \*user_data, const void \*key1, const void \*key2)
-
-
-Built-in key types
-~~~~~~~~~~~~~~~~~~
-
-We also provide a couple of specialized constructors for common key types, which
-prevents you from having to duplicate common hashing and comparison functions.
-
-.. function:: struct cork_hash_table \*cork_string_hash_table_new(size_t initial_size, unsigned int flags)
-
-   Create a hash table whose keys will be C strings.
-
-.. function:: struct cork_hash_table \*cork_pointer_hash_table_new(size_t initial_size, unsigned int flags)
-
-   Create a hash table where keys should be compared using standard pointer
-   equality.  (In other words, keys should only be considered equal if they
-   point to the same physical object.)
-
-
-Automatically freeing entries
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-.. function:: void cork_hash_table_set_free_key(struct cork_hash_table \*table, void \*user_data, cork_free_f free_key)
-              void cork_hash_table_set_free_value(struct cork_hash_table \*table, void \*user_data, cork_free_f free_value)
-
-   If you provide ``free_key`` and/or ``free_value`` callbacks, then the hash
-   table will take ownership of any keys and values that you add.  The hash
-   table will use these callbacks to free each key and value when entries are
-   explicitly deleted (via :c:func:`cork_hash_table_delete` or
-   :c:func:`cork_hash_table_clear`), and when the hash table itself is
-   destroyed.
-
-
-Adding and retrieving entries
------------------------------
-
-There are several functions that can be used to add or retrieve entries
-from a hash table.  Each one has slightly different semantics; you
-should read through them all before deciding which one to use for a
-particular use case.
-
-.. note::
-
-   Each of these functions comes in two variants.  The “normal” variant will use
-   the hash table's :c:func:`hash <cork_hash_table_set_hash>` callback to
-   calculate the hash value for the *key* parameter.  This is the normal way to
-   interact with a hash table.
-
-   When using the ``_hash`` variant, you must calculate the hash value for each
-   key yourself, and pass in this hash value as an extra parameter.  The hash
-   table's :c:func:`hash <cork_hash_table_set_hash>` callback is not invoked.
-   This can be more efficient, if you've already calculated or cached the hash
-   value.  It is your responsibility to make sure that the hash values you
-   provide are consistent, just like when you write a :c:func:`hash
-   <cork_hash_table_set_hash>` callback.
-
-.. function:: void \*cork_hash_table_get(const struct cork_hash_table \*table, const void \*key)
-              void \*cork_hash_table_get_hash(const struct cork_hash_table \*table, cork_hash hash, const void \*key)
-
-   Retrieves the value in *table* with the given *key*.  We return
-   ``NULL`` if there's no corresponding entry in the table.  This means
-   that, using this function, you can't tell the difference between a
-   missing entry, and an entry that's explicitly mapped to ``NULL``.  If
-   you need to distinguish those cases, you should use
-   :c:func:`cork_hash_table_get_entry()` instead.
-
-.. function:: struct cork_hash_table_entry \*cork_hash_table_get_entry(const struct cork_hash_table \*table, const void \*key)
-              struct cork_hash_table_entry \*cork_hash_table_get_entry_hash(const struct cork_hash_table \*table, cork_hash hash, const void \*key)
-
-   Retrieves the entry in *table* with the given *key*.  We return
-   ``NULL`` if there's no corresponding entry in the table.
-
-   You are free to update the :c:member:`key
-   <cork_hash_table_entry.key>` and :c:member:`value
-   <cork_hash_table_entry.value>` fields of the entry.  However, you
-   must ensure that any new key is considered “equal” to the old key,
-   according to the hasher and comparator functions that you provided
-   for this hash table.
-
-.. function:: struct cork_hash_table_entry \*cork_hash_table_get_or_create(struct cork_hash_table \*table, void \*key, bool \*is_new)
-              struct cork_hash_table_entry \*cork_hash_table_get_or_create_hash(struct cork_hash_table \*table, cork_hash hash, void \*key, bool \*is_new)
-
-   Retrieves the entry in *table* with the given *key*.  If there is no
-   entry with the given key, it will be created.  (If we can't create
-   the new entry, we'll return ``NULL``.)  We'll fill in the *is_new*
-   output parameter to indicate whether the entry is new or not.
-
-   If a new entry is created, its value will initially be ``NULL``, but
-   you can update this as necessary.  You can also update the entry's
-   key, though you must ensure that any new key is considered “equal” to
-   the old key, according to the hasher and comparator functions that
-   you provided for this hash table.  This is necessary, for instance,
-   if the *key* parameter that we search for was allocated on the stack.
-   We can't save this stack key into the hash table, since it will
-   disapppear as soon as the calling function finishes.  Instead, you
-   must create a new key on the heap, which can be saved into the entry.
-   For efficiency, you'll only want to allocate this new heap-stored key
-   if the entry is actually new, especially if there will be a lot
-   successful lookups of existing keys.
-
-.. function:: int cork_hash_table_put(struct cork_hash_table \*table, void \*key, void \*value, bool \*is_new, void \*\*old_key, void \*\*old_value)
-              int cork_hash_table_put_hash(struct cork_hash_table \*table, cork_hash hash, void \*key, void \*value, bool \*is_new, void \*\*old_key, void \*\*old_value)
-
-   Add an entry to a hash table.  If there is already an entry with the
-   given key, we will overwrite its key and value with the *key* and
-   *value* parameters.  If the *is_new* parameter is non-\ ``NULL``,
-   we'll fill it in to indicate whether the entry is new or already
-   existed in the table.  If the *old_key* and/or *old_value* parameters
-   are non-\ ``NULL``, we'll fill them in with the existing key and
-   value.  This can be used, for instance, to finalize an overwritten
-   key or value object.
-
-.. function:: void cork_hash_table_delete_entry(struct cork_hash_table \*table, struct cork_hash_table_entry \*entry)
-
-   Removes *entry* from *table*.  You must ensure that *entry* refers to a
-   valid, existing entry in the hash table.  This function can be more efficient
-   than :c:func:`cork_hash_table_delete` if you've recently retrieved a hash
-   table entry using :c:func:`cork_hash_table_get_or_create` or
-   :c:func:`cork_hash_table_get_entry`, since we won't have to search for the
-   entry again.
-
-.. function:: bool cork_hash_table_delete(struct cork_hash_table \*table, const void \*key, void \*\*deleted_key, void \*\*deleted_value)
-              bool cork_hash_table_delete_hash(struct cork_hash_table \*table, cork_hash hash, const void \*key, void \*\*deleted_key, void \*\*deleted_value)
-
-   Removes the entry with the given *key* from *table*.  If there isn't
-   any entry with the given key, we'll return ``false``.  If the
-   *deleted_key* and/or *deleted_value* parameters are non-\ ``NULL``,
-   we'll fill them in with the deleted key and value.  This can be used,
-   for instance, to finalize the key or value object that was stored in
-   the hash table entry.
-
-   If you have provided a :c:func:`free_key <cork_hash_table_set_free_key>` or
-   :c:func:`free_value <cork_hash_table_set_free_value>` callback for *table*,
-   then we'll automatically free the key and/or value of the deleted entry.
-   (This happens before ``cork_hash_table_delete`` returns, so you must not
-   provide a *deleted_key* and/or *deleted_value* in this case.)
-
-
-Other operations
-----------------
-
-.. function:: size_t cork_hash_table_size(const struct cork_hash_table \*table)
-
-   Returns the number of entries in a hash table.
-
-.. function:: void cork_hash_table_clear(struct cork_hash_table \*table)
-
-   Removes all of the entries in a hash table, without finalizing the
-   hash table itself.
-
-   If you have provided a :c:func:`free_key <cork_hash_table_set_free_key>` or
-   :c:func:`free_value <cork_hash_table_set_free_value>` callback for *table*,
-   then we'll automatically free any remaining keys and/or values.
-
-.. function:: int cork_hash_table_ensure_size(struct cork_hash_table \*table, size_t desired_count)
-
-   Ensures that *table* has enough space to efficiently store a certain
-   number of entries.  This can be used to reduce (or eliminate) the
-   number of resizing operations needed to add a large number of entries
-   to the table, when you know in advance roughly how many entries there
-   will be.
-
-
-Iterating through a hash table
-------------------------------
-
-There are two strategies you can use to access all of the entries in a
-hash table: *mapping* and *iterating*.
-
-
-Iteration order
-~~~~~~~~~~~~~~~
-
-Regardless of whether you use the mapping or iteration functions, we guarantee
-that the collection of items will be processed in the same order that they were
-added to the hash table.
-
-
-Mapping
-~~~~~~~
-
-With mapping, you write a mapping function that will be applied to each entry in
-the table.  (In this case, libcork controls the loop that steps through each
-entry.)
-
-.. function:: void cork_hash_table_map(struct cork_hash_table \*table, void \*user_data, cork_hash_table_map_f map)
-
-   Applies the *map* function to each entry in a hash table.  The *map*
-   function's :c:type:`cork_hash_table_map_result` return value can be used to
-   influence the iteration.
-
-   .. type:: enum cork_hash_table_map_result (\*cork_hash_table_map_f)(void \*user_data, struct cork_hash_table_entry \*entry)
-
-      The function that will be applied to each entry in a hash table.  The
-      function's return value can be used to influence the iteration:
-
-      .. type:: enum cork_hash_table_map_result
-
-         .. var:: CORK_HASH_TABLE_CONTINUE
-
-            Continue the current :c:func:`cork_hash_table_map()` operation.  If
-            there are any remaining elements, the next one will be passed into
-            another call of the *map* function.
-
-         .. var:: CORK_HASH_TABLE_ABORT
-
-            Stop the current :c:func:`cork_hash_table_map()` operation.  No more
-            entries will be processed after this one, even if there are
-            remaining elements in the hash table.
-
-         .. var:: CORK_HASH_TABLE_DELETE
-
-            Continue the current :c:func:`cork_hash_table_map()` operation, but
-            first delete the entry that was just processed.  If there are any
-            remaining elements, the next one will be passed into another call of
-            the *map* function.
-
-For instance, you can manually calculate the number of entries in a hash
-table as follows (assuming you didn't want to use the built-in
-:c:func:`cork_hash_table_size()` function, of course)::
-
-  static enum cork_hash_table_map_result
-  count_entries(void *user_data, struct cork_hash_table_entry *entry)
-  {
-      size_t  *count = user_data;
-      (*count)++;
-      return CORK_HASH_TABLE_MAP_CONTINUE;
-  }
-
-  struct cork_hash_table  *table = /* from somewhere */;
-  size_t  count = 0;
-  cork_hash_table_map(table, &count, count_entries);
-  /* the number of entries is now in count */
-
-
-Iterating
-~~~~~~~~~
-
-The second strategy is to iterate through the entries yourself.  Since
-the internal struture of the :c:type:`cork_hash_table` type is opaque
-(and slightly more complex than a simple array), you have to use a
-special “iterator” type to manage the manual iteration.  Note that
-unlike when using a mapping function, it is **not** safe to delete
-entries in a hash table as you manually iterate through them.
-
-.. type:: struct cork_hash_table_iterator
-
-   A helper type for manually iterating through the entries in a hash
-   table.  All of the fields in this type are private.  You'll usually
-   allocate this type on the stack.
-
-.. function:: void cork_hash_table_iterator_init(struct cork_hash_table \*table, struct cork_hash_table_iterator \*iterator)
-
-   Initializes a new iterator for the given hash table.
-
-.. function:: struct cork_hash_table_entry \*cork_hash_table_iterator_next(struct cork_hash_table_iterator \*iterator)
-
-   Returns the next entry in *iterator*\ 's hash table.  If you've
-   already iterated through all of the entries in the table, we'll
-   return ``NULL``.
-
-With these functions, manually counting the hash table entries looks
-like::
-
-  struct cork_hash_table  *table = /* from somewhere */;
-  struct cork_hash_table_iterator  iter;
-  struct cork_hash_table_entry  *entry;
-  size_t  count = 0;
-
-  cork_hash_table_iterator_init(table, &iter);
-  while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {
-      count++;
-  }
-  /* the number of elements is now in count */
diff --git a/docs/old/hash-values.rst b/docs/old/hash-values.rst
deleted file mode 100644
index 00f37d9..0000000
--- a/docs/old/hash-values.rst
+++ /dev/null
@@ -1,111 +0,0 @@
-.. _hash-values:
-
-***********
-Hash values
-***********
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-
-The functions in this section can be used to produce fast, good hash
-values.
-
-.. note::
-
-   For the curious, libcork currently uses the public-domain
-   `MurmurHash3 <http://code.google.com/p/smhasher/>`_ as its hash
-   implementation.
-
-
-Hashing in C code
------------------
-
-A common pattern would be something along the lines of::
-
-  struct my_type {
-      int  a;
-      long  b;
-      double  c;
-      size_t  name_length;
-      const char  *name;
-  };
-
-  cork_hash
-  my_type_hash(const struct my_type *self)
-  {
-      /* hash of "struct my_type" */
-      cork_hash  hash = 0xd4a130d8;
-      hash = cork_hash_variable(hash, self->a);
-      hash = cork_hash_variable(hash, self->b);
-      hash = cork_hash_variable(hash, self->c);
-      hash = cork_hash_buffer(hash, self->name, self->name_length);
-      return hash;
-   }
-
-In this example, the seed value (``0xd4a130d8``) is the hash of the
-constant string ``"struct my_type"``.  You can produce seed values like
-this using the :ref:`cork-hash <cork-hash>` script described below::
-
-  $ cork-hash "struct my_type"
-  0xd4a130d8
-
-
-.. type:: uint32_t  cork_hash
-
-.. function:: cork_hash cork_hash_buffer(cork_hash seed, const void \*src, size_t len)
-              cork_hash cork_hash_variable(cork_hash seed, TYPE val)
-
-   Incorporate the contents of the given binary buffer or variable into a hash
-   value.  For the ``_variable`` variant, *val* must be an lvalue visible in the
-   current scope.
-
-   The hash values produces by these functions can change over time, and might
-   not be consistent across different platforms.  The only guarantee is that
-   hash values will be consistest for the duration of the current process.
-
-.. function:: cork_hash cork_stable_hash_buffer(cork_hash seed, const void \*src, size_t len)
-              cork_hash cork_stable_hash_variable(cork_hash seed, TYPE val)
-
-   Stable versions of :c:func:`cork_hash_buffer` and
-   :c:func:`cork_hash_variable`.  We guarantee that the hash values produced by
-   this function will be consistent across different platforms, and across
-   different versions of the libcork library.
-
-
-.. type:: cork_big_hash
-
-.. function:: cork_big_hash cork_big_hash_buffer(cork_big_hash seed, const void \*src, size_t len)
-
-   Incorporate the contents of the given binary buffer into a "big" hash value.
-   A big hash value has a much larger space of possible hash values (128 bits vs
-   32).
-
-
-.. function:: bool cork_big_hash_equal(cork_big_hash hash1, cork_big_hash hash2)
-
-   Compare two big hash values for equality.
-
-
-.. _cork-hash:
-
-Hashing from the command line
------------------------------
-
-Several parts of libcork use hash values as identifiers; you use a
-unique string to identify part of your code, and use the hash of that
-string as the actual identifier value.  We provide a command-line
-utility that you can use to produce these hash values:
-
-.. code-block:: none
-
-   cork-hash <string>
-
-.. describe:: <string>
-
-   The string to hash.  This should be provided as a single argument on
-   the command line, so if your string contains spaces or other shell
-   meta-characters, you must enclose the string in quotes.
diff --git a/docs/old/index.rst b/docs/old/index.rst
deleted file mode 100644
index 3fd786d..0000000
--- a/docs/old/index.rst
+++ /dev/null
@@ -1,59 +0,0 @@
-.. _index:
-
-|project_name| documentation
-============================
-
-This is the documentation for |project_name| |release|, last updated
-|today|.
-
-
-Introduction
-------------
-
-So what is libcork, exactly?  It's a “simple, easily embeddable, cross-platform
-C library”.  It falls roughly into the same category as glib_ or APR_ in the C
-world; the STL, POCO_, or QtCore_ in the C++ world; or the standard libraries
-of any decent dynamic language.
-
-So if libcork has all of these comparables, why a new library?  Well, none of
-the C++ options are really applicable here.  And none of the C options work,
-because one of the main goals is to have the library be highly modular, and
-useful in resource-constrained systems.  Once we describe some of the design
-decisions that we've made in libcork, you'll hopefully see how this fits into
-an interesting niche of its own.
-
-.. _glib: http://library.gnome.org/devel/glib/
-.. _APR: http://apr.apache.org/
-.. _POCO: http://pocoproject.org/
-.. _QtCore: http://qt.nokia.com/
-
-
-Contents
---------
-
-.. toctree::
-   :maxdepth: 2
-
-   config
-   versions
-   visibility
-   basic-types
-   byte-order
-   attributes
-   allocation
-   errors
-   gc
-   mempool
-   ds
-   cli
-   files
-   process
-   subprocess
-   threads
-
-
-Indices and tables
-------------------
-
-* :ref:`genindex`
-* :ref:`search`
diff --git a/docs/old/int128.rst b/docs/old/int128.rst
deleted file mode 100644
index 7247216..0000000
--- a/docs/old/int128.rst
+++ /dev/null
@@ -1,145 +0,0 @@
-.. _int128:
-
-****************
-128-bit integers
-****************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-We provide an API for working with unsigned, 128-bit integers.  Unlike libraries
-like GMP_, our goal is not to support arbitrarily large integers, but to provide
-optimized support for this one specific integer type.  We might add support for
-additional large integer types in the future, as need arises, but the focus will
-always be on a small number of specific types, and not on arbitrary sizes.  For
-that, use GMP.
-
-.. _GMP: http://gmplib.org/
-
-
-.. type:: cork_u128
-
-   An unsigned, 128-bit integer.  You can assume that instances of this type
-   will be exactly 16 bytes in size, and that the integer value will be stored
-   in host-endian order.  This type is currently implemented as a ``struct``,
-   but none of its members are part of the public API.
-
-
-Initialization
-==============
-
-.. function:: cork_u128 cork_u128_from_32(uint32_t i0, uint32_t i1, uint32_t i2, uint32_t i3)
-              cork_u128 cork_u128_from_64(uint64_t i0, uint64_t i1)
-
-   Return a 128-bit integer initialized with the given portions.  The various
-   *iX* pieces are given in big-endian order, regardless of the host's
-   endianness.  For instance, both of the following initialize an integer to
-   :math:`2^{64}`::
-
-       cork_u128  value1 = cork_u128_from_32(0, 1, 0, 0);
-       cork_u128  value2 = cork_u128_from_64(1, 0);
-
-
-Accessing subsets
-=================
-
-.. function:: &uint8_t cork_u128_be8(cork_u128 value, unsigned int index)
-              &uint16_t cork_u128_be16(cork_u128 value, unsigned int index)
-              &uint32_t cork_u128_be32(cork_u128 value, unsigned int index)
-              &uint64_t cork_u128_be64(cork_u128 value, unsigned int index)
-
-   Returns a reference to a portion of a 128-bit integer.  Regardless of the
-   host's endianness, the indices are counted in big-endian order — i.e., an
-   *index* of ``0`` will always return the most-significant portion of *value*.
-
-   The result is a valid lvalue, so you can assign to it to update the contents
-   of *value*::
-
-       cork_u128  value;
-       cork_u128_be64(value, 0) = 4;
-       cork_u128_be64(value, 1) = 16;
-
-
-Arithmetic
-==========
-
-All of the functions in this section are implemented as macros or inline
-functions, so you won't incur any function-call overhead when using them.
-
-.. function:: cork_u128 cork_u128_add(cork_128 a, cork_u128 b)
-              cork_u128 cork_u128_sub(cork_128 a, cork_u128 b)
-
-   Add or subtract two 128-bit integers, returning the result.
-
-   ::
-
-       cork_u128  a = cork_u128_from_32(0, 10);
-       cork_u128  b = cork_u128_from_32(0, 3);
-       cork_u128  c = cork_u128_add(a, b);
-       cork_u128  d = cork_u128_sub(a, b);
-       // c == 13 && d == 7
-
-
-Comparison
-==========
-
-All of the functions in this section are implemented as macros or inline
-functions, so you won't incur any function-call overhead when using them.
-
-.. function:: bool cork_u128_eq(cork_128 a, cork_u128 b)
-              bool cork_u128_ne(cork_128 a, cork_u128 b)
-              bool cork_u128_lt(cork_128 a, cork_u128 b)
-              bool cork_u128_le(cork_128 a, cork_u128 b)
-              bool cork_u128_gt(cork_128 a, cork_u128 b)
-              bool cork_u128_ge(cork_128 a, cork_u128 b)
-
-   Compare two 128-bit integers.  These functions correspond, respectively, to
-   the ``==``, ``!=``, ``<``, ``<=``, ``>``, and ``>=`` operators.
-
-   ::
-
-       cork_u128  a = cork_u128_from_32(0, 10);
-       cork_u128  b = cork_u128_from_32(0, 3);
-       // cork_u128_eq(a, b) → false
-       // cork_u128_ne(a, b) → true
-       // cork_u128_eq(a, a) → true
-       // cork_u128_gt(a, b) → true
-       // cork_u128_ge(a, a) → true
-       // and so on
-
-
-Printing
-========
-
-.. function:: const char \*cork_u128_to_decimal(char \*buf, cork_u128 value)
-              const char \*cork_u128_to_hex(char \*buf, cork_u128 value)
-              const char \*cork_u128_to_padded_hex(char \*buf, cork_u128 value)
-
-   Write the string representation of *value* into *buf*.  The ``decimal`` and
-   ``hex`` variants do not include any padding in the result.  The
-   ``padded_hex`` variant pads the result with ``0`` characters so that the
-   string representation of every :c:type:`cork_u128` has the same width.
-
-   You must provide the buffer that the string representation will be rendered
-   into.  (This ensures that these functions are thread-safe.)  The return value
-   will be some portion of this buffer, but might not be *buf* itself.
-
-   You are responsible for ensuring that *buf* is large enough to hold the
-   string representation of any valid 128-bit integer.  The
-   :c:macro:`CORK_U128_DECIMAL_LENGTH` and :c:macro:`CORK_U128_HEX_LENGTH`
-   macros can be helpful for this::
-
-     char  buf[CORK_U128_DECIMAL_LENGTH];
-     cork_u128  value = cork_u128_from_32(0, 125);
-     printf("%s\n", cork_u128_to_decimal(buf, value));
-     // prints "125\n"
-
-
-.. macro:: CORK_U128_DECIMAL_LENGTH
-           CORK_U128_HEX_LENGTH
-
-   The maximum length of the decimal or hexadecimal string representation of a
-   128-bit integer, including a ``NUL`` terminator.
diff --git a/docs/old/managed-buffer.rst b/docs/old/managed-buffer.rst
deleted file mode 100644
index 16ddf75..0000000
--- a/docs/old/managed-buffer.rst
+++ /dev/null
@@ -1,125 +0,0 @@
-.. _managed-buffer:
-
-**********************
-Managed binary buffers
-**********************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/ds.h>
-
-This section defines an interface for handling reference-counted binary
-buffers.  The :c:type:`cork_managed_buffer` type wraps a buffer with a
-simple reference count, and takes care of freeing the necessary
-resources when the reference count drops to zero.  There should only be
-a single :c:type:`cork_managed_buffer` instance for any given buffer,
-regardless of how many threads or functions access that buffer.  Each
-thread or function that uses the buffer does so via a
-:c:type:`cork_slice` instance.  This type is meant to be allocated
-directly on the stack (or in some other managed storage), and keeps a
-pointer to the managed buffer instance that it slices.  As its name
-implies, a slice can refer to a subset of the buffer.
-
-
-.. type:: struct cork_managed_buffer
-
-   A “managed buffer”, which wraps a buffer with a simple reference
-   count.
-
-   Managed buffer consumers should consider all of the fields of this
-   class private.  Managed buffer implementors should fill in this
-   fields when constructing a new ``cork_managed_buffer`` instance.
-
-   .. member:: const void  \*buf
-
-      The buffer that this instance manages.
-
-   .. member:: size_t  size
-
-      The size of :c:member:`buf`.
-
-   .. member:: volatile int  ref_count
-
-      A reference count for the buffer.  If this drops to ``0``, the
-      buffer will be finalized.
-
-   .. member:: struct cork_managed_buffer_iface  \*iface
-
-      The managed buffer implementation for this instance.
-
-
-.. function:: struct cork_managed_buffer \*cork_managed_buffer_ref(struct cork_managed_buffer \*buf)
-
-   Atomically increase the reference count of a managed buffer.  This
-   function is thread-safe.
-
-
-.. function:: void cork_managed_buffer_unref(struct cork_managed_buffer \*buf)
-
-   Atomically decrease the reference count of a managed buffer.  If the
-   reference count falls to ``0``, the instance is freed.  This function
-   is thread-safe.
-
-.. function:: int cork_managed_buffer_slice(struct cork_slice \*dest, struct cork_managed_buffer \*buffer, size_t offset, size_t length)
-              int cork_managed_buffer_slice_offset(struct cork_slice \*dest, struct cork_managed_buffer \*buffer, size_t offset)
-
-   Initialize a new slice that refers to a subset of a managed buffer.
-   The *offset* and *length* parameters identify the subset.  (For the
-   ``_slice_offset`` variant, the *length* is calculated automatically
-   to include all of the managed buffer content starting from *offset*.)
-   If these parameters don't refer to a valid portion of the buffer, we
-   return ``false``, and you must not try to deference the slice's
-   :c:member:`buf <cork_slice.buf>` pointer.  If the slice is valid, we
-   return ``true``.
-
-   Regardless of whether the new slice is valid, you **must** ensure
-   that you call :c:func:`cork_slice_finish()` when you are done with
-   the slice.
-
-
-Predefined managed buffer implementations
------------------------------------------
-
-.. function:: struct cork_managed_buffer \*cork_managed_buffer_new_copy(const void \*buf, size_t size)
-
-   Make a copy of *buf*, and allocate a new managed buffer to manage
-   this copy.  The copy will automatically be freed when the managed
-   buffer's reference count drops to ``0``.
-
-
-.. type:: void (\*cork_managed_buffer_freer)(void \*buf, size_t size)
-
-   A finalization function for a managed buffer created by
-   :c:func:`cork_managed_buffer_new()`.
-
-.. function:: struct cork_managed_buffer \*cork_managed_buffer_new(const void \*buf, size_t size, cork_managed_buffer_freer free)
-
-   Allocate a new managed buffer to manage an existing buffer (*buf*).
-   The existing buffer is *not* copied; the new managed buffer instance
-   takes control of it.  When the managed buffer's reference count drops
-   to ``0``, it will call *free* to finalize *buf*.
-
-   This is a helper function, and keeps you from having to write a
-   complete custom managed buffer implementation when you don't need to
-   store any additional state in the managed buffer object.
-
-   .. note::
-
-      The *free* function is *not* responsible for freeing the
-      ``cork_managed_buffer`` instance itself.
-
-
-Custom managed buffer implementations
--------------------------------------
-
-.. type:: struct cork_managed_buffer_iface
-
-   The interface of methods that managed buffer implementations must
-   provide.
-
-   .. member:: void (\*free)(struct cork_managed_buffer \*self)
-
-      Free the contents of a managed buffer, and the
-      ``cork_managed_buffer`` instance itself.
diff --git a/docs/old/mempool.rst b/docs/old/mempool.rst
deleted file mode 100644
index 85bf112..0000000
--- a/docs/old/mempool.rst
+++ /dev/null
@@ -1,197 +0,0 @@
-.. _mempool:
-
-************
-Memory pools
-************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-The functions in this section let you define *memory pools*, which allow
-you to reduce the overhead of allocating and freeing large numbers of
-small objects.  Instead of generating a ``malloc`` call for each
-individual object, the memory pool allocates a large *block* of memory,
-and then subdivides this block of memory into objects of the desired
-size.  The free objects in the memory pool are linked together in a
-singly-linked list, which means that allocation and deallocation is
-usually a (very small) constant-time operation.
-
-.. note::
-
-   Memory pools are *not* thread safe; if you have multiple threads
-   allocating objects of the same type, they'll need separate memory
-   threads.
-
-
-Basic interface
----------------
-
-.. type:: struct cork_mempool
-
-   A memory pool.  All of the objects created by the memory pool will be
-   the same size; this size is provided when you initialize the memory
-   pool.
-
-.. function:: struct cork_mempool \*cork_mempool_new_size(size_t element_size)
-              struct cork_mempool \*cork_mempool_new(TYPE type)
-
-   Allocate a new memory pool.  The size of the objects allocated by
-   the memory pool is given either as an explicit *element_size*, or by
-   giving the *type* of the objects.  The blocks allocated by the memory
-   pool will be of a default size (currently 4Kb).
-
-.. function:: struct cork_mempool \*cork_mempool_new_size_ex(size_t element_size, size_t block_size)
-              struct cork_mempool \*cork_mempool_new_ex(TYPE type, size_t block_size)
-
-   Allocate a new memory pool.  The size of the objects allocated by
-   the memory pool is given either as an explicit *element_size*, or by
-   giving the *type* of the objects.  The blocks allocated by the memory
-   pool will be *block_size* bytes large.
-
-.. function:: void cork_mempool_free(struct cork_mempool \*mp)
-
-   Free a memory pool.  You **must** have already freed all of the
-   objects allocated by the pool; if you haven't, then this function
-   will cause the current process to abort.
-
-.. function:: void \*cork_mempool_new_object(struct cork_mempool \*mp)
-
-   Allocate a new object from the memory pool.
-
-.. function:: void cork_mempool_free_object(struct cork_mempool \*mp, void \*ptr)
-
-   Free an object that was allocated from the memory pool.
-
-
-
-.. _mempool-lifecycle:
-
-Initializing and finalizing objects
------------------------------------
-
-When you free an object that was allocated via a memory pool, the memory
-for that object isn't actually freed immediately.  (That's kind of the
-reason that you're using a memory pool in the first place.)  This means
-that if your object contains any fields that are expensive to initialize
-and finalize, it can make sense to postpone the finalization of those
-fields until the memory for the object itself is actually freed.
-
-As an example, let's say you have the following type that you're going
-to allocate via a memory pool::
-
-    struct my_data {
-        struct cork_buffer  scratch_space;
-        int  age;
-    };
-
-Our first attempt at a constructor and destructor would then be::
-
-    static cork_mempool  *pool;
-    pool = cork_mempool_new(struct my_data);
-
-    struct my_data *
-    my_data_new(void)
-    {
-        struct my_data  *self = cork_mempool_new_object(pool);
-        if (self == NULL) {
-            return NULL;
-        }
-
-        cork_buffer_init(&self->scratch_space);
-        return self;
-    }
-
-    void
-    my_data_free(struct my_data *self)
-    {
-        cork_buffer_done(&self->scratch_space);
-        cork_mempool_free_object(pool, self);
-    }
-
-What's interesting about this example is that the ``scratch_space``
-field, being a :c:type:`cork_buffer`, allocates some space internally to
-hold whatever data we're building up in the buffer.  When we call
-:c:func:`cork_buffer_done` in our destructor, that memory is returned to
-the system.  Later on, when we allocate a new ``my_data``, the
-:c:func:`cork_mempool_new_object` call in our constructor might get this same
-physical instance back.  We'll then proceed to re-initialize the
-``scratch_space`` buffer, which will then reallocate its internal buffer
-space as we use the type.
-
-Since we're using a memory pool to reuse the memory for the ``my_data``
-instance, we might as well try to reuse the memory for the
-``scratch_space`` field, as well.  To do this, you provide initialization and
-finalization callbacks:
-
-.. function:: void cork_mempool_set_user_data(struct cork_mempool \*mp, void \*user_data, cork_free_f free_user_data)
-              void cork_mempool_set_init_object(struct cork_mempool \*mp, cork_init_f init_object)
-              void cork_mempool_set_done_object(struct cork_mempool \*mp, cork_done_f done_object)
-
-   Provide callback functions that will be used to initialize and finalize each
-   object created by the memory pool.
-
-So, instead of putting the initialization logic into our constructor, we
-put it into the ``init_object`` function.  Similarly, the finalization
-logic goes into ``done_object``, and not our destructor::
-
-    static void
-    my_data_init(void *user_data, void *vself)
-    {
-        struct my_data  *self = vself;
-        cork_buffer_init(&self->scratch_space);
-        return 0;
-    }
-
-    static void
-    my_data_done(void *user_data, void *vself)
-    {
-        struct my_data  *self = vself;
-        cork_buffer_done(&self->scratch_space);
-    }
-
-    static cork_mempool  *pool;
-    pool = cork_mempool_new(pool, struct my_data);
-    cork_mempool_set_init_object(pool, my_data_init);
-    cork_mempool_set_done_object(pool, my_data_done);
-
-    struct my_data *
-    my_data_new(void)
-    {
-        return cork_mempool_new_object(pool);
-    }
-
-    void
-    my_data_free(struct my_data *self)
-    {
-        cork_mempool_free_object(pool, self);
-    }
-
-In this implementation, the ``scratch_space`` buffer is initialized when
-the memory for an instance is first allocated, and it's not finalized
-until the memory for the instance is returned to the system.  (Which
-basically means "when the memory pool itself is freed".)
-
-A caveat with this approach is that we've no longer guaranteed that the
-``scratch_space`` buffer is empty when ``my_data_new`` returns — if
-we're reusing an existing object, then the contents of the "previous"
-object's buffer will still be there.  We can either make sure that
-consumers of ``my_data`` don't assume anything about the contents of
-``scratch_space``, or better yet, we can *reset* the fields in our
-constructor object::
-
-    struct my_data *
-    my_data_new(void)
-    {
-        struct my_data  *self = cork_mempool_new_object(pool);
-        cork_buffer_clear(&self->scratch_space);
-        return self;
-    }
-
-In this example, we can reset the buffer just by clearing it.  If
-resetting is more involved, it can sometimes be better to leave the
-instance in a "messy" state, and have your clients not make assumptions.
-But if you do this, make sure to be clear about it in your
-documentation.
diff --git a/docs/old/net-addresses.rst b/docs/old/net-addresses.rst
deleted file mode 100644
index bea320d..0000000
--- a/docs/old/net-addresses.rst
+++ /dev/null
@@ -1,134 +0,0 @@
-.. _net-addresses:
-
-*****************
-Network addresses
-*****************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-
-IP addresses
-------------
-
-libcork provides C types for storing IPv4 and IPv6 addresses, as well as
-a union type for storing a generic IP address, regardless of whether
-it's IPv4 or IPv6.  (This lets you distinguish between an IPv4 address
-and the equivalent ``::ffff:0:0/96`` IPv4-mapped IPv6 address.)
-
-.. type:: struct cork_ipv4
-          struct cork_ipv6
-
-   An IPv4 or IPv6 address.  The address is stored in memory exactly as
-   it would be if sent over a network connection — i.e., in
-   network-endian order, regardless of the endianness of the current
-   host.  The types are also guaranteed to be exactly the size of an
-   actual IPv4 or IPv6 address (without additional padding), so they can
-   be embedded directly into ``struct`` types that represent binary
-   disk/wire formats.
-
-   The contents of these types should be considered opaque.  You should
-   use the accessor functions defined below to interact with the IP
-   address.
-
-.. type:: struct cork_ip
-
-   A single union type that can contain either an IPv4 or IPv6 address.
-   This type contains a discriminator field, so you can't use it
-   directly in a binary disk/wire format type.
-
-   .. member:: unsigned int  version
-
-      Either ``4`` or ``6``, indicating whether the current IP address
-      is an IPv4 address or an IPv6 address.
-
-   .. member:: struct cork_ipv4  ip.v4
-               struct cork_ipv6  ip.v6
-
-      Gives you access to the underlying :c:type:`cork_ipv4` or
-      :c:type:`cork_ipv6` instance for the current address.  It's your
-      responsibility to check the :c:member:`cork_ip.version` field and
-      only access the union branch that corresponds to the current IP
-      version.
-
-
-.. function:: void cork_ipv4_copy(struct cork_ipv4 \*addr, const void \*src)
-              void cork_ipv6_copy(struct cork_ipv6 \*addr, const void \*src)
-              void cork_ip_from_ipv4(struct cork_ip \*addr, const void \*src)
-              void cork_ip_from_ipv6(struct cork_ip \*addr, const void \*src)
-
-   Initializes a :c:type:`cork_ipv4`, :c:type:`cork_ipv6`, or
-   :c:type:`cork_ip` instance from an existing IP address somewhere in
-   memory.  The existing address doesn't have to be an instance of the
-   :c:type:`cork_ipv4` or :c:type:`cork_ipv6` types, but it does have to
-   be a well-formed address.  (For IPv4, it must be 4 bytes long; for
-   IPv6, 16 bytes long.  And in both cases, the address must already be
-   in network-endian order, regardless of the host's endianness.)
-
-
-.. function:: int cork_ipv4_init(struct cork_ipv4 \*addr, const char \*str)
-              int cork_ipv6_init(struct cork_ipv6 \*addr, const char \*str)
-              int cork_ip_init(struct cork_ip \*addr, const char \*str)
-
-   Initializes a :c:type:`cork_ipv4`, :c:type:`cork_ipv6`, or
-   :c:type:`cork_ip` instance from the string representation of an IP
-   address.  *str* must point to a string containing a well-formed IP
-   address.  (Dotted-quad for an IPv4, and colon-hex for IPv6.)
-   Moreover, the version of the IP address in *str* must be compatible
-   with the function that you call: it can't be an IPv6 address if you
-   call ``cork_ipv4_init``, and it can't be an IPv4 address if you call
-   ``cork_ipv6_init``.
-
-   If *str* doesn't represent a valid address (of a compatible IP
-   version), then we leave *addr* unchanged, fill in the current error
-   condition with a :c:data:`CORK_NET_ADDRESS_PARSE_ERROR` error, and
-   return ``-1``.
-
-
-.. function:: bool cork_ipv4_equal(const struct cork_ipv4 \*addr1, const struct cork_ipv4 \*addr2)
-              bool cork_ipv6_equal(const struct cork_ipv6 \*addr1, const struct cork_ipv6 \*addr2)
-              bool cork_ip_equal(const struct cork_ip \*addr1, const struct cork_ip \*addr2)
-
-   Checks two IP addresses for equality.
-
-
-.. macro:: CORK_IPV4_STRING_LENGTH
-           CORK_IPV6_STRING_LENGTH
-           CORK_IP_STRING_LENGTH
-
-   The maximum length of the string representation of an IPv4, IPv6, or
-   generic IP address, including a ``NUL`` terminator.
-
-.. function:: void cork_ipv4_to_raw_string(const struct cork_ipv4 \*addr, char \*dest)
-              void cork_ipv6_to_raw_string(const struct cork_ipv6 \*addr, char \*dest)
-              void cork_ip_to_raw_string(const struct cork_ip \*addr, char \*dest)
-
-   Fills in *dest* with the string representation of an IPv4, IPv6, or
-   generic IP address.  You are responsible for ensuring that *dest* is
-   large enough to hold the string representation of any valid IP
-   address of the given version.  The
-   :c:macro:`CORK_IPV4_STRING_LENGTH`,
-   :c:macro:`CORK_IPV6_STRING_LENGTH`, and
-   :c:macro:`CORK_IP_STRING_LENGTH` macros can be helpful for this::
-
-     char  buf[CORK_IPV4_STRING_LENGTH];
-     struct cork_ipv4  addr;
-     cork_ipv4_to_raw_string(&addr, buf);
-
-
-.. function:: bool cork_ipv4_is_valid_network(const struct cork_ipv4 \*addr, unsigned int cidr_prefix)
-              bool cork_ipv6_is_valid_network(const struct cork_ipv6 \*addr, unsigned int cidr_prefix)
-              bool cork_ip_is_valid_network(const struct cork_ipv6 \*addr, unsigned int cidr_prefix)
-
-    Checks an IP address for alignment with a CIDR block prefix. For example,
-    10.1.2.4/24 is invalid, but 10.1.2.4/30 is valid.
-
-
-.. macro:: CORK_NET_ADDRESS_ERROR
-           CORK_NET_ADDRESS_PARSE_ERROR
-
-   The error class and codes used for the :ref:`error conditions
-   <errors>` described in this section.
diff --git a/docs/old/process.rst b/docs/old/process.rst
deleted file mode 100644
index 3bb13ec..0000000
--- a/docs/old/process.rst
+++ /dev/null
@@ -1,193 +0,0 @@
-.. _processes:
-
-*********
-Processes
-*********
-
-.. highlight:: c
-
-::
-
-  #include <libcork/os.h>
-
-The functions in this section let you interact with the current running process.
-
-
-Cleanup functions
-~~~~~~~~~~~~~~~~~
-
-Often you will need to perform some cleanup tasks whenever the current process
-terminates normally.  The functions in this section let you do that.
-
-.. function:: void cork_cleanup_at_exit(int priority, cork_cleanup_function function)
-              void cork_cleanup_at_exit_named(const char \*name, int priority, cork_cleanup_function function)
-
-   Register a *function* that should be called when the current process
-   terminates.  When multiple functions are registered, the order in which they
-   are called is determined by their *priority* values --- functions with lower
-   priorities will be called first.  If any functions have the same priority
-   value, there is no guarantee about the order in which they will be called.
-
-   All cleanup functions must conform to the following signature:
-
-   .. type:: void (\*cork_cleanup_function)(void)
-
-   The ``_named`` variant lets you provide an explicit name for the cleanup
-   function, which currently is only used when printing out debug messages.  The
-   plain variant automatically detects the name of *function*, so that you don't
-   have to provide it explicitly.
-
-
-.. _env:
-
-Environment variables
-~~~~~~~~~~~~~~~~~~~~~
-
-.. type:: struct cork_env
-
-   A collection of environment variables that can be passed to subprocesses.
-
-
-.. function:: struct cork_env \*cork_env_new(void)
-
-   Create a new, empty collection of environment variables.
-
-.. function:: struct cork_env \*cork_env_clone_current(void)
-
-   Create a new :c:type:`cork_env` containing all of the environment variables
-   in the current process's environment list.
-
-.. function:: void cork_env_free(struct cork_env \*env)
-
-   Free a collection of environment variables.
-
-
-.. function:: const char \*cork_env_get(struct cork_env \*env, const char \*name)
-
-   Return the value of the environment variable with the given *name*.  If there
-   is no variable with that name, return ``NULL``.
-
-   If *env* is ``NULL``, then the variable is retrieved from the current process
-   environment; otherwise, it is retrieved from *env*.
-
-.. function:: void cork_env_add(struct cork_env \*env, const char \*name, const char \*value)
-              void cork_env_add_printf(struct cork_env \*env, const char \*name, const char \*format, ...)
-              void cork_env_add_vprintf(struct cork_env \*env, const char \*name, const char \*format, va_list args)
-
-   Add a new environment variable with the given *name* and *value*.  If there
-   is already a variable with that name, it is overwritten.  We make a copy of
-   both *name* and *variable*, so it is safe to pass in temporary or reusable
-   strings for either.  The ``printf`` and ``vprintf`` variants construct the
-   new variable's value from a ``printf``-like format string.
-
-   If *env* is ``NULL``, then the new variable is added to the current process
-   environment; otherwise, it is added to *env*.
-
-.. function:: void cork_env_remove(struct cork_env \*env, const char \*name)
-
-   Remove the environment variable with the given *name*, if it exists.  If
-   there isn't any variable with that name, do nothing.
-
-   If *env* is ``NULL``, then the variable is removed from the current process
-   environment; otherwise, it is removed from *env*.
-
-
-.. function:: void cork_env_replace_current(struct cork_env \*env)
-
-   Replace the current process's environment list with the contents of *env*.
-
-
-.. _exec:
-
-Executing another program
-~~~~~~~~~~~~~~~~~~~~~~~~~
-
-.. type:: struct cork_exec
-
-   A specification for executing another program.
-
-
-.. function:: struct cork_exec \*cork_exec_new(const char \*program)
-              struct cork_exec \*cork_exec_new_with_params(const char \*program, ...)
-              struct cork_exec \*cork_exec_new_with_param_array(const char \*program, char \* const \*params)
-
-   Create a new specification for executing *program*.  *program* must either be
-   an absolute path to an executable on the local filesystem, or the name of an
-   executable that should be found in the current ``PATH``.
-
-   The first variant creates a specification that initially doesn't contain any
-   parameters to pass into the new program.  The second variant allows you to
-   pass in each argument as a separate parameter; you must ensure that you
-   terminate the list of parameters with a ``NULL`` pointer.  The third variant
-   allows you to pass in a ``NULL``-terminated array of strings to use as an
-   initial parameter list.  For all three variants, you can add additional
-   parameters before executing the new program via the :c:func:`cork_add_param`
-   function.
-
-   .. note::
-
-      Most programs will expect the first parameter to be the name of the
-      program being executed.  The :c:func:`cork_exec_new_with_params` function
-      will automatically fill in this first parameter for you.  The other
-      constructor functions do not; when using them, it is your responsibility
-      to provide this parameter, just like any other parameters to pass into the
-      program.
-
-   This function does not actually execute the program; that is handled by the
-   :c:func:`cork_exec_run` function.
-
-.. function:: void cork_exec_free(struct cork_exec \*exec)
-
-   Free an execution specification.  You normally won't need to call this
-   function; normally you'll replace the current process with the new program
-   (by calling :c:func:`cork_exec_run`), which means you won't have a chance to
-   free the specification object.
-
-.. function:: const char \*cork_exec_description(struct cork_exec \*exec)
-
-   Return a string description of the program described by an execution
-   specification.
-
-.. function:: void cork_exec_add_param(struct cork_exec \*exec, const char \*param)
-
-   Add a parameter to the parameter list that will be passed into the new
-   program.
-
-.. function:: void cork_exec_set_env(struct cork_exec \*exec, struct cork_env \*env)
-
-   Provide a set of environment variables that will be passed into the new
-   program.  The subprocess's environment will contain only those variables
-   defined in *env*.  You can use the :c:func:`cork_env_clone_current` function
-   to create a copy of the current process's environment, to use it as a base to
-   add new variables or remove unsafe variables.  We will take control of *env*,
-   so you must **not** call :c:func:`cork_env_free` to free the environment
-   yourself.
-
-   If you don't call this function for a specification object, the new
-   program will use the same environment as the calling process.
-
-.. function:: void cork_exec_set_cwd(struct cork_exec \*exec, const char \directory)
-
-   Change the working directory that the new program will be called from.  If
-   you don't call this function for a specification object, the new program will
-   be executed in the same working directory as the calling process.
-
-
-.. function:: const char \*cork_exec_program(struct cork_exec \*exec)
-              size_t \*cork_exec_param_count(struct cork_exec \*exec)
-              const char \*cork_exec_param(struct cork_exec \*exec, size_t index)
-              struct cork_env \*cork_exec_env(struct cork_exec \*exec)
-              const char \*cork_exec_cwd(struct cork_exec \*exec)
-
-   Accessor functions that allow you to retrieve the contents of an execution
-   specification.  The :c:func:`cork_exec_env` and :c:func:`cork_exec_cwd`
-   functions might return ``NULL``, if there isn't an environment or working
-   directory specified.
-
-
-.. function:: int cork_exec_run(struct cork_exec \*exec)
-
-   Execute the program specified by *exec*, replacing the current process.
-   If we can successfully start the new program, this function will not return.
-   If there are any errors starting the program, this function will return an
-   error condition.
diff --git a/docs/old/ring-buffer.rst b/docs/old/ring-buffer.rst
deleted file mode 100644
index 40db587..0000000
--- a/docs/old/ring-buffer.rst
+++ /dev/null
@@ -1,73 +0,0 @@
-.. _ring-buffer:
-
-************
-Ring buffers
-************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/ds.h>
-
-
-.. type:: struct cork_ring_buffer
-
-   A ring buffer data structure that can be easily embedded into other
-   types.  All of the fields in ``cork_ring_buffer`` are private; you
-   should only access the contents of the ring buffer via the functions
-   defined below.
-
-   The elements of a ring buffer are ``void *`` pointers.  (You can also
-   store integers via the :c:type:`intptr_t` and :c:type:`uintptr_t`
-   types.)  Ring buffers have a fixed capacity, which must be specified
-   when the ring buffer instance is initialized.  You cannot add extra
-   space to an existing ring buffer.
-
-   Ring buffers implement a FIFO queue structure; elements will be
-   returned by :c:func:`cork_ring_buffer_pop()` in the same order that
-   they're added by :c:func:`cork_ring_buffer_add()`.
-
-
-.. function:: int cork_ring_buffer_init(struct cork_ring_buffer \*buf, size_t size)
-              struct cork_ring_buffer \*cork_ring_buffer_new(size_t size)
-
-   Initializes a ring buffer instance, having a capacity of *size* elements.
-   The ``_init`` version should be used to initialize an instance you
-   allocated yourself on the stack.  The ``_new`` version will allocate an
-   instance from the heap.  If memory allocation fails in either function,
-   the program will abort with an error.
-
-
-.. function:: void cork_ring_buffer_done(struct cork_ring_buffer \*buf)
-              void cork_ring_buffer_free(struct cork_ring_buffer \*buf)
-
-   Finalizes a ring buffer instance.  The ``_done`` variant should be used to
-   finalize an instance that you allocated yourself (i.e., on the stack).  The
-   ``_free`` version should be used on instance allocated on the heap by using
-   :c:func:`cork_hash_table_new()`.  Nothing special is done to any
-   remaining elements in the ring buffer; if they need to be finalized,
-   you should do that yourself before calling this function.
-
-
-.. function:: bool cork_ring_buffer_is_empty(struct cork_ring_buffer \*buf)
-              bool cork_ring_buffer_is_full(struct cork_ring_buffer \*buf)
-
-   Returns whether the ring buffer is empty or full.  (You cannot add
-   elements to a full ring buffer, and you cannot pop elemenst from an
-   empty one.)
-
-
-.. function:: int cork_ring_buffer_add(struct cork_ring_buffer \*buf, void \*element)
-
-   Adds *element* to a ring buffer.  If the ring buffer is full, we
-   return ``-1``, and the ring buffer will be unchanged.  Otherwise we
-   return ``0``.
-
-.. function:: void \*cork_ring_buffer_pop(struct cork_ring_buffer \*buf)
-              void \*cork_ring_buffer_peek(struct cork_ring_buffer \*buf)
-
-   Returns the next element in the ring buffer.  If the ring buffer is
-   empty, we return ``NULL``.  The ``_pop`` variant will remove the
-   returned element from the ring buffer before returning it; the
-   ``_peek`` variant will leave the element in the ring buffer.
diff --git a/docs/old/slice.rst b/docs/old/slice.rst
deleted file mode 100644
index 2d46a5b..0000000
--- a/docs/old/slice.rst
+++ /dev/null
@@ -1,254 +0,0 @@
-.. _slice:
-
-*************
-Binary slices
-*************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/ds.h>
-
-This section defines an interface for safely referring to the contents
-of a binary buffer, without needing to know where the buffer came from.
-In addition to accessing the contents of the underlying buffer, slices
-support three operations:
-
-* *Copying* initializes a new slice object to point at the same
-  underlying buffer as the current slice.  Depending on how the
-  underlying buffer is implemented, this doesn't necessarily involve
-  actual copying; for instance, the :c:type:`cork_managed_buffer` type
-  implements this operation by incrementing the reference count of the
-  managed buffer.
-
-* *Slicing* updates the current slice to point at a subset of its
-  current contents.  This doesn't affect the underlying buffer.
-
-* *Freeing* releases the resources used by the slice, possibly freeing
-  the underlying buffer.
-
-These operations are represented by the *slice interface*
-(:c:type:`cork_slice_iface`).  To write a new slice implementation, you
-just need to provide an instance of this interface type.
-
-
-.. note::
-
-   There's no generic constructor or initialization function for slices;
-   instead, you'll create a slice from some other data structure, using
-   a function specific to that data structure.  (An example is the
-   :c:func:`cork_buffer_to_slice()` function, which initializes a slice
-   from a :ref:`resizable buffer <buffer>`.)
-
-
-.. type:: struct cork_slice
-
-   A specific window into a portion of an underlying binary buffer.
-
-   Instances of this class do not need to be (and almost never are)
-   allocated on the heap; you can define an instance directly on the
-   stack, or in some other kind of managed storage.
-
-   .. note::
-
-      It is **very important** that you ensure that
-      :c:func:`cork_slice_finish()` is called whenever you are done with
-      a slice — if you don't, there's a very good chance that the
-      underlying buffer will never be freed.  Yes, yes, it's unfortunate
-      that C doesn't have ``try``/``finally`` or RAII, but suck it up
-      and make sure that :c:func:`cork_slice_finish()` gets called.
-
-   .. member:: const void  \*buf
-
-      The beginning of the sliced portion of the underlying buffer.
-
-   .. member:: size_t  size
-
-      The size of the sliced portion of the underlying buffer.
-
-   .. member:: struct cork_slice_iface  \*iface
-
-      The slice implementation of the underlying buffer.  For slice
-      consumers, this field should be considered private.  For slice
-      implementors, you should fill in this field with your slice
-      interface.
-
-   .. member:: void  \*user_data
-
-      An opaque pointer used by the slice implementation.  For slice
-      consumers, this field should be considered private.  For slice
-      implementors, you can use this field to point at the underlying
-      buffer (and/or any additional metadata that you need.)
-
-
-.. function:: void cork_slice_clear(struct cork_slice \*slice)
-
-   Clear a slice object.  This fills in a slice instance so that it's
-   “empty”.  You should not try to call any of the slice methods on an
-   empty slice, nor should you try to dereference the slice's
-   :c:member:`buf <cork_slice.buf>` pointer.  An empty slice is
-   equivalent to a ``NULL`` pointer.
-
-.. function:: bool cork_slice_is_empty(struct cork_slice \*slice)
-
-   Return whether a slice is empty.
-
-
-.. function:: int cork_slice_copy(struct cork_slice \*dest, struct cork_slice \*src, size_t offset, size_t length)
-              int cork_slice_copy_offset(struct cork_slice \*dest, struct cork_slice \*src, size_t offset)
-              int cork_slice_copy_fast(struct cork_slice \*dest, struct cork_slice \*src, size_t offset, size_t length)
-              int cork_slice_copy_offset_fast(struct cork_slice \*dest, struct cork_slice \*src, size_t offset)
-
-   Initialize a new slice that refers to a subset of an existing slice.
-   The *offset* and *length* parameters identify the subset.  (For the
-   ``_copy_offset`` variant, the *length* is calculated automatically to
-   include all of the original slice content starting from *offset*.)
-
-   For the ``_fast`` variants, we **don't** verify that the *offset* and
-   *length* parameters refer to a valid subset of the slice.  This is
-   your responsibility.  For the non-\ ``_fast`` variants, we perform a
-   bounds check for you, and return an error if the requested slice is
-   invalid.
-
-   Regardless of whether the new slice is valid, you **must** ensure
-   that you call :c:func:`cork_slice_finish()` on *dest* when you are
-   done with it.
-
-.. function:: int cork_slice_light_copy(struct cork_slice \*dest, const struct cork_slice \*src, size_t offset, size_t length)
-              int cork_slice_light_copy_offset(struct cork_slice \*dest, const struct cork_slice \*src, size_t offset)
-              int cork_slice_light_copy_fast(struct cork_slice \*dest, const struct cork_slice \*src, size_t offset, size_t length)
-              int cork_slice_light_copy_offset_fast(struct cork_slice \*dest, const struct cork_slice \*src, size_t offset)
-
-   Initialize a new slice that refers to a subset of an existing slice.  By
-   calling a ``_light_copy`` function instead of a ``_copy`` function, you are
-   guaranteeing that *dest* will not outlive *src* — i.e., it is your
-   responsibility to ensure that you call :c:func:`cork_slice_finish` on *dest*
-   before you call it on *src*.  This guarantee lets slice implementations make
-   a more light-weight copy of the slice: for instance, by not having to make a
-   copy of the underlying buffer.
-
-   The *offset* and *length* parameters identify the subset.  (For the
-   ``_light_copy_offset`` variant, the *length* is calculated automatically to
-   include all of the original slice content starting from *offset*.)
-
-   For the ``_fast`` variants, we **don't** verify that the *offset* and
-   *length* parameters refer to a valid subset of the slice.  This is
-   your responsibility.  For the non-\ ``_fast`` variants, we perform a
-   bounds check for you, and return an error if the requested slice is
-   invalid.
-
-   Regardless of whether the new slice is valid, you **must** ensure
-   that you call :c:func:`cork_slice_finish()` on *dest* when you are
-   done with it.
-
-.. function:: int cork_slice_slice(struct cork_slice \*slice, size_t offset, size_t length)
-              int cork_slice_slice_offset(struct cork_slice \*slice, size_t offset)
-              int cork_slice_slice_fast(struct cork_slice \*slice, size_t offset, size_t length)
-              int cork_slice_slice_offset_fast(struct cork_slice \*slice, size_t offset)
-
-   Update a slice to refer to a subset of its contents.  The *offset*
-   and *length* parameters identify the subset.  (For the
-   ``_slice_offset`` variant, the *length* is calculated automatically
-   to include all of the original slice content starting from *offset*.)
-
-   For the ``_fast`` variants, we **don't** verify that the *offset* and
-   *length* parameters refer to a valid subset of the slice.  This is
-   your responsibility.  For the non-\ ``_fast`` variants, we perform a
-   bounds check for you, and return an error if the requested slice is
-   invalid.
-
-.. function:: void cork_slice_finish(struct cork_slice \*slice)
-
-   Finalize a slice, freeing the underlying buffer if necessary.
-
-.. function:: int cork_slice_equal(const struct cork_slice \*slice1, const struct cork_slice \*slice2)
-
-   Compare the contents of two slices for equality.  (The *contents* of
-   the slices are compared, not their pointers; this is the slice
-   equivalent of ``memcmp``, not the ``==`` operator.)
-
-
-Slice interface
----------------
-
-.. type:: struct cork_slice_iface
-
-   The interface of methods that slice implementations must provide.
-
-   .. member:: void (\*free)(struct cork_slice \*self)
-
-      Called when the slice should be freed.  If necessary, you should
-      free the contents of the underlying buffer.  (If the buffer
-      contents can be shared, it's up to you to keep track of when the
-      contents are safe to be freed.)
-
-      This function pointer can be ``NULL`` if you don't need to free
-      any underlying buffer.
-
-   .. member:: int (\*copy)(struct cork_slice \*dest, const struct cork_slice \*src, size_t offset, size_t length)
-               int (\*light_copy)(struct cork_slice \*dest, const struct cork_slice \*src, size_t offset, size_t length)
-
-      Create a copy of a slice.  You can assume that *offset* and
-      *length* refer to a valid subset of *src*\ 's content.
-
-      For the ``light_copy`` method, the caller guarantees that the new light
-      copy (*dest*) will not outlive the original slice (*src*).  For some slice
-      implementations, this lets you create a more light-weight copy — for
-      instance, by not having to make an actualy copy of the underlying buffer.
-
-   .. member:: int (\*slice)(struct cork_slice \*self, size_t offset, size_t length)
-
-      Update *self* to point at a different subset of the underlying
-      buffer.  You can assume that *offset* and *length* refer to a
-      valid subset of the buffer.  (They will be relative to *self*\ 's
-      existing slice, and not to the original buffer.)
-
-      This function pointer can be ``NULL`` if you don't need to do
-      anything special to the underlying buffer; in this case,
-      :c:func:`cork_slice_slice()` and
-      :c:func:`cork_slice_slice_offset()` will update the slice's *buf*
-      and *size* fields for you.
-
-
-Built-in slice implementations
-------------------------------
-
-Several libcork classes can be used to initialize a slice:
-
-* :ref:`Managed buffers <managed-buffer>` via the
-  :c:func:`cork_managed_buffer_slice` function
-
-* :ref:`Resizable buffers <buffer>` via the
-  :c:func:`cork_buffer_to_slice` function
-
-You can also initialize a slice to point at an existing buffer:
-
-
-.. function:: void cork_slice_init_static(struct cork_slice \*dest, const void \*buf, size_t size)
-
-   Initializes *dest* to point at the given static buffer.  Since the
-   buffer is static, and guaranteed to always exist, the slice's
-   :c:member:`~cork_slice.copy` method doesn't copy the underlying data,
-   it just creates a new pointer to the existing buffer.
-
-   .. note::
-
-      You can also use this function to refer to a non-static buffer,
-      but then you take responsibility for ensuring that the underlying
-      buffer exists for at least as long as the slice, and any copies
-      made of the slice.
-
-   As with all slices, you **must** ensure that you call
-   :c:func:`cork_slice_finish` when you're done with the slice.
-
-
-.. function:: void cork_slice_init_copy_once(struct cork_slice \*dest, const void \*buf, size_t size)
-
-   Initializes *dest* to point at the given buffer.  If any copies are made of
-   the slice, then we create a :ref:`managed copy <managed-buffer>` of the
-   underlying buffer.  This means that you only have to ensure that *buf* exists
-   for as long as the original *dest* slice is used.
-
-   As with all slices, you **must** ensure that you call
-   :c:func:`cork_slice_finish` when you're done with the slice.
diff --git a/docs/old/stream.rst b/docs/old/stream.rst
deleted file mode 100644
index 145783c..0000000
--- a/docs/old/stream.rst
+++ /dev/null
@@ -1,228 +0,0 @@
-.. _stream:
-
-*****************
-Stream processing
-*****************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/ds.h>
-
-
-Stream producers
-----------------
-
-A *producer* of binary data should take in a pointer to a
-:c:type:`cork_stream_consumer` instance.  Any data that is produced by the
-stream is then sent into the consumer instance for processing.  Once the stream
-has been exhausted (for instance, by reaching the end of a file), you signal
-this to the consumer.  During both of these steps, the consumer is able to
-signal error conditions; for instance, a stream consumer that parses a
-particular file format might return an error condition if the stream of data is
-malformed.  If possible, the stream producer can try to recover from the error
-condition, but more often, the stream producer will simply pass the error back
-up to its caller.
-
-.. function:: int cork_stream_consumer_data(struct cork_stream_consumer \*consumer, const void \*buf, size_t size, bool is_first_chunk)
-
-   Send the next chunk of data into a stream consumer.  You only have to ensure
-   that *buf* is valid for the duration of this function call; the stream
-   consumer is responsible for saving a copy of the data if it needs to be
-   processed later.  In particular, this means that it's perfectly safe for
-   *buf* to refer to a stack-allocated memory region.
-
-.. function:: int cork_stream_consumer_eof(struct cork_stream_consumer \*consumer)
-
-   Notify the stream consumer that the end of the stream has been reached.  The
-   stream consumer might perform some final validation and error detection at
-   this point.
-
-.. function:: void cork_stream_consumer_free(struct cork_stream_consumer \*consumer)
-
-   Finalize and deallocate a stream consumer.
-
-
-Built-in stream producers
-~~~~~~~~~~~~~~~~~~~~~~~~~
-
-We provide several built-in stream producers:
-
-.. function:: int cork_consume_fd(struct cork_stream_consumer \*consumer, int fd)
-              int cork_consume_file(struct cork_stream_consumer \*consumer, FILE \*fp)
-              int cork_consume_file_from_path(struct cork_stream_consumer \*consumer, const char \*path, int flags)
-
-   Read in a file, passing its contents into the given stream consumer.  The
-   ``_fd`` and ``_file`` variants consume a file that you've already opened; you
-   are responsible for closing the file after its been consumed.  The
-   ``_file_from_path`` variant will open the file for you, using the standard
-   ``open(2)`` function with the given *flags*.  This variant will close the
-   file before returning, regardless of whether the file was successfully
-   consumed or not.
-
-
-File stream producer example
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-As an example, we could implement the :c:func:`cork_consume_file` stream
-producer as follows::
-
-  #include <stdio.h>
-  #include <libcork/core.h>
-  #include <libcork/helpers/errors.h>
-  #include <libcork/ds.h>
-
-  #define BUFFER_SIZE  65536
-
-  int
-  cork_consume_file(struct cork_stream_consumer *consumer, FILE *fp)
-  {
-      char  buf[BUFFER_SIZE];
-      size_t  bytes_read;
-      bool  first = true;
-
-      while ((bytes_read = fread(buf, 1, BUFFER_SIZE, fp)) > 0) {
-          rii_check(cork_stream_consumer_data(consumer, buf, bytes_read, first));
-          first = false;
-      }
-
-      if (feof(fp)) {
-          return cork_stream_consumer_eof(consumer);
-      } else {
-          cork_system_error_set();
-          return -1;
-      }
-  }
-
-Note that this stream producer does not take care of opening or closing
-the ``FILE`` object, nor does it take care of freeing the consumer.  (Our actual
-implementation of :c:func:`cork_consume_file` also correctly handles ``EINTR``
-errors, and so is a bit more complex.  But this example still works as an
-illustration of how to pass data into a stream consumer.)
-
-
-.. _stream-consumers:
-
-Stream consumers
-----------------
-
-To consume data from a stream, you must create a type that implements the
-:c:type:`cork_stream_consumer` interface.
-
-.. type:: struct cork_stream_consumer
-
-   An interface for consumer a stream of binary data.  The producer of
-   the stream will call the :c:func:`cork_stream_consumer_data()`
-   function repeatedly, once for each successive chunk of data in the
-   stream.  Once the stream has been exhausted, the producer will call
-   :c:func:`cork_stream_consumer_eof()` to signal the end of the stream.
-
-   .. member:: int (\*data)(struct cork_stream_consumer \*consumer, const void \*buf, size_t size, bool is_first_chunk)
-
-      Process the next chunk of data in the stream.  *buf* is only
-      guaranteed to be valid for the duration of this function call.  If
-      you need to access the contents of the slice later, you must save
-      it somewhere yourself.
-
-      If there is an error processing this chunk of data, you should
-      return ``-1`` and fill in the current error condition using
-      :c:func:`cork_error_set`.
-
-   .. member:: int (\*eof)(struct cork_stream_consumer \*consumer)
-
-      Handle the end of the stream.  This allows you to defer any final
-      validation or error detection until all of the data has been
-      processed.
-
-      If there is an error detected at this point, you should return
-      ``-1`` and fill in the current error condition using
-      :c:func:`cork_error_set`.
-
-   .. member:: void (\*free)(struct cork_stream_consumer \*consumer)
-
-      Free the consumer object.
-
-
-Built-in stream consumers
-~~~~~~~~~~~~~~~~~~~~~~~~~
-
-We provide several built-in stream consumers:
-
-.. function:: struct cork_stream_consumer \*cork_fd_consumer_new(int fd)
-              struct cork_stream_consumer \*cork_file_consumer_new(FILE \*fp)
-              struct cork_stream_consumer \*cork_file_from_path_consumer_new(const char \*path, int flags)
-
-   Create a stream consumer that appends any data that it receives to a file.
-   The ``_fd`` and ``_file`` variants append to a file that you've already
-   opened; you are responsible for closing the file after the consumer has
-   finished processing data.  The ``_file_from_path`` variant will open the file
-   for you, using the standard ``open(2)`` function with the given *flags*.
-   This variant will close the file before returning, regardless of whether the
-   stream consumer successfully processed the data or not.
-
-
-File stream consumer example
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-As an example, we could implement a stream consumer for the
-:c:func:`cork_file_consumer_new` function as follows::
-
-  #include <stdio.h>
-  #include <libcork/core.h>
-  #include <libcork/helpers/errors.h>
-  #include <libcork/ds.h>
-
-  struct cork_file_consumer {
-      /* cork_file_consumer implements the cork_stream_consumer interface */
-      struct cork_stream_consumer  parent;
-      /* the file to write the data into */
-      FILE  *fp;
-  };
-
-  static int
-  cork_file_consumer__data(struct cork_stream_consumer *vself,
-                           const void *buf, size_t size, bool is_first)
-  {
-      struct file_consumer  *self =
-          cork_container_of(vself, struct cork_file_consumer, parent);
-      size_t  bytes_written = fwrite(buf, 1, size, self->fp);
-      /* If there was an error writing to the file, then signal this to
-       * the producer */
-      if (bytes_written == size) {
-          return 0;
-      } else {
-          cork_system_error_set();
-          return -1;
-      }
-  }
-
-  static int
-  cork_file_consumer__eof(struct cork_stream_consumer *vself)
-  {
-      /* We don't close the file, so there's nothing special to do at
-       * end-of-stream. */
-      return 0;
-  }
-
-  static void
-  cork_file_consumer__free(struct cork_stream_consumer *vself)
-  {
-      struct file_consumer  *self =
-          cork_container_of(vself, struct cork_file_consumer, parent);
-      free(self);
-  }
-
-  struct cork_stream_consumer *
-  cork_file_consumer_new(FILE *fp)
-  {
-      struct cork_file_consumer  *self = cork_new(struct cork_file_consumer);
-      self->parent.data = cork_file_consumer__data;
-      self->parent.eof = cork_file_consumer__eof;
-      self->parent.free = cork_file_consumer__free;
-      self->fp = fp;
-      return &self->parent;
-  }
-
-Note that this stream consumer does not take care of opening or closing the
-``FILE`` object.
diff --git a/docs/old/subprocess.rst b/docs/old/subprocess.rst
deleted file mode 100644
index 2ef0dcf..0000000
--- a/docs/old/subprocess.rst
+++ /dev/null
@@ -1,204 +0,0 @@
-.. _subprocesses:
-
-************
-Subprocesses
-************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/os.h>
-
-The functions in this section let you fork child processes, run arbitrary
-commands in them, and collect any output that they produce.
-
-
-Subprocess objects
-~~~~~~~~~~~~~~~~~~
-
-.. type:: struct cork_subprocess
-
-   Represents a child process.  There are several functions for creating child
-   processes, described below.
-
-
-.. function:: void cork_subprocess_free(struct cork_subprocess \*sub)
-
-   Free a subprocess.  The subprocess must not currently be executing.
-
-
-Creating subprocesses
-~~~~~~~~~~~~~~~~~~~~~
-
-There are several functions that you can use to create and execute child
-processes.
-
-.. function:: struct cork_subprocess \*cork_subprocess_new(void \*user_data, cork_free_f free_user_data, cork_run_f run, struct cork_stream_consumer \*stdout, struct cork_stream_consumer \*stderr, int \*exit_code)
-              struct cork_subprocess \*cork_subprocess_new_exec(struct cork_exec \*exec, struct cork_stream_consumer \*stdout, struct cork_stream_consumer \*stderr, int \*exit_code)
-
-   Create a new subprocess specification.  The first variant will execute the
-   given *run* function in the subprocess.  The second variant will execute a
-   new program in the subprocess; the details of the program to execute are
-   given by a :c:type:`cork_exec` specification object.
-
-   For both of these functions, you can collect the data that the subprocess
-   writes to its stdout and stderr streams by passing in :ref:`stream consumer
-   <stream-consumers>` instances for the *stdout* and/or *stderr* parameters.
-   If either (or both) of these parameters is ``NULL``, then the child process
-   will inherit the corresponding output stream from the current process.
-   (Usually, this means that the child's stdout or stderr will be interleaved
-   with the parent's.)
-
-   If you provide a non-``NULL`` pointer for the *exit_code* parameter, then we
-   will fill in this pointer with the exit code of the subprocess when it
-   finishes.  For :c:func:`cork_subprocess_new_exec`, the exit code is the value
-   passed to the builtin ``exit`` function, or the value returned from the
-   subprocess's ``main`` function.  For :c:func:`cork_subprocess_new`, the exit
-   code is the value returned from the thread body's *run* function.
-
-
-You can also create *groups* of subprocesses.  This lets you start up several
-subprocesses at the same time, and wait for them all to finish.
-
-.. type:: struct cork_subprocess_group
-
-   A group of subprocesses that will all be executed simultaneously.
-
-.. function:: struct cork_subprocess_group \*cork_subprocess_group_new(void)
-
-   Create a new group of subprocesses.  The group will initially be empty.
-
-.. function:: void cork_subprocess_group_free(struct cork_subprocess_group \*group)
-
-   Free a subprocess group.  This frees all of the subprocesses in the group,
-   too.  If you've started executing the subprocesses in the group, you **must
-   not** call this function until they have finished executing.  (You can use
-   the :c:func:`cork_subprocess_group_is_finished` function to see if the group
-   is still executing, and the :c:func:`cork_subprocess_group_abort` to
-   terminate the subprocesses before freeing the group.)
-
-.. function:: void cork_subprocess_group_add(struct cork_subprocess_group \*group, struct cork_subprocess \*sub)
-
-   Add the given subprocess to *group*.  The group takes control of the
-   subprocess; you should not try to free it yourself.
-
-
-Once you've created your subprocesses, you can start them executing:
-
-.. function:: int cork_subprocess_start(struct cork_subprocess \*sub)
-              int cork_subprocess_group_start(struct cork_subprocess_group \*group)
-
-   Execute the given subprocess, or all of the subprocesses in *group*.  We
-   immediately return once the processes have been started.  You can use the
-   :c:func:`cork_subprocess_drain`, :c:func:`cork_subprocess_wait`,
-   :c:func:`cork_subprocess_group_drain`, and
-   :c:func:`cork_subprocess_group_wait` functions to wait for the subprocesses
-   to complete.
-
-   If there are any errors starting the subprocesses, we'll terminate any
-   subprocesses that we were able to start, set an :ref:`error condition
-   <errors>`, and return ``-1``.
-
-
-Since we immediately return after starting the subprocesses, you must somehow
-wait for them to finish.  There are two strategies for doing so.  If you don't
-need to communicate with the subprocesses (by writing to their stdin streams or
-sending them signals), the simplest strategy is to just wait for them to finish:
-
-.. function:: int cork_subprocess_wait(struct cork_subprocess \*sub)
-              int cork_subprocess_group_wait(struct cork_subprocess_group \*group)
-
-   Wait until the given subprocess, or all of the subprocesses in *group*, have
-   finished executing.  While waiting, we'll continue to read data from the
-   subprocesses stdout and stderr streams as we can.
-
-   If there are any errors reading from the subprocesses, we'll terminate all of
-   the subprocesses that are still executing, set an :ref:`error condition
-   <errors>`, and return ``-1``.  If the group has already finished, the
-   function doesn't do anything.
-
-As an example::
-
-    struct cork_subprocess_group  *group = /* from somewhere */;
-    /* Wait for the subprocesses to finish */
-    if (cork_subprocess_group_wait(group) == -1) {
-        /* An error occurred; handle it! */
-    }
-
-    /* At this point, we're guaranteed that the subprocesses have all been
-     * terminated; either everything finished successfully, or the subprocesses
-     * were terminated for us when an error was detected. */
-    cork_subprocess_group_free(group);
-
-
-If you do need to communicate with the subprocesses, then you need more control
-over when we try to read from their stdout and stderr streams.  (The pipes that
-connect the subprocesses to the parent process are fixed size, and so without
-careful orchestration, you can easily get a deadlock.  Moreover, the right
-pattern of reading and writing depends on the subprocesses that you're
-executing, so it's not something that we can handle for you automatically.)
-
-.. function:: struct cork_stream_consumer \*cork_subprocess_stdin(struct cork_subprocess \*sub)
-
-   Return a :ref:`stream consumer <stream-consumers>` that lets you write data
-   to the subprocess's stdin.  We do not buffer this data in any way; calling
-   :c:func:`cork_stream_consumer_data` immediately tries to write the given data
-   to the subprocess's stdin stream.  This can easily lead to deadlock if you do
-   not manage the subprocess's particular orchestration correctly.
-
-.. function:: bool cork_subprocess_is_finished(struct cork_subprocess \*sub)
-              bool cork_subprocess_group_is_finished(struct cork_subprocess_group \*group)
-
-   Return whether the given subprocess, or all of the subprocesses in *group*,
-   have finished executing.
-
-.. function:: int cork_subprocess_abort(struct cork_subprocess \*sub)
-              int cork_subprocess_group_abort(struct cork_subprocess_group \*group)
-
-   Immediately terminate the given subprocess, or all of the subprocesses in
-   *group*.  This can be used to clean up if you detect an error condition and
-   need to close the subprocesses early.  If the group has already finished, the
-   function doesn't do anything.
-
-.. function:: bool cork_subprocess_drain(struct cork_subprocess \*sub)
-              bool cork_subprocess_group_drain(struct cork_subprocess_group \*group)
-
-   Check the given subprocess, or all of the subprocesses in *group*, for any
-   output on their stdout and stderr streams.  We'll read in as much data as we
-   can from all of the subprocesses without blocking, and then return.  (Of
-   course, we only do this for those subprocesses that you provided stdout or
-   stderr consumers for.)
-
-   This function lets you pass data into the subprocesses's stdin streams, or
-   (**TODO: eventually**) send them signals, and handle any orchestration that's
-   necessarily to ensure that the subprocesses don't deadlock.
-
-   The return value indicates whether any "progress" was made.  We will return
-   ``true`` if we were able to read any data from any of the subprocesses, or if
-   we detected that any of the subprocesses exited.
-
-   If there are any errors reading from the subprocesses, we'll terminate all of
-   the subprocesses that are still executing, set an :ref:`error condition
-   <errors>`, and return ``false``.  If the group has already finished, the
-   function doesn't do anything.
-
-To do this, you continue to "drain" the subprocesses whenever you're ready to
-read from their stdout and stderr streams.  You repeat this in a loop, writing
-to the stdin streams or sending signals as necessary, until all of the
-subprocesses have finished::
-
-    struct cork_subprocess_group  *group = /* from somewhere */;
-    while (!cork_subprocess_group_is_finished(group)) {
-        /* Drain the stdout and stderr streams */
-        if (cork_subprocess_group_drain(group) == -1) {
-            /* An error occurred; handle it! */
-        } else {
-            /* Write to the stdin streams or send signals */
-        }
-    }
-
-    /* At this point, we're guaranteed that the subprocesses have all been
-     * terminated; either everything finished successfully, or the subprocesses
-     * were terminated for us when an error was detected. */
-    cork_subprocess_group_free(group);
diff --git a/docs/old/threads.rst b/docs/old/threads.rst
deleted file mode 100644
index f79f38e..0000000
--- a/docs/old/threads.rst
+++ /dev/null
@@ -1,329 +0,0 @@
-.. _multithreading:
-
-**********************
-Multithreading support
-**********************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/threads.h>
-
-libcork provides several functions for handling threads and writing
-thread-aware code in a portable way.
-
-
-.. _thread-ids:
-
-Thread IDs
-==========
-
-.. type:: unsigned int cork_thread_id
-
-   An identifier for a thread in the current process.  This is a portable type;
-   it is not based on the "raw" thread ID used by the underlying thread
-   implementation.  This type will always be equivalent to ``unsigned int``, on
-   all platforms.  Furthermore, :c:data:`CORK_THREAD_NONE` will always refer to
-   an instance of this type that we guarantee will not be used by any thread.
-
-.. var:: cork_thread_id CORK_THREAD_NONE
-
-   A :c:type:`cork_thread_id` value that will not be used as the ID of any
-   thread.  You can use this value to represent "no thread" in any data
-   structures you create.  Moreover, we guarantee that ``CORK_THREAD_NONE`` will
-   have the value ``0``, which lets you zero-initialize a data structure
-   containing a :c:type:`cork_thread_id`, and have its initial state
-   automatically represent "no thread".
-
-.. function:: cork_thread_id cork_current_thread_get_id(void)
-
-   Returns the identifier of the currently executing thread.  This function
-   works correctly for any thread in the current proces --- including the main
-   thread, and threads that weren't created by :c:func:`cork_thread_new`.
-
-
-.. _threads:
-
-Creating threads
-================
-
-The functions in this section let you create and start new threads in the
-current process.  Each libcork thread is named and has a unique :ref:`thread ID
-<thread-ids>`.  Each thread also contains a ``run`` function, which defines the
-code that should be executed within the new thread.
-
-Every thread goes through the same lifecycle:
-
-1) You create a new thread via :c:func:`cork_thread_new`.  At this point, the
-   thread is ready to execute, but isn't automatically started.  If you
-   encounter an error before you start the thread, you must use
-   :c:func:`cork_thread_free` to free the thread object.
-
-   When you create the thread, you give it a :c:type:`cork_run_f` function,
-   which defines the code that will be executed in the new thread.  You also
-   provide a ``user_data`` value, which it gives you a place to pass data into
-   and out of the thread.
-
-   .. note::
-
-      Any data passed into and out of the thread via the body instance is not
-      automatically synchronized or thread-safe.  You can safely pass in input
-      data before calling :c:type:`cork_thread_new`, and retrieve output data
-      after calling :c:type:`cork_thread_join`, all without requiring any extra
-      synchronization effort.  While the thread is executing, however, you must
-      implement your own synchronization or locking to access the contents of
-      the body from some other thread.
-
-2) You start the thread via :c:func:`cork_thread_start`.  You must ensure that
-   you don't try to start a thread more than once.  Once you've started a
-   thread, you no longer have responsibility for freeing it; you must ensure
-   that you don't call :c:func:`cork_thread_free` on a thread that you've
-   started.
-
-3) Once you've started a thread, you wait for it to finish via
-   :c:func:`cork_thread_join`.  Any thread can wait for any other thread to
-   finish, although you are responsible for ensuring that your threads don't
-   deadlock.  However, you can only join a particular thread once.
-
-
-
-
-.. type:: struct cork_thread
-
-   A thread within the current process.  This type is opaque; you must use the
-   functions defined below to interact with the thread.
-
-
-.. function:: struct cork_thread \*cork_thread_new(const char \*name, void \*user_data, cork_free_f free_user_data, cork_run_f run)
-
-   Create a new thread with the given *name* that will execute *run*.  The
-   thread does not start running immediately.
-
-   When the thread is started, the *run* function will be called with
-   *user_data* as its only parameter.  When the thread finishes (or if it is
-   freed via :c:func:`cork_thread_free` before the thread is started), we'll use
-   the *free_user_data* function to free the *user_data* value.  You can provide
-   ``NULL`` if *user_data* shouldn't be freed, or if you want to free it
-   yourself.
-
-   .. note::
-
-      If you provide a *free_user_data* function, it will be called as soon as
-      the thread finished.  That means that if you use
-      :c:func:`cork_thread_join` to wait for the thread to finish, the
-      *user_data* value will no longer be valid when :c:func:`cork_thread_join`
-      returns.  You must either copy any necessary data out into more a more
-      persistent memory location before the thread finishes, or you should use a
-      ``NULL`` *free_user_data* function and free the *user_data* memory
-      yourself once you're sure the thread has finished.
-
-
-.. function:: void cork_thread_free(struct cork_thread \*thread)
-
-   Free *thread*.  You can only call this function if you haven't started the
-   thread yet.  Once you start a thread, the thread is responsible for freeing
-   itself when it finishes.
-
-.. function:: struct cork_thread \*cork_current_thread_get(void)
-
-   Return the :c:type:`cork_thread` instance for the current thread.  This
-   function returns ``NULL`` when called from the main thread (i.e., the one
-   created automatically when the process starts), or from a thread that wasn't
-   created via :c:func:`cork_thread_new`.
-
-.. function:: const char \* cork_thread_get_name(struct cork_thread \*thread)
-              cork_thread_id cork_thread_get_id(struct cork_thread \*thread)
-
-   Retrieve information about the given thread.
-
-.. function:: int cork_thread_start(struct cork_thread \*thread)
-
-   Start *thread*.  After calling this function, you must not try to free
-   *thread* yourself; the thread will automatically free itself once it has
-   finished executing and has been joined.
-
-.. function:: int cork_thread_join(struct cork_thread \*thread)
-
-   Wait for *thread* to finish executing.  If the thread's body's ``run``
-   function an :ref:`error condition <errors>`, we will catch that error and
-   return it ourselves.  The thread is automatically freed once it finishes
-   executing.
-
-   You cannot join a thread that has not been started, and once you've started a
-   thread, you **must** join it exactly once.  (If you don't join it, there's no
-   guarantee that it will be freed.)
-
-
-.. _atomics:
-
-Atomic operations
-=================
-
-We provide several platform-agnostic macros for implementing common
-atomic operations.
-
-
-Addition
-~~~~~~~~
-
-.. function:: int cork_int_atomic_add(volatile int \*var, int delta)
-              unsigned int cork_uint_atomic_add(volatile unsigned int \*var, unsigned int delta)
-              size_t cork_size_atomic_add(volatile size_t \*var, size_t delta)
-
-   Atomically add *delta* to the variable pointed to by *var*, returning
-   the result of the addition.
-
-.. function:: int cork_int_atomic_pre_add(volatile int \*var, int delta)
-              unsigned int cork_uint_atomic_pre_add(volatile unsigned int \*var, unsigned int delta)
-              size_t cork_size_atomic_pre_add(volatile size_t \*var, size_t delta)
-
-   Atomically add *delta* to the variable pointed to by *var*, returning
-   the value from before the addition.
-
-
-Subtraction
-~~~~~~~~~~~
-
-.. function:: int cork_int_atomic_sub(volatile int \*var, int delta)
-              unsigned int cork_uint_atomic_sub(volatile unsigned int \*var, unsigned int delta)
-              size_t cork_size_atomic_sub(volatile size_t \*var, size_t delta)
-
-   Atomically subtract *delta* from the variable pointed to by *var*,
-   returning the result of the subtraction.
-
-.. function:: int cork_int_atomic_pre_sub(volatile int \*var, int delta)
-              unsigned int cork_uint_atomic_pre_sub(volatile unsigned int \*var, unsigned int delta)
-              size_t cork_size_atomic_pre_sub(volatile size_t \*var, size_t delta)
-
-   Atomically subtract *delta* from the variable pointed to by *var*,
-   returning the value from before the subtraction.
-
-
-Compare-and-swap
-~~~~~~~~~~~~~~~~
-
-.. function:: int cork_int_cas(volatile int_t \*var, int old_value, int new_value)
-              unsigned int cork_uint_cas(volatile uint_t \*var, unsigned int old_value, unsigned int new_value)
-              size_t cork_size_cas(volatile size_t \*var, size_t old_value, size_t new_value)
-              TYPE \*cork_ptr_cas(TYPE \* volatile \*var, TYPE \*old_value, TYPE \*new_value)
-
-   Atomically check whether the variable pointed to by *var* contains
-   the value *old_value*, and if so, update it to contain the value
-   *new_value*.  We return the value of *var* before the
-   compare-and-swap.  (If this value is equal to *old_value*, then the
-   compare-and-swap was successful.)
-
-
-.. _once:
-
-Executing something once
-========================
-
-The functions in this section let you ensure that a particular piece of
-code is executed exactly once, even if multiple threads attempt the
-execution at roughly the same time.
-
-.. macro:: cork_once_barrier(name)
-
-   Declares a barrier that can be used with the :c:func:`cork_once`
-   macro.
-
-.. macro:: cork_once(barrier, call)
-           cork_once_recursive(barrier, call)
-
-   Ensure that *call* (which can be an arbitrary statement) is executed
-   exactly once, regardless of how many times control reaches the call
-   to ``cork_once``.  If control reaches the ``cork_once`` call at
-   roughly the same time in multiple threads, exactly one of them will
-   be allowed to execute the code.  The call to ``cork_once`` won't
-   return until *call* has been executed.
-
-   If you have multiple calls to ``cork_once`` that use the same
-   *barrier*, then exactly one *call* will succeed.  If the *call*
-   statements are different in those ``cork_once`` invocations, then
-   it's undefined which one gets executed.
-
-   If the function that contains the ``cork_once`` call is recursive, then you
-   should call the ``_recursive`` variant of the macro.  With the ``_recursive``
-   variant, if the same thread tries to obtain the underlying lock multiple
-   times, the second and later calls will silently succeed.  With the regular
-   variant, you'll get a deadlock in this case.
-
-These macros are usually used to initialize a static variable that will
-be shared across multiple threads::
-
-    static struct my_type  shared_value;
-
-    static void
-    expensive_initialization(void)
-    {
-        /* do something to initialize shared_value */
-    }
-
-    cork_once_barrier(shared_value_once);
-
-    struct my_type *
-    get_shared_value(void)
-    {
-        cork_once(shared_value_once, expensive_initialization());
-        return &shared_value;
-    }
-
-Each thread can then call ``get_shared_value`` to retrieve a properly
-initialized instance of ``struct my_type``.  Regardless of how many
-threads call this function, and how often they call it, the value will
-be initialized exactly once, and will be guaranteed to be initialized
-before any thread tries to use it.
-
-
-.. _tls:
-
-Thread-local storage
-====================
-
-The macro in this section can be used to create thread-local storage in
-a platform-agnostic manner.
-
-.. macro:: cork_tls(TYPE type, SYMBOL name)
-
-   Creates a static function called :samp:`{[name]}_get`, which will
-   return a pointer to a thread-local instance of *type*.  This is a
-   static function, so it won't be visible outside of the current
-   compilation unit.
-
-   When a particular thread's instance is created for the first time, it
-   will be filled with ``0`` bytes.  If the actual type needs more
-   complex initialization before it can be used, you can create a
-   wrapper struct that contains a boolean indiciating whether that
-   initialization has happened::
-
-       struct wrapper {
-           bool  initialized;
-           struct real_type  val;
-       };
-
-       cork_tls(struct wrapper, wrapper);
-
-       static struct real_type *
-       real_type_get(void)
-       {
-           struct wrapper * wrapper = wrapper_get();
-           struct real_type * real_val = &wrapper->val;
-           if (CORK_UNLIKELY(!wrapper->initialized)) {
-               expensive_initialization(real_val);
-           }
-           return real_val;
-       }
-
-   It's also not possible to provide a finalization function; if your
-   thread-local variable acquires any resources or memory that needs to
-   be freed when the thread finishes, you must make a “thread cleanup”
-   function that you explicitly call at the end of each thread.
-
-   .. note::
-
-      On some platforms, the number of thread-local values that can be
-      created by any given process is limited (i.e., on the order of 128
-      or 256 values).  This means that you should limit the number of
-      thread-local values you create, especially in a library.
diff --git a/docs/old/timestamps.rst b/docs/old/timestamps.rst
deleted file mode 100644
index 229b5af..0000000
--- a/docs/old/timestamps.rst
+++ /dev/null
@@ -1,97 +0,0 @@
-.. _timestamps:
-
-*************************
-High-precision timestamps
-*************************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-
-.. type:: uint64_t  cork_timestamp
-
-   A high-precision timestamp type.  A timestamp is represented by a
-   64-bit integer, whose unit is the *gammasecond* (γsec), where
-   :math:`1~\textrm{γsec} = \frac{1}{2^{32}} \textrm{sec}`.  With this
-   representation, the upper 32 bits of a timestamp value represent the
-   timestamp truncated (towards zero) to seconds.
-
-   For this type, we don't concern ourselves with any higher-level
-   issues of clock synchronization or time zones.  ``cork_timestamp``
-   values can be used to represent any time quantity, regardless of
-   which time standard (UTC, GMT, TAI) you use, or whether it takes into
-   account the local time zone.
-
-
-.. function:: void cork_timestamp_init_sec(cork_timestamp \*ts, uint32_t sec)
-              void cork_timestamp_init_gsec(cork_timestamp \*ts, uint32_t sec, uint32_t gsec)
-              void cork_timestamp_init_msec(cork_timestamp \*ts, uint32_t sec, uint32_t msec)
-              void cork_timestamp_init_usec(cork_timestamp \*ts, uint32_t sec, uint32_t usec)
-              void cork_timestamp_init_nsec(cork_timestamp \*ts, uint32_t sec, uint32_t nsec)
-
-   Initializes a timestamp from a separate seconds part and fractional
-   part.  For the ``_sec`` variant, the fractional part will be set to
-   ``0``.  For the ``_gsec`` variant, you provide the fractional part in
-   gammaseconds.  For the ``_msec``, ``_usec``, and ``_nsec`` variants, the
-   fractional part will be translated into gammaseconds from milliseconds,
-   microseconds, or nanoseconds, respectively.
-
-
-.. function:: void cork_timestamp_init_now(cork_timestamp \*ts)
-
-   Initializes a timestamp with the current UTC time of day.
-
-   .. note::
-
-      The resolution of this function is system-dependent.
-
-
-.. function:: uint32_t cork_timestamp_sec(const cork_timestamp ts)
-
-   Returns the seconds portion of a timestamp.
-
-.. function:: uint32_t cork_timestamp_gsec(const cork_timestamp ts)
-              uint32_t cork_timestamp_msec(const cork_timestamp ts)
-              uint32_t cork_timestamp_usec(const cork_timestamp ts)
-              uint32_t cork_timestamp_nsec(const cork_timestamp ts)
-
-   Returns the fractional portion of a timestamp.  The variants return the
-   fractional portion in, respectively, gammaseconds, milliseconds,
-   microseconds, or nanoseconds.
-
-
-.. function:: int cork_timestamp_format_utc(const cork_timestamp ts, const char \*format, struct cork_buffer \*buf)
-              int cork_timestamp_format_local(const cork_timestamp ts, const char \*format, struct cork_buffer \*buf)
-
-   Create the string representation of the given timestamp according to
-   *format*, appending the result to the current contents of *buf*.
-
-   The ``_utc`` variant assumes that *ts* represents a UTC time, whereas the
-   ``_local`` variant assumes that it represents a time in the local time zone.
-
-   *format* is a format string whose syntax is similar to that of the POSIX
-   ``strftime`` function.  *format* must contain arbitrary text interspersed
-   with ``%`` specifiers, which will be replaced with portions of the timestamp.
-   The following specifiers are recognized (note that this list does **not**
-   include all of the specifiers supported by ``strftime``):
-
-   ============== ====================================================
-   Specifier      Replacement
-   ============== ====================================================
-   ``%%``         A literal ``%`` character
-   ``%d``         Day of month (``01``-``31``)
-   ``%[width]f``  Fractional seconds (zero-padded, limited to ``[width]``
-                  digits)
-   ``%H``         Hour in current day (``00``-``23``)
-   ``%m``         Month (``01``-``12``)
-   ``%M``         Minute in current hour (``00``-``59``)
-   ``%s``         Number of seconds since Unix epoch
-   ``%S``         Second in current minute (``00``-``60``)
-   ``%Y``         Four-digit year (including century)
-   ============== ====================================================
-
-   If the format string is invalid, we will return an :ref:`error condition
-   <errors>`.
diff --git a/docs/old/unique-ids.rst b/docs/old/unique-ids.rst
deleted file mode 100644
index 2c55598..0000000
--- a/docs/old/unique-ids.rst
+++ /dev/null
@@ -1,90 +0,0 @@
-.. _unique-ids:
-
-******************
-Unique identifiers
-******************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-
-The functions in this section let you define compile-time unique identifiers.
-These identifiers are simple C variables, and each one is guaranteed to be
-unique within the context of a single execution of your program.  They are *not*
-appropriate for use as external identifiers --- for instance, for serializing
-into long-term storage or sending via a communications channel to another
-process.
-
-
-.. type:: cork_uid
-
-   A unique identifier.
-
-
-.. macro:: cork_uid  CORK_UID_NONE
-
-   A unique identifier value that means "no identifier".  This is guaranteed to
-   be distinct from all other unique identifiers.  It is invalid to call
-   :c:func:`cork_uid_hash`, :c:func:`cork_uid_id`, or :c:func:`cork_uid_name` on
-   this identifier.
-
-
-.. macro:: cork_uid_define(SYMBOL id)
-           cork_uid_define_named(SYMBOL id, const char \*name)
-
-   You use the :c:func:`cork_uid_define` macro to define a new unique identifier
-   with the given C identifier *id*.  The ``_define`` variant also uses *id* as
-   the identifier's human-readable name; the ``_define_named`` variant let's you
-   provide a separate human-readable name.  Within the context of a single
-   execution of this program, this identifier is guaranteed to be distinct from
-   any other identifier, regardless of which library the identifiers are defined
-   in.
-
-   In the same compilation unit, you can then use the C identifier *id* to
-   retrieve the :c:type:`cork_uid` instance for this identifier.
-
-   .. note::
-
-      The unique identifier objects are declared ``static``, so they are only
-      directly visible (using the C identifier *id*) in the same compilation
-      unit as the :c:func:`cork_uid_define` call that created the identifier.
-      The resulting :c:type:`cork_uid` value, however, can be passed around the
-      rest of your code however you want.
-
-
-.. function:: bool cork_uid_equal(const cork_uid id1, const cork_uid id2)
-
-   Return whether two :c:type:`cork_uid` values refer to the same unique
-   identifier.
-
-
-.. function:: cork_hash cork_uid_hash(const cork_uid id)
-
-   Return a :ref:`hash value <hash-values>` for the given identifier.
-
-
-.. function:: const char \*cork_uid_name(const cork_uid id)
-
-   Return the name of the given unique identifier.
-
-
-Example
-=======
-
-::
-
-    #include <stdio.h>
-    #include <libcork/core.h>
-
-    cork_uid_define(test_id);
-
-    int
-    main(void)
-    {
-        cork_uid  id = test_id;
-        printf("Identifier %p has name %s\n", id, cork_uid_name(id));
-        return 0;
-    }
diff --git a/docs/old/versions.rst b/docs/old/versions.rst
deleted file mode 100644
index fca99cf..0000000
--- a/docs/old/versions.rst
+++ /dev/null
@@ -1,74 +0,0 @@
-.. _versions:
-
-***************
-Library version
-***************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-The macros and functions in this section let you determine the version of the
-libcork library at compile-time and runtime, and make it easier for you to
-define similar macros and functions in your own libraries.
-
-
-libcork version
----------------
-
-.. macro:: CORK_VERSION
-
-   The libcork library version, encoded as a single number as follows::
-
-       (major * 1000000) + (minor * 1000) + patch
-
-   For instance, version 1.2.10 would be encoded as 1002010.
-
-.. macro:: CORK_VERSION_MAJOR
-           CORK_VERSION_MINOR
-           CORK_VERSION_PATCH
-
-   The libcork library version, with each part of the version number separated
-   out into separate macros.
-
-
-.. function:: const char \*cork_version_string(void)
-              const char \*cork_revision_string(void)
-
-   Return the libcork library version or revision as a string.  The *version* is
-   the simple three-part version number (``major:minor:patch``).  The
-   *revision* is an opaque string that identifies the specific revision in
-   libcork's code history.  (Right now, this is a SHA-1 git commit identifier.)
-
-
-.. tip:: Compile-time vs runtime
-
-   There's an important difference between the :c:macro:`CORK_VERSION` macro and
-   :c:func:`cork_version_string` function, even though they seemingly return the
-   same information.
-
-   The macro version be evaluated by the preprocessor, and so it will return the
-   version that was available *when your code was compiled*.  If you later
-   install a newer (but backwards-compatible) version of libcork, any code that
-   called the macro will still have the original version, and not the new
-   version.
-
-   The function version, on the other hand, calculates the version information
-   *at runtime*, when the function is actually called.  That means that the
-   function result will always give you the current installed libcork version,
-   even as newer versions are installed on the system.
-
-
-Constructing version information
---------------------------------
-
-If you're writing a library that uses libcork, it's a good idea to provide your
-own version information, similar to how libcork does.
-
-
-.. function:: CORK_MAKE_VERSION(major, minor, patch)
-
-   Assemble a ``major.minor.patch`` version into a single number, using the same
-   pattern as :c:macro:`CORK_VERSION`.
diff --git a/docs/old/visibility.rst b/docs/old/visibility.rst
deleted file mode 100644
index aa71e74..0000000
--- a/docs/old/visibility.rst
+++ /dev/null
@@ -1,121 +0,0 @@
-.. _visibility:
-
-*****************
-Symbol visibility
-*****************
-
-.. highlight:: c
-
-::
-
-  #include <libcork/core.h>
-
-When writing a shared library, you should always be careful to explicitly mark
-which functions and other symbols are part of the library's public API, and
-which should only be used internally by the library.  There are a number of
-benefits to doing this; there is a good summary on the `GCC wiki`_.  (Note that
-even though that summary is on the GCC wiki, the notes apply equally well to
-other compilers and platforms.)
-
-.. _GCC wiki: http://gcc.gnu.org/wiki/Visibility
-
-libcork provides several helper macros that make it easier to do this.  We use
-these macros ourselves to define libcork's public API.
-
-
-Defining a library's public API
--------------------------------
-
-On some platforms (for instance, on Windows), you must declare each public
-function and symbol differently depending on whether you're compiling the
-library that *defines* the symbol, or a library or program that *uses* the
-symbol.  The first is called an *export*, the second an *import*.  On other
-platforms (for instance, GCC on Linux), the declaration of a public symbol is
-the same regardless of whether you're exporting or importing the symbol.
-libcork provides macros that let you explicitly declare a symbol as an export or
-an import in a platform-independent way.
-
-.. macro:: CORK_EXPORT
-           CORK_IMPORT
-
-   Explicitly declare that a symbol should be exported from the current shared
-   library, or imported from some other shared library.
-
-However, you will rarely need to use these macros directly.  Instead, when
-writing a new shared library, you should declare a new preprocessor macro
-(specific to the new library), which you'll use when declaring the library's
-public API.  For instance, if you're creating a new library called
-*libfoo*, you would declare a new preprocessor macro called ``FOO_API``::
-
-    #if !defined(FOO_API)
-    #define FOO_API  CORK_IMPORT
-    #endif
-
-This ensures that anyone who wants to *use* libfoo doesn't need to do anything
-special; the ``FOO_API`` macro will default to importing the symbols from
-libfoo's public API.
-
-When *building* libfoo, you must set up your build system to define this
-variable differently; since you need to *export* the symbols in this case, the
-``FOO_API`` macro should be set to ``CORK_EXPORT``.  Each build system will have
-a different way to do this.  In CMake, for instance, you'd add the following:
-
-.. code-block:: cmake
-
-    set_target_properties(libfoo PROPERTIES
-        COMPILE_DEFINITIONS FOO_API=CORK_EXPORT
-    )
-
-Then, in all of your header files, you should use your new ``FOO_API`` macro
-when declaring each function or symbol in the public API::
-
-    FOO_API int
-    foo_load_from_file(const char *name);
-
-    FOO_API void
-    foo_do_something_great(int flags);
-
-    extern FOO_API  const char  *foo_name;
-
-
-Local symbols
--------------
-
-Normally, if you need a function to be local, and not be exported as part of the
-library's public API, you can just declare it ``static``::
-
-    static int
-    file_local_function(void)
-    {
-        /* This function is not visible outside of this file. */
-        return 0;
-    }
-
-This works great as long as the function is only needed within the current
-source file.  Sometimes, though, you need to define a function that can be used
-in other source files within the same library, but which shouldn't be visible
-outside of the library.  To do this, you should define the function using the
-:c:macro:`CORK_LOCAL` macro.
-
-.. macro:: CORK_LOCAL
-
-   Declare a symbol that should be visible in any source file within the current
-   library, but not visible outside of the library.
-
-As an example::
-
-    CORK_LOCAL int
-    library_local_function(void)
-    {
-        /* This function is visible in other files, but not outside of the
-         * library. */
-        return 0;
-    }
-
-Since you're going to use this function in multiple files, you'll want to
-declare the function in a header file.  However, since the function is not part
-of the public API, this should *not* be defined in a public header file (that
-is, one that's installed along with the shared library).  Instead, you should
-include a private header file that's only available in your library's source
-code archive, and which should not be installed with the other public header
-files.
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index ed3e309..e77f0aa 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -69,47 +69,3 @@ add_c_library(
         threads
 )
 
-if (ENABLE_SHARED OR ENABLE_SHARED_EXECUTABLES)
-    set_target_properties(libcork-shared PROPERTIES
-        COMPILE_DEFINITIONS CORK_API=CORK_EXPORT
-    )
-endif (ENABLE_SHARED OR ENABLE_SHARED_EXECUTABLES)
-
-if (ENABLE_STATIC OR NOT ENABLE_SHARED_EXECUTABLES)
-    set_target_properties(libcork-static PROPERTIES
-        COMPILE_DEFINITIONS CORK_API=CORK_LOCAL
-    )
-endif (ENABLE_STATIC OR NOT ENABLE_SHARED_EXECUTABLES)
-
-
-#-----------------------------------------------------------------------
-# Utility commands
-
-add_c_executable(
-    cork-hash
-    OUTPUT_NAME cork-hash
-    SOURCES cork-hash/cork-hash.c
-    LOCAL_LIBRARIES
-        libcork
-)
-
-add_c_executable(
-    cork-initializer
-    SKIP_INSTALL
-    OUTPUT_NAME cork-initializer
-    SOURCES
-        cork-initializer/init1.c
-        cork-initializer/init2.c
-        cork-initializer/main.c
-    LOCAL_LIBRARIES
-        libcork
-)
-
-add_c_executable(
-    cork-test
-    SKIP_INSTALL
-    OUTPUT_NAME cork-test
-    SOURCES cork-test/cork-test.c
-    LOCAL_LIBRARIES
-        libcork
-)
