diff --git a/service/service.c b/service/service.c
index fcf0215..47fc88a 100644
--- a/service/service.c
+++ b/service/service.c
@@ -12,8 +12,11 @@
  * GNU General Public License for more details.
  */
 
-#include <sys/types.h>
+#include <fcntl.h>
+#include <linux/limits.h>
 #include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/wait.h>
 #include <unistd.h>
 
 #include <libubox/blobmsg_json.h>
@@ -292,6 +295,17 @@ static const struct blobmsg_policy container_console_policy[__CONTAINER_CONSOLE_
 	[CONTAINER_CONSOLE_INSTANCE] = { "instance", BLOBMSG_TYPE_STRING },
 };
 
+enum {
+	INIT_ACTION_NAME,
+	INIT_ACTION_ACTION,
+	__INIT_MAX
+};
+
+static const struct blobmsg_policy init_action_policy[] = {
+	[INIT_ACTION_NAME] = { "name", BLOBMSG_TYPE_STRING },
+	[INIT_ACTION_ACTION] = { "action", BLOBMSG_TYPE_STRING },
+};
+
 static inline bool is_container_obj(struct ubus_object *obj)
 {
 	return (obj && (strcmp(obj->name, "container") == 0));
@@ -785,6 +799,86 @@ err_console_fd:
 }
 
 
+struct service_init_context {
+	struct uloop_process process;
+	struct ubus_context *ctx;
+	struct ubus_request_data req;
+};
+
+static void service_init_action_cb(struct uloop_process *p, int stat)
+{
+	struct service_init_context *c = container_of(p, struct service_init_context, process);
+
+	ubus_complete_deferred_request(c->ctx, &c->req, UBUS_STATUS_OK);
+
+	free(c);
+}
+
+static int service_init_action(struct ubus_context *ctx,
+			       struct ubus_object *obj,
+			       struct ubus_request_data *req,
+			       const char *method,
+			       struct blob_attr *msg)
+{
+	struct blob_attr *tb[__INIT_MAX];
+	struct service_init_context *c;
+	struct stat s;
+	char script[PATH_MAX];
+	const char *action;
+	pid_t pid;
+	int fd;
+
+	blobmsg_parse(init_action_policy, __INIT_MAX, tb, blobmsg_data(msg), blobmsg_data_len(msg));
+
+	if (!tb[INIT_ACTION_NAME] || !tb[INIT_ACTION_ACTION])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	snprintf(script, sizeof(script), "/etc/init.d/%s", blobmsg_get_string(tb[INIT_ACTION_NAME]));
+	if (stat(script, &s) || !(s.st_mode & S_IXUSR))
+		return UBUS_STATUS_NOT_FOUND;
+
+	action = blobmsg_get_string(tb[INIT_ACTION_ACTION]);
+	if (strcmp(action, "disable") &&
+	    strcmp(action, "enable") &&
+	    strcmp(action, "stop") &&
+	    strcmp(action, "start") &&
+	    strcmp(action, "restart") &&
+	    strcmp(action, "reload"))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	c = calloc(1, sizeof(*c));
+	if (!c)
+		return UBUS_STATUS_UNKNOWN_ERROR;
+
+	pid = fork();
+	switch (pid) {
+	case -1:
+		free(c);
+		return UBUS_STATUS_UNKNOWN_ERROR;
+	case 0:
+		/* Set stdin, stdout & stderr to /dev/null */
+		fd = open("/dev/null", O_RDWR);
+		if (fd >= 0) {
+			dup2(fd, 0);
+			dup2(fd, 1);
+			dup2(fd, 2);
+			close(fd);
+		}
+
+		execl(script, script, action, NULL);
+		exit(errno);
+	default:
+		c->ctx = ctx;
+		c->process.pid = pid;
+		c->process.cb = service_init_action_cb;
+		uloop_process_add(&c->process);
+
+		ubus_defer_request(ctx, req, &c->req);
+
+		return 0; /* Deferred */
+	}
+}
+
 static struct ubus_method main_object_methods[] = {
 	UBUS_METHOD("set", service_handle_set, service_set_attrs),
 	UBUS_METHOD("add", service_handle_set, service_set_attrs),
@@ -797,6 +891,7 @@ static struct ubus_method main_object_methods[] = {
 	UBUS_METHOD("validate", service_handle_validate, validate_policy),
 	UBUS_METHOD("get_data", service_get_data, get_data_policy),
 	UBUS_METHOD("state", service_handle_state, service_state_attrs),
+	UBUS_METHOD("init_action", service_init_action, init_action_policy),
 };
 
 static struct ubus_object_type main_object_type =
