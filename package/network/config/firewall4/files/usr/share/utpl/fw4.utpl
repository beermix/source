{%

local networks = {};
local defaults = null;
local helpers = [];
local zones = [];
local rules = [];
local redirects = [];
local chains = {};

local PARSE_LIST   = 0x01;
local FLATTEN_LIST = 0x02;
local NO_INVERT    = 0x04;
local UNSUPPORTED  = 0x08;
local REQUIRED     = 0x10;

local ipv4_icmptypes = {
	"any": [ 0xFF, 0, 0xFF ],
	"echo-reply": [ 0, 0, 0xFF ],
	"pong": [ 0, 0, 0xFF ], /* Alias */

	"destination-unreachable": [ 3, 0, 0xFF ],
	"network-unreachable": [ 3, 0, 0 ],
	"host-unreachable": [ 3, 1, 1 ],
	"protocol-unreachable": [ 3, 2, 2 ],
	"port-unreachable": [ 3, 3, 3 ],
	"fragmentation-needed": [ 3, 4, 4 ],
	"source-route-failed": [ 3, 5, 5 ],
	"network-unknown": [ 3, 6, 6 ],
	"host-unknown": [ 3, 7, 7 ],
	"network-prohibited": [ 3, 9, 9 ],
	"host-prohibited": [ 3, 10, 10 ],
	"TOS-network-unreachable": [ 3, 11, 11 ],
	"TOS-host-unreachable": [ 3, 12, 12 ],
	"communication-prohibited": [ 3, 13, 13 ],
	"host-precedence-violation": [ 3, 14, 14 ],
	"precedence-cutoff": [ 3, 15, 15 ],

	"source-quench": [ 4, 0, 0xFF ],

	"redirect": [ 5, 0, 0xFF ],
	"network-redirect": [ 5, 0, 0 ],
	"host-redirect": [ 5, 1, 1 ],
	"TOS-network-redirect": [ 5, 2, 2 ],
	"TOS-host-redirect": [ 5, 3, 3 ],

	"echo-request": [ 8, 0, 0xFF ],
	"ping": [ 8, 0, 0xFF ], /* Alias */

	"router-advertisement": [ 9, 0, 0xFF ],

	"router-solicitation": [ 10, 0, 0xFF ],

	"time-exceeded": [ 11, 0, 0xFF ],
	"ttl-exceeded": [ 11, 0, 0xFF ], /* Alias */
	"ttl-zero-during-transit": [ 11, 0, 0 ],
	"ttl-zero-during-reassembly": [ 11, 1, 1 ],

	"parameter-problem": [ 12, 0, 0xFF ],
	"ip-header-bad": [ 12, 0, 0 ],
	"required-option-missing": [ 12, 1, 1 ],

	"timestamp-request": [ 13, 0, 0xFF ],

	"timestamp-reply": [ 14, 0, 0xFF ],

	"address-mask-request": [ 17, 0, 0xFF ],

	"address-mask-reply": [ 18, 0, 0xFF ]
};

local ipv6_icmptypes = {
	"destination-unreachable": [ 1, 0, 0xFF ],
	"no-route": [ 1, 0, 0 ],
	"communication-prohibited": [ 1, 1, 1 ],
	"address-unreachable": [ 1, 3, 3 ],
	"port-unreachable": [ 1, 4, 4 ],

	"packet-too-big": [ 2, 0, 0xFF ],

	"time-exceeded": [ 3, 0, 0xFF ],
	"ttl-exceeded": [ 3, 0, 0xFF ], /* Alias */
	"ttl-zero-during-transit": [ 3, 0, 0 ],
	"ttl-zero-during-reassembly": [ 3, 1, 1 ],

	"parameter-problem": [ 4, 0, 0xFF ],
	"bad-header": [ 4, 0, 0 ],
	"unknown-header-type": [ 4, 1, 1 ],
	"unknown-option": [ 4, 2, 2 ],

	"echo-request": [ 128, 0, 0xFF ],
	"ping": [ 128, 0, 0xFF ], /* Alias */

	"echo-reply": [ 129, 0, 0xFF ],
	"pong": [ 129, 0, 0xFF ], /* Alias */

	"router-solicitation": [ 133, 0, 0xFF ],

	"router-advertisement": [ 134, 0, 0xFF ],

	"neighbour-solicitation": [ 135, 0, 0xFF ],
	"neighbor-solicitation": [ 135, 0, 0xFF ], /* Alias */

	"neighbour-advertisement": [ 136, 0, 0xFF ],
	"neighbor-advertisement": [ 136, 0, 0xFF ], /* Alias */

	"redirect": [ 137, 0, 0xFF ]
};

local dscp_classes = {
	"CS0": 0x00,
	"CS1": 0x08,
	"CS2": 0x10,
	"CS3": 0x18,
	"CS4": 0x20,
	"CS5": 0x28,
	"CS6": 0x30,
	"CS7": 0x38,
	"BE": 0x00,
	"AF11": 0x0a,
	"AF12": 0x0c,
	"AF13": 0x0e,
	"AF21": 0x12,
	"AF22": 0x14,
	"AF23": 0x16,
	"AF31": 0x1a,
	"AF32": 0x1c,
	"AF33": 0x1e,
	"AF41": 0x22,
	"AF42": 0x24,
	"AF43": 0x26,
	"EF": 0x2e
};

function to_mask(bits, v6) {
	local m = [];

	if (bits < 0 || bits > (v6 ? 128 : 32))
		return null;

	for (local i = 0; i < (v6 ? 16 : 4); i++) {
		local b = (bits < 8) ? bits : 8;
		m[i] = (0xff << (8 - b)) & 0xff;
		bits -= b;
	}

	return arrtoip(m);
}

function to_bits(mask) {
	local a = iptoarr(mask);

	if (!a)
		return null;

	local bits = 0;

	for (local i = 0, z = false; i < length(a); i++) {
		z = z || !a[i];

		while (!z && (a[i] & 0x80)) {
			a[i] = (a[i] << 1) & 0xff;
			bits++;
		}

		if (a[i])
			return null;
	}

	return bits;
}

function apply_mask(addr, mask) {
	local a = iptoarr(addr);

	if (!a)
		return null;

	if (type(mask) == "int") {
		for (local i = 0; i < length(a); i++) {
			local b = (mask < 8) ? mask : 8;
			a[i] &= (0xff << (8 - b)) & 0xff;
			mask -= b;
		}
	}
	else {
		local m = iptoarr(mask);

		if (!m || length(a) != length(m))
			return null;

		for (local i = 0; i < length(a); i++)
			a[i] &= m[i];
	}

	return arrtoip(a);
}

function to_array(x) {
	if (type(x) == "array")
		return x;

	if (x == null)
		return [];

	if (type(x) == "object")
		return [ x ];

	x = trim("" + x);

	return (x == "") ? [] : split(x, /[ \t]+/);
}

function filter_pos(x) {
	local rv = filter(x, function(e) { !e.invert; });
	return length(rv) ? rv : null;
}

function filter_neg(x) {
	local rv = filter(x, function(e) { e.invert; });
	return length(rv) ? rv : null;
}

function subnets_split_af(x) {
	local rv = [];

	for (local ag in to_array(x)) {
		for (local a in filter(ag.addrs, function(a) { a.family == 4 })) {
			rv[0] = rv[0] || [];
			push(rv[0], {
				invert: ag.invert,
				family: a.family,
				addr: a.addr,
				bits: a.bits
			});
		}

		for (local a in filter(ag.addrs, function(a) { a.family == 6 })) {
			rv[1] = rv[1] || [];
			push(rv[1], {
				invert: ag.invert,
				family: a.family,
				addr: a.addr,
				bits: a.bits
			});
		}
	}

	return rv;
}

function ensure_tcpudp(x) {
	if (length(filter(x, function(p) { p.name == "tcp" || p.name == "udp" })))
		return true;

	local rest = filter(x, function(p) { !p.any }),
	      any = filter(x, function(p) { p.any });

	if (length(any) && !length(rest)) {
		splice(x, 0);
		push(x, { name: "tcp" }, { name: "udp" });
		return true;
	}

	return false;
}

function is_family(x, v) { x.family == 0 || x.family == v }
function family_is_ipv4(x) { x.family == 0 || x.family == 4 }
function family_is_ipv6(x) { x.family == 0 || x.family == 6 }

function infer_family(f, objects) {
	local res = f;
	local by = null;

	for (local i = 0; i < length(objects); i += 2) {
		local objs = to_array(objects[i]),
		      desc = objects[i + 1];

		for (local obj in objs) {
			if (!obj || obj.family == 0 || obj.family == res)
				continue;

			if (res == 0) {
				res = obj.family;
				by = obj.desc;
				continue;
			}

			return by
				? sprintf('references IPv%d only %s but is restricted to IPv%d by %s', obj.family, desc, res, by)
				: sprintf('is restricted to IPv%d but referenced %s is IPv%d only', res, desc, obj.family);
		}
	}

	return res;
}

return {
	load: function() {
		this.cursor = uci.cursor();
		this.cursor.load("firewall");
		this.cursor.load("/usr/share/firewall4/helpers");

		this.ubus = ubus.connect();

		local self = this;

		local ifaces = this.ubus.call("network.interface", "dump");


		//
		// Gather logical network information from ubus
		//

		if (type(ifaces) == "object" && type(ifaces.interface) == "array") {
			for (local ifc in ifaces.interface) {
				local net = {
					up: ifc.up,
					device: ifc.l3_device
				};

				if (type(ifc["ipv4-address"]) == "array") {
					for (local addr in ifc["ipv4-address"]) {
						net.ipaddrs = net.ipaddrs || [];
						push(net.ipaddrs, {
							family: 4,
							addr: addr.address,
							mask: to_mask(addr.mask, false),
							bits: addr.mask
						});
					}
				}

				if (type(ifc["ipv6-address"]) == "array") {
					for (local addr in ifc["ipv6-address"]) {
						net.ipaddrs = net.ipaddrs || [];
						push(net.ipaddrs, {
							family: 6,
							addr: addr.address,
							mask: to_mask(addr.mask, true),
							bits: addr.mask
						});
					}
				}

				if (type(ifc["ipv6-prefix-assignment"]) == "array") {
					for (local addr in ifc["ipv6-prefix-assignment"]) {
						if (addr["local-address"]) {
							net.ipaddrs = net.ipaddrs || [];
							push(net.ipaddrs, {
								family: 6,
								addr: addr["local-address"].address,
								mask: to_mask(addr["local-address"].mask, true),
								bits: addr["local-address"].mask
							});
						}
					}
				}

				networks[ifc.interface] = net;
			}
		}


		//
		// Read helper mapping
		//

		this.cursor.foreach("helpers", "helper", function(h) {
			local helper = self.parse_options(h, {
				name: [ "string", null, REQUIRED ],
				description: [ "string" ],
				module: [ "string" ],
				family: [ "family" ],
				proto: [ "protocol", null, PARSE_LIST | FLATTEN_LIST | NO_INVERT ],
				port: [ "port", null, NO_INVERT ]
			});

			if (helper === false) {
				warn(sprintf("Helper definition '%s' skipped due to invalid options\n", h.name || h['.name']));
				return;
			}
			else if (helper.proto.any) {
				warn(sprintf("Helper definition '%s' must not specify wildcard protocol\n", h.name || h['.name']));
				return;
			}
			else if (length(helper.proto) > 1) {
				warn(sprintf("Helper definition '%s' must not specify multiple protocols\n", h.name || h['.name']));
				return;
			}

			helper.type = replace(helper.module, /^nf_conntrack_/, "");
			helper.available = ((fs.stat("/sys/module/" + helper.module) || {}).type == "directory");

			push(helpers, helper);
		});


		//
		// Read default policies
		//

		this.cursor.foreach("firewall", "defaults", function(d) {
			if (defaults) {
				self.warn_section(d[".name"], ": ignoring duplicate defaults section");
				return;
			}

			local defs = self.parse_options(d, {
				input: [ "policy", "drop" ],
				output: [ "policy", "drop" ],
				forward: [ "policy", "drop" ],

				drop_invalid: [ "bool" ],
				tcp_reject_code: [ "reject_code", "tcp-reset" ],
				any_reject_code: [ "reject_code", "port-unreachable" ],

				syn_flood: [ "bool" ],
				synflood_protect: [ "bool" ],
				synflood_rate: [ "limit", "25/second" ],
				synflood_burst: [ "int", "50" ],

				tcp_syncookies: [ "bool", "1" ],
				tcp_ecn: [ "int" ],
				tcp_window_scaling: [ "bool", "1" ],

				accept_redirects: [ "bool" ],
				accept_source_route: [ "bool" ],

				auto_helper: [ "bool", "1" ],
				custom_chains: [ "bool", null, UNSUPPORTED ],
				disable_ipv6: [ "bool", null, UNSUPPORTED ],
				flow_offloading: [ "bool", null, UNSUPPORTED ],
				flow_offloading_hw: [ "bool", null, UNSUPPORTED ]
			});

			if (defs === false) {
				self.warn_section(d[".name"], "skipped due to invalid options");
				return;
			}

			if (defs.synflood_protect === null)
				defs.synflood_protect = defs.syn_flood;

			delete(defs, "syn_flood");

			defaults = defs;
		});


		//
		// Build list of logical zones
		//

		this.cursor.foreach("firewall", "zone", function(z) {
			local zone = self.parse_options(z, {
				enabled: [ "bool", "1" ],

				name: [ "string", null, REQUIRED ],
				family: [ "family" ],

				network: [ "device", null, PARSE_LIST ],
				device: [ "device", null, PARSE_LIST ],
				subnet: [ "network", null, PARSE_LIST ],

				input: [ "policy", defaults ? defaults.input : "drop" ],
				output: [ "policy", defaults ? defaults.output : "drop" ],
				forward: [ "policy", defaults ? defaults.forward : "drop" ],

				masq: [ "bool" ],
				masq_allow_invalid: [ "bool" ],
				masq_src: [ "network", null, PARSE_LIST ],
				masq_dest: [ "network", null, PARSE_LIST ],

				extra: [ "string", null, UNSUPPORTED ],
				extra_src: [ "string", null, UNSUPPORTED ],
				extra_dest: [ "string", null, UNSUPPORTED ],

				mtu_fix: [ "bool" ],
				custom_chains: [ "bool", null, UNSUPPORTED ],

				log: [ "int" ],
				log_limit: [ "limit", "10/second" ],

				auto_helper: [ "bool", "1" ],
				helper: [ "cthelper", null, PARSE_LIST ]
			});

			if (zone === false) {
				self.warn_section(z[".name"], "skipped due to invalid options");
				return;
			}
			else if (!zone.enabled) {
				self.warn_section(z[".name"], "is disabled, ignoring section");
				return;
			}

			if (defaults && defaults.auto_helper === false)
				zone.auto_helper = false;

			local match_devices = [];
			local related_subnets = [];
			local match_subnets, masq_src_subnets, masq_dest_subnets;

			for (local e in to_array(zone.network)) {
				if (exists(networks, e.device)) {
					local net = networks[e.device];

					if (net.device) {
						push(match_devices, {
							invert: e.invert,
							device: net.device
						});
					}

					for (local a in (net.ipaddrs || []))
						push(related_subnets, a);
				}
			}

			for (local e in to_array(zone.device))
				push(match_devices, e);

			match_subnets = subnets_split_af(zone.subnet);
			masq_src_subnets = subnets_split_af(zone.masq_src);
			masq_dest_subnets = subnets_split_af(zone.masq_dest);

			for (local a in match_subnets[0])
				push(related_subnets, a);

			for (local a in match_subnets[1])
				push(related_subnets, a);


			local match_rules = [];

			local add_rule = function(family, devices, subnets, zone) {
				local r = {};

				r.family = family;

				r.devices_pos = map(filter_pos(devices), function(d) { d.device });
				r.devices_neg = map(filter_neg(devices), function(d) { d.device });

				r.subnets_pos = map(filter_pos(subnets), self.cidr);
				r.subnets_neg = map(filter_neg(subnets), self.cidr);

				push(match_rules, r);
			};

			local family = infer_family(zone.family, [
				zone.helper, "ct helper"
			]);

			/* check if there's no AF specific bits, in this case we can do AF agnostic matching */
			if (!family && !length(match_subnets[0]) && !length(match_subnets[1])) {
				add_rule(0, match_devices, null, zone);
			}

			/* we need to emit one or two AF specific rules */
			else {
				if (family_is_ipv4(zone) && (length(match_devices) || length(match_subnets[0])))
					add_rule(4, match_devices, match_subnets[0], zone);

				if (family_is_ipv6(zone) && (length(match_devices) || length(match_subnets[1])))
					add_rule(6, match_devices, match_subnets[1], zone);
			}

			zone.match_rules = match_rules;

			if (masq_src_subnets[0]) {
				zone.masq4_src_pos = map(filter_pos(masq_src_subnets[0]), self.cidr);
				zone.masq4_src_neg = map(filter_neg(masq_src_subnets[0]), self.cidr);
			}

			if (masq_src_subnets[1]) {
				zone.masq6_src_pos = map(filter_pos(masq_src_subnets[1]), self.cidr);
				zone.masq6_src_neg = map(filter_neg(masq_src_subnets[1]), self.cidr);
			}

			if (masq_dest_subnets[0]) {
				zone.masq4_dest_pos = map(filter_pos(masq_dest_subnets[0]), self.cidr);
				zone.masq4_dest_neg = map(filter_neg(masq_dest_subnets[0]), self.cidr);
			}

			if (masq_dest_subnets[1]) {
				zone.masq6_dest_pos = map(filter_pos(masq_dest_subnets[1]), self.cidr);
				zone.masq6_dest_neg = map(filter_neg(masq_dest_subnets[1]), self.cidr);
			}

			zone.sflags = {};
			zone.sflags[zone.input] = true;

			zone.dflags = {};
			zone.dflags[zone.output] = true;
			zone.dflags[zone.forward] = true;

			zone.related_subnets = related_subnets;

			if (zone.masq || zone.masq6)
				zone.dflags.snat = true;

			if ((zone.auto_helper && !(zone.masq || zone.masq6)) || length(zone.helper)) {
				zone.dflags.helper = true;

				for (local helper in (length(zone.helper) ? zone.helper : helpers)) {
					for (local proto in helper.proto) {
						push(rules, {
							chain: "helper_" + zone.name,
							family: helper.family,
							name: helper.description || helper.name,
							proto: proto,
							src: zone,
							dports_pos: [ self.port(helper.port) ],
							target: "helper",
							set_helper: helper
						});
					}
				}
			}

			push(zones, zone);
		});


		//
		// Build list of forwardings
		//

		this.cursor.foreach("firewall", "forwarding", function(f) {
			local fwd = self.parse_options(f, {
				enabled: [ "bool", "1" ],

				name: [ "string" ],
				family: [ "family" ],

				src: [ "zone_ref", null, REQUIRED ],
				dest: [ "zone_ref", null, REQUIRED ]
			});

			if (fwd === false) {
				self.warn_section(f[".name"], "skipped due to invalid options");
				return;
			}
			else if (!fwd.enabled) {
				self.warn_section(f[".name"], "is disabled, ignoring section");
				return;
			}

			local add_rule = function(family, fwd) {
				local f = {};

				for (local key in fwd)
					f[key] = fwd[key];

				f.family = family;
				f.proto = { any: true };

				f.name = fwd.name || sprintf("Accept %s to %s forwarding",
					fwd.src.any ? "any" : fwd.src.zone.name,
					fwd.dest.any ? "any" : fwd.dest.zone.name);

				f.chain = fwd.src.any ? "forward" : sprintf("forward_%s", fwd.src.zone.name);

				if (fwd.dest.any)
					f.target = "accept";
				else
					f.jump_chain = sprintf("accept_to_%s", fwd.dest.zone.name);

				chains[f.chain] = true;

				push(rules, f);
			};


			local family = fwd.family;

			/* inherit family restrictions from related zones */
			if (family === 0 || family === null) {
				local f1 = fwd.src.zone ? fwd.src.zone.family : 0;
				local f2 = fwd.dest.zone ? fwd.dest.zone.family : 0;

				if (f1 != 0 && f2 != 0 && f1 != f2) {
					self.warn_section(f[".name"],
						sprintf("references src %s restricted to %s and dest restricted to %s, ignoring forwarding",
						        fwd.src.zone.name, self.nfproto(f1, true),
						        fwd.dest.zone.name, self.nfproto(f2, true)));

					continue;
				}
				else if (f1) {
					self.warn_section(f[".name"],
						sprintf("inheriting %s restriction from src %s",
						        self.nfproto(f1, true), fwd.src.zone.name));

					family = f1;
				}
				else if (f2) {
					self.warn_section(f[".name"],
						sprintf("inheriting %s restriction from dest %s",
						        self.nfproto(f2, true), fwd.dest.zone.name));

					family = f2;
				}
			}

			add_rule(family, fwd);

			if (fwd.dest.zone)
				fwd.dest.zone.dflags.accept = true;
		});


		//
		// Build list of rules
		//

		this.cursor.foreach("firewall", "rule", function(r) {
			local rule = self.parse_options(r, {
				enabled: [ "bool", "1" ],

				name: [ "string", self.section_id(r[".name"]) ],
				family: [ "family" ],

				src: [ "zone_ref" ],
				dest: [ "zone_ref" ],

				device: [ "device" ],
				direction: [ "direction" ],

				ipset: [ "setmatch", null, UNSUPPORTED ],
				helper: [ "cthelper" ],
				set_helper: [ "cthelper", null, NO_INVERT ],

				proto: [ "protocol", "tcpudp", PARSE_LIST | FLATTEN_LIST ],

				src_ip: [ "network", null, PARSE_LIST ],
				src_mac: [ "mac", null, PARSE_LIST ],
				src_port: [ "port", null, PARSE_LIST ],

				dest_ip: [ "network", null, PARSE_LIST ],
				dest_port: [ "port", null, PARSE_LIST ],

				icmp_type: [ "icmptype", null, PARSE_LIST ],
				extra: [ "string", null, UNSUPPORTED ],

				limit: [ "limit" ],
				limit_burst: [ "int" ],

				utc_time: [ "bool" ],
				start_date: [ "date" ],
				stop_date: [ "date" ],
				start_time: [ "time" ],
				stop_time: [ "time" ],
				weekdays: [ "weekdays" ],
				monthdays: [ "monthdays", null, UNSUPPORTED ],

				mark: [ "mark" ],
				set_mark: [ "mark", null, NO_INVERT ],
				set_xmark: [ "mark", null, NO_INVERT ],

				dscp: [ "dscp" ],
				set_dscp: [ "dscp", null, NO_INVERT ],

				target: [ "target" ]
			});

			if (rule === false) {
				self.warn_section(r[".name"], "skipped due to invalid options");
				return;
			}
			else if (!rule.enabled) {
				self.warn_section(r[".name"], "is disabled, ignoring section");
				return;
			}

			if (rule.target in ["helper", "notrack"] && (!rule.src || !rule.src.zone)) {
				self.warn_section(r[".name"], "must specify a source zone for target '" + rule.target + "'");
				return;
			}
			else if (rule.target in ["dscp", "mark"] && rule.dest) {
				self.warn_section(r[".name"], "must not specify option 'dest' for target '" + rule.target + "'");
				return;
			}
			else if (rule.target == "dscp" && !rule.set_dscp) {
				self.warn_section(r[".name"], "must specify option 'set_dscp' for target 'dscp'");
				return;
			}
			else if (rule.target == "mark" && !rule.set_mark && !rule.set_xmark) {
				self.warn_section(r[".name"], "must specify option 'set_mark' or 'set_xmark' for target 'mark'");
				return;
			}
			else if (rule.target == "helper" && !rule.set_helper) {
				self.warn_section(r[".name"], "must specify option 'set_helper' for target 'helper'");
				return;
			}

			local need_src_action_chain = function(rule) {
				return (rule.src && rule.src.zone && rule.src.zone.log && rule.target != "accept");
			};

			local add_rule = function(family, proto, saddrs, daddrs, sports, dports, icmptypes, icmpcodes, rule) {
				local r = {};

				for (local key in rule)
					r[key] = rule[key];

				r.family = family;
				r.proto = proto;
				r.has_addrs = !!(length(saddrs) || length(daddrs));
				r.has_ports = !!(length(sports) || length(dports));
				r.saddrs_pos = map(filter_pos(saddrs), self.cidr);
				r.saddrs_neg = map(filter_neg(saddrs), self.cidr);
				r.daddrs_pos = map(filter_pos(daddrs), self.cidr);
				r.daddrs_neg = map(filter_neg(daddrs), self.cidr);
				r.sports_pos = map(filter_pos(sports), self.port);
				r.sports_neg = map(filter_neg(sports), self.port);
				r.dports_pos = map(filter_pos(dports), self.port);
				r.dports_neg = map(filter_neg(dports), self.port);
				r.smacs_pos = map(filter_pos(rule.src_mac), function(m) { m.mac });
				r.smacs_neg = map(filter_neg(rule.src_mac), function(m) { m.mac });
				r.icmp_types = map(icmptypes, function(i) { (family == 4) ? i.type : i.type6 });
				r.icmp_codes = map(icmpcodes, function(ic) { sprintf('%d . %d', (family == 4) ? ic.type : ic.type6, (family == 4) ? ic.code_min : ic.code6_min) });

				if (!length(r.icmp_types))
					delete(r, "icmp_types");

				if (!length(r.icmp_codes))
					delete(r, "icmp_codes");

				if (r.set_mark) {
					r.set_xmark = {
						invert: r.set_mark.invert,
						mark:   r.set_mark.mark,
						mask:   r.set_mark.mark | r.set_mark.mask
					};

					delete(r, "set_mark");
				}

				if (r.target == "notrack") {
					r.chain = sprintf("notrack_%s", r.src.zone.name);
					r.src.zone.dflags.notrack = true;
				}
				else if (r.target == "helper") {
					r.chain = sprintf("helper_%s", r.src.zone.name);
					r.src.zone.dflags.helper = true;
				}
				else if (r.target == "mark" || r.target == "dscp") {
					if (r.src) {
						r.chain = "mangle_prerouting";
						r.src.zone.dflags[r.target] = true;
					}
					else {
						r.chain = "mangle_output";
					}
				}
				else {
					r.chain = "output";

					if (r.src) {
						if (!r.src.any)
							r.chain = sprintf("%s_%s", r.dest ? "forward" : "input", r.src.zone.name);
						else
							r.chain = r.dest ? "forward" : "input";
					}

					if (r.dest && !r.src) {
						if (!r.dest.any)
							r.chain = sprintf("output_%s", r.dest.zone.name);
						else
							r.chain = "output";
					}

					if (r.dest && !r.dest.any) {
						r.jump_chain = sprintf("%s_to_%s", r.target, r.dest.zone.name);
						r.dest.zone.dflags[r.target] = true;
					}
					else if (need_src_action_chain(r)) {
						r.jump_chain = sprintf("%s_from_%s", r.target, r.src.zone.name);
						r.src.zone.dflags[r.target] = true;
					}
					else if (r.target == "reject")
						r.jump_chain = "handle_reject";
				}

				chains[r.chain] = true;

				push(rules, r);
			};

			for (local proto in rule.proto) {
				local sip, dip, sports, dports, itypes4, itypes6;
				local family = rule.family;

				switch (proto.name) {
				case "icmp":
					itypes4 = filter(rule.icmp_type || [], family_is_ipv4);
					itypes6 = filter(rule.icmp_type || [], family_is_ipv6);
					break;

				case "ipv6-icmp":
					family = 6;
					itypes6 = filter(rule.icmp_type || [], family_is_ipv6);
					break;

				case "tcp":
				case "udp":
					sports = rule.src_port;
					dports = rule.dest_port;
					break;
				}

				family = infer_family(family, [
					rule.src, "source zone",
					rule.dest, "destination zone",
					rule.helper, "helper match",
					rule.set_helper, "helper to set"
				]);

				if (type(family) == "string") {
					self.warn_section(r[".name"], family + ", skipping");
					continue;
				}

				sip = subnets_split_af(rule.src_ip);
				dip = subnets_split_af(rule.dest_ip);

				local has_ipv4_specifics = (length(sip[0]) || length(dip[0]) || length(itypes4));
				local has_ipv6_specifics = (length(sip[1]) || length(dip[1]) || length(itypes6));

				/* if no family was configured, infer target family from IP addresses */
				if (family === null) {
					if (has_ipv4_specifics && !has_ipv6_specifics)
						family = 4;
					else if (has_ipv6_specifics && !has_ipv4_specifics)
						family = 6;
					else
						family = 0;
				}

				/* check if there's no AF specific bits, in this case we can do an AF agnostic rule */
				if (!family && rule.target != "dscp" && !has_ipv4_specifics && !has_ipv6_specifics) {
					add_rule(0, proto, null, null, sports, dports, null, null, rule);
				}

				/* we need to emit one or two AF specific rules */
				else {
					if (family == 0 || family == 4) {
						local icmp_types = filter(itypes4, function(i) { i.code_min == 0 && i.code_max == 0xFF });
						local icmp_codes = filter(itypes4, function(i) { i.code_min != 0 || i.code_max != 0xFF });

						if (length(icmp_types) || (!length(icmp_types) && !length(icmp_codes)))
							add_rule(4, proto, sip[0], dip[0], sports, dports, icmp_types, null, rule);

						if (length(icmp_codes))
							add_rule(4, proto, sip[0], dip[0], sports, dports, null, icmp_codes, rule);
					}

					if (family == 0 || family == 6) {
						local icmp_types = filter(itypes6, function(i) { i.code_min == 0 && i.code_max == 0xFF });
						local icmp_codes = filter(itypes6, function(i) { i.code_min != 0 || i.code_max != 0xFF });

						if (length(icmp_types) || (!length(icmp_types) && !length(icmp_codes)))
							add_rule(6, proto, sip[1], dip[1], sports, dports, icmp_types, null, rule);

						if (length(icmp_codes))
							add_rule(6, proto, sip[1], dip[1], sports, dports, null, icmp_codes, rule);
					}
				}
			}
		});


		//
		// Build list of redirects
		//

		this.cursor.foreach("firewall", "redirect", function(r) {
			local redir = self.parse_options(r, {
				enabled: [ "bool", "1" ],

				name: [ "string", self.section_id(r[".name"]) ],
				family: [ "family", "4" ],

				src: [ "zone_ref" ],
				dest: [ "zone_ref" ],

				ipset: [ "setmatch", null, UNSUPPORTED ],
				helper: [ "cthelper", null, NO_INVERT ],

				proto: [ "protocol", "tcpudp", PARSE_LIST | FLATTEN_LIST ],

				src_ip: [ "network" ],
				src_mac: [ "mac", null, PARSE_LIST ],
				src_port: [ "port" ],

				src_dip: [ "network" ],
				src_dport: [ "port" ],

				dest_ip: [ "network" ],
				dest_port: [ "port" ],

				extra: [ "string", null, UNSUPPORTED ],

				limit: [ "limit" ],
				limit_burst: [ "int" ],

				utc_time: [ "bool" ],
				start_date: [ "date" ],
				stop_date: [ "date" ],
				start_time: [ "time" ],
				stop_time: [ "time" ],
				weekdays: [ "weekdays" ],
				monthdays: [ "monthdays", null, UNSUPPORTED ],

				mark: [ "mark" ],

				reflection: [ "bool", "1" ],
				reflection_src: [ "reflection_source", "internal" ],

				reflection_zone: [ "zone_ref", null, PARSE_LIST ],

				target: [ "target", "dnat" ]
			});

			if (redir === false) {
				self.warn_section(r[".name"], "skipped due to invalid options");
				return;
			}
			else if (!redir.enabled) {
				self.warn_section(r[".name"], "is disabled, ignoring section");
				return;
			}

			if (!(redir.target in ["dnat", "snat"])) {
				self.warn_section(r[".name"], "has invalid target specified, defaulting to dnat");
				redir.target = "dnat";
			}

			local resolve_dest = function(redir) {
				for (local zone in zones) {
					for (local addr in zone.related_subnets) {
						if (redir.dest_ip.family != addr.family)
							continue;

						local a = apply_mask(redir.dest_ip.addr, addr.bits);
						local b = apply_mask(addr.addr, addr.bits);

						if (a != b)
							continue;

						redir.dest = {
							any: false,
							zone: zone
						};

						return true;
					}
				}

				return false;
			};

			if (redir.target == "dnat") {
				if (!redir.src)
					return self.warn_section(r[".name"], "has no source specified");
				else if (redir.src.any)
					return self.warn_section(r[".name"], "must not have source '*' for dnat target");
				else if (redir.dest_ip && redir.dest_ip.invert)
					return self.warn_section(r[".name"], "must not specify a negated 'dest_ip' value");

				if (!redir.dest && redir.dest_ip && resolve_dest(redir))
					self.warn_section(r[".name"], "does not specify a destination, assuming '" + redir.dest.zone.name + "'");

				if (!redir.dest_port)
					redir.dest_port = redir.src_dport;

				if (redir.reflection && redir.dest && redir.dest.zone && redir.src.zone.masq) {
					redir.dest.zone.dflags.accept = true;
					redir.dest.zone.dflags.dnat = true;
					redir.dest.zone.dflags.snat = true;
				}

				if (redir.helper)
					redir.src.zone.dflags.helper = true;

				redir.src.zone.dflags[redir.target] = true;
			}
			else {
				if (!redir.dest)
					return self.warn_section(r[".name"], "has no destination specified");
				else if (redir.dest.any)
					return self.warn_section(r[".name"], "must not have destination '*' for snat target");
				else if (!redir.src_dip)
					return self.warn_section(r[".name"], "has no 'src_dip' option specified");
				else if (redir.src_dip.invert)
					return self.warn_section(r[".name"], "must not specify a negated 'src_dip' value");
				else if (redir.src_mac)
					return self.warn_section(r[".name"], "must not use 'src_mac' option for snat target");
				else if (redir.helper)
					return self.warn_section(r[".name"], "must not use 'helper' option for snat target");

				redir.dest.zone.dflags[redir.target] = true;
			}


			local add_rule = function(family, proto, saddrs, daddrs, raddrs, sport, dport, rport, redir) {
				local r = {};

				for (local key in redir)
					r[key] = redir[key];

				r.family = family;
				r.proto = proto;
				r.has_addrs = !!(length(saddrs) || length(daddrs));
				r.has_ports = !!(sport || dport || rport);
				r.saddrs_pos = map(filter_pos(saddrs), self.cidr);
				r.saddrs_neg = map(filter_neg(saddrs), self.cidr);
				r.daddrs_pos = map(filter_pos(daddrs), self.cidr);
				r.daddrs_neg = map(filter_neg(daddrs), self.cidr);
				r.sports_pos = map(filter_pos(to_array(sport)), self.port);
				r.sports_neg = map(filter_neg(to_array(sport)), self.port);
				r.dports_pos = map(filter_pos(to_array(dport)), self.port);
				r.dports_neg = map(filter_neg(to_array(dport)), self.port);
				r.smacs_pos = map(filter_pos(redir.src_mac), function(m) { m.mac });
				r.smacs_neg = map(filter_neg(redir.src_mac), function(m) { m.mac });

				r.raddr = raddrs ? raddrs[0] : null;
				r.rport = rport;

				switch (r.target) {
				case "dnat":
					r.chain = sprintf("dstnat_%s", r.src.zone.name);

					if (!r.raddr)
						r.target = "redirect";

					break;

				case "snat":
					r.chain = sprintf("srcnat_%s", r.dest.zone.name);
					break;
				}

				chains[r.chain] = true;

				push(redirects, r);
			};

			local to_hostaddr = function(a) {
				local bits = (a.family == 4) ? 32 : 128;

				return {
					family: a.family,
					addr: apply_mask(a.addr, bits),
					bits: bits
				};
			};

			for (local proto in redir.proto) {
				local sip, dip, rip, iip, eip, refip, sport, dport, rport;
				local family = redir.family;

				if (proto.name == "ipv6-icmp")
					family = 6;

				family = infer_family(family, [
					redir.src, "source zone",
					redir.dest, "destination zone",
					redir.helper, "helper match"
				]);

				if (type(family) == "string") {
					self.warn_section(r[".name"], family + ", skipping");
					continue;
				}

				switch (redir.target) {
				case "dnat":
					sip = subnets_split_af(redir.src_ip);
					dip = subnets_split_af(redir.src_dip);
					rip = subnets_split_af(redir.dest_ip);

					switch (proto.name) {
					case "tcp":
					case "udp":
						sport = redir.src_port;
						dport = redir.src_dport;
						rport = redir.dest_port;
						break;
					}

					/* build reflection rules */
					if (redir.reflection && (length(rip[0]) || length(rip[1])) &&
					    redir.src && redir.src.zone && redir.src.zone[family == 4 ? "masq" : "masq6"] &&
					    redir.dest && redir.dest.zone) {

						local refredir = {
							name: redir.name + " (reflection)",

							helper: redir.helper,

							// XXX: this likely makes no sense for reflection rules
							//src_mac: redir.src_mac,

							limit: redir.limit,
							limit_burst: redir.limit_burst,

							start_date: redir.start_date,
							stop_date: redir.stop_date,
							start_time: redir.start_time,
							stop_time: redir.stop_time,
							weekdays: redir.weekdays,

							mark: redir.mark
						};

						local eaddrs = subnets_split_af(length(dip) ? dip : { addrs: redir.src.zone.related_subnets });
						local rzones = length(redir.reflection_zone) ? redir.reflection_zone : [ redir.dest ];

						for (local rzone in rzones) {
							if (!is_family(rzone, family)) {
								self.warn_section(r[".name"],
									sprintf("is restricted to IPv%d but referenced reflection zone is IPv%d only, skipping",
									        family, rzone.family));
								continue;
							}

							local iaddrs = subnets_split_af({ addrs: rzone.zone.related_subnets });
							local refaddrs = (redir.reflection_src == "internal") ? iaddrs : eaddrs;

							refaddrs = [
								map(refaddrs[0], to_hostaddr),
								map(refaddrs[1], to_hostaddr)
							];

							eaddrs = [
								map(eaddrs[0], to_hostaddr),
								map(eaddrs[1], to_hostaddr)
							];

							for (local i = 0; i <= 1; i++) {
								if (length(rip[i])) {
									refredir.src = rzone;
									refredir.dest = null;
									refredir.target = "dnat";
									add_rule(i ? 6 : 4, proto, iaddrs[i], eaddrs[i], rip[i], sport, dport, rport, refredir);

									for (local refaddr in refaddrs[i]) {
										refredir.src = null;
										refredir.dest = rzone;
										refredir.target = "snat";
										add_rule(i ? 6 : 4, proto, iaddrs[i], rip[i], [ refaddr ], null, rport, null, refredir);
									}
								}
							}
						}
					}


					break;

				case "snat":
					sip = subnets_split_af(redir.src_ip);
					dip = subnets_split_af(redir.dest_ip);
					rip = subnets_split_af(redir.src_dip);

					switch (proto.name) {
					case "tcp":
					case "udp":
						sport = redir.src_port;
						dport = redir.dest_port;
						rport = redir.src_dport;
						break;
					}

					break;
				}

				if (length(rip[0]) > 1 || length(rip[1]) > 1)
					self.warn_section(r[".name"], "specifies multiple rewrite addresses, using only first one");

				/* check if there's no AF specific bits, in this case we can do an AF agnostic rule */
				if (!family && !length(sip[0]) && !length(sip[1]) && !length(dip[0]) && !length(dip[1]) && !length(rip[0]) && !length(rip[1])) {
					add_rule(0, proto, null, null, null, sport, dport, rport, redir);
				}

				/* we need to emit one or two AF specific rules */
				else {
					if (family == 0 || family == 4)
						add_rule(4, proto, sip[0], dip[0], rip[0], sport, dport, rport, redir);

					if (family == 0 || family == 6)
						add_rule(6, proto, sip[1], dip[1], rip[1], sport, dport, rport, redir);
				}
			}
		});


		//
		// Build list of snats
		//

		this.cursor.foreach("firewall", "nat", function(n) {
			local snat = self.parse_options(n, {
				enabled: [ "bool", "1" ],

				name: [ "string", self.section_id(n[".name"]) ],
				family: [ "family", "4" ],

				src: [ "zone_ref" ],
				device: [ "string" ],

				ipset: [ "setmatch", null, UNSUPPORTED ],

				proto: [ "protocol", "all", PARSE_LIST | FLATTEN_LIST ],

				src_ip: [ "network" ],
				src_port: [ "port" ],

				snat_ip: [ "network", null, NO_INVERT ],
				snat_port: [ "port", null, NO_INVERT ],

				dest_ip: [ "network" ],
				dest_port: [ "port" ],

				extra: [ "string", null, UNSUPPORTED ],

				limit: [ "limit" ],
				limit_burst: [ "int" ],

				connlimit_ports: [ "bool" ],

				utc_time: [ "bool" ],
				start_date: [ "date" ],
				stop_date: [ "date" ],
				start_time: [ "time" ],
				stop_time: [ "time" ],
				weekdays: [ "weekdays" ],
				monthdays: [ "monthdays", null, UNSUPPORTED ],

				mark: [ "mark" ],

				target: [ "target", "masquerade" ]
			});

			if (snat === false) {
				self.warn_section(n[".name"], "skipped due to invalid options");
				return;
			}
			else if (!snat.enabled) {
				self.warn_section(n[".name"], "is disabled, ignoring section");
				return;
			}

			if (!(snat.target in ["accept", "snat", "masquerade"])) {
				self.warn_section(n[".name"], "has invalid target specified, defaulting to masquerade");
				snat.target = "masquerade";
			}

			if (snat.target == "snat" && !snat.snat_ip && !snat.snat_port) {
				self.warn_section(n[".name"], "needs either 'snat_ip' or 'snat_port' for target snat, ignoring section");
				return;
			}
			else if (snat.target != "snat" && snat.snat_ip) {
				self.warn_section(n[".name"], "must not use 'snat_ip' for non-snat target, ignoring section");
				return;
			}
			else if (snat.target != "snat" && snat.snat_port) {
				self.warn_section(n[".name"], "must not use 'snat_port' for non-snat target, ignoring section");
				return;
			}

			if ((snat.snat_port || snat.src_port || snat.dest_port) && !ensure_tcpudp(snat.proto)) {
				self.warn_section(n[".name"], "specifies ports but no UDP/TCP protocol, ignoring section");
				return;
			}

			if (snat.src && snat.src.zone)
				snat.src.zone.dflags.snat = true;

			local add_rule = function(family, proto, saddrs, daddrs, raddrs, sport, dport, rport, snat) {
				local n = {};

				for (local key in snat)
					n[key] = snat[key];

				n.family = family;
				n.proto = proto;
				n.has_addrs = !!(length(saddrs) || length(daddrs) || length(raddrs));
				n.has_ports = !!(sport || dport);
				n.saddrs_pos = map(filter_pos(saddrs), self.cidr);
				n.saddrs_neg = map(filter_neg(saddrs), self.cidr);
				n.daddrs_pos = map(filter_pos(daddrs), self.cidr);
				n.daddrs_neg = map(filter_neg(daddrs), self.cidr);
				n.sports_pos = map(filter_pos(to_array(sport)), self.port);
				n.sports_neg = map(filter_neg(to_array(sport)), self.port);
				n.dports_pos = map(filter_pos(to_array(dport)), self.port);
				n.dports_neg = map(filter_neg(to_array(dport)), self.port);

				n.raddr = raddrs ? raddrs[0] : null;
				n.rport = rport;

				n.chain = (snat.src && snat.src.zone) ? sprintf("srcnat_%s", snat.src.zone.name) : "srcnat";

				chains[n.chain] = true;

				push(redirects, n);
			};

			for (local proto in snat.proto) {
				local sip, dip, rip, sport, dport, rport;
				local family = snat.family;

				sip = subnets_split_af(snat.src_ip);
				dip = subnets_split_af(snat.dest_ip);
				rip = subnets_split_af(snat.snat_ip);

				switch (proto.name) {
				case "tcp":
				case "udp":
					sport = snat.src_port;
					dport = snat.dest_port;
					rport = snat.snat_port;
					break;
				}

				if (length(rip[0]) > 1 || length(rip[1]) > 1)
					self.warn_section(n[".name"], "specifies multiple rewrite addresses, using only first one");

				/* inherit family restrictions from related zones */
				if (family === 0 || family === null) {
					local f = (rule.src && rule.src.zone) ? rule.src.zone.family : 0;

					if (f) {
						self.warn_section(r[".name"],
							sprintf("inheriting %s restriction from src %s",
							        self.nfproto(f1, true), rule.src.zone.name));

						family = f;
					}
				}

				/* if no family was configured, infer target family from IP addresses */
				if (family === null) {
					if ((length(sip[0]) || length(dip[0]) || length(rip[0])) && !length(sip[1]) && !length(dip[1]) && !length(rip[1]))
						family = 4;
					else if ((length(sip[1]) || length(dip[1]) || length(rip[1])) && !length(sip[0]) && !length(dip[0]) && !length(rip[0]))
						family = 6;
					else
						family = 0;
				}

				/* check if there's no AF specific bits, in this case we can do an AF agnostic rule */
				if (!family && !length(sip[0]) && !length(sip[1]) && !length(dip[0]) && !length(dip[1]) && !length(rip[0]) && !length(rip[1])) {
					add_rule(0, proto, null, null, null, sport, dport, rport, snat);
				}

				/* we need to emit one or two AF specific rules */
				else {
					if (family == 0 || family == 4)
						add_rule(4, proto, sip[0], dip[0], rip[0], sport, dport, rport, snat);

					if (family == 0 || family == 6)
						add_rule(6, proto, sip[1], dip[1], rip[1], sport, dport, rport, snat);
				}
			}
		});
	},

	get: function(sid, opt) {
		return this.cursor.get("firewall", sid, opt);
	},

	get_all: function(sid) {
		return this.cursor.get_all("firewall", sid);
	},

	parse_options: function(s, spec) {
		local rv = {};

		for (local key in spec) {
			local datatype = "parse_" + spec[key][0],
			      defval = spec[key][1],
			      flags = spec[key][2] || 0,
			      parsefn = (flags & PARSE_LIST) ? "parse_list" : "parse_opt";

			local res = this[parsefn](s, key, datatype, defval, flags);

			if (res !== res)
				return false;

			if (type(res) == "object" && res.invert && (flags & NO_INVERT)) {
				this.warn_section(s[".name"], "option '" + key + '" must not be negated');
				return false;
			}

			if (res != null) {
				if (flags & UNSUPPORTED)
					this.warn_section(s[".name"], "option '" + key + "' is not supported by fw4");
				else
					rv[key] = res;
			}
		}

		for (local opt in s) {
			if (index(opt, '.') != 0 && !exists(spec, opt)) {
				this.warn_section(s[".name"], "specifies unknown option '" + opt + "'");
				return false;
			}
		}

		return rv;
	},

	parse_subnet: function(subnet) {
		local parts = split(subnet, "/");

		switch (length(parts)) {
		case 2:
			local a = iptoarr(parts[0]);
			local m = iptoarr(parts[1]);
			local b;

			if (!a)
				return null;

			if (m) {
				if (length(a) != length(m))
					return null;

				b = to_bits(parts[1]);

				if (b == null)
					return null;

				m = arrtoip(m);
			}
			else {
				b = +parts[1];

				if (type(b) != "int")
					return null;

				m = to_mask(b, length(a) == 16);
			}

			return [{
				family: (length(a) == 16) ? 6 : 4,
				addr: arrtoip(a),
				mask: m,
				bits: b
			}];

		case 1:
			parts = split(parts[0], "-");

			switch (length(parts)) {
			case 2:
				local a = iptoarr(parts[0]);
				local b = iptoarr(parts[1]);

				if (a && b && length(a) == length(b)) {
					return [{
						family: (length(a) == 16) ? 6 : 4,
						addr: arrtoip(a),
						addr2: arrtoip(b),
						range: true
					}];
				}

				break;

			case 1:
				local a = iptoarr(parts[0]);

				if (a) {
					return [{
						family: (length(a) == 16) ? 6 : 4,
						addr: arrtoip(a),
						mask: to_mask(length(a) * 8, length(a) == 16),
						bits: length(a) * 8
					}];
				}

				local n = networks[parts[0]];

				if (n) {
					local rv = [];

					for (local i = 0; i < length(n.ipaddrs); i++)
						push(rv, n.ipaddrs[i]);

					return rv;
				}
			}
		}

		return null;
	},

	parse_enum: function(val, choices) {
		if (type(val) == "string") {
			val = lc(val);

			for (local i = 0; i < length(choices); i++)
				if (substr(choices[i], 0, length(val)) == val)
					return choices[i];
		}

		return null;
	},

	section_id: function(sid) {
		local s = this.get_all(sid);

		if (!s)
			return null;

		if (s[".anonymous"]) {
			local c = 0;

			this.cursor.foreach("firewall", s[".type"], function(ss) {
				if (ss[".name"] == s[".name"])
					return false;

				c++;
			});

			return sprintf("@%s[%d]", s[".type"], c);
		}

		return s[".name"];
	},

	warn_section: function(sid, msg) {
		local n = this.get(sid, "name");

		if (n)
			warn(sprintf("Section %s (%s) %s\n", this.section_id(sid), n, msg));
		else
			warn(sprintf("Section %s %s\n", this.section_id(sid), msg));
	},

	parse_policy: function(val) {
		return this.parse_enum(val, [
			"accept",
			"reject",
			"drop"
		]);
	},

	parse_bool: function(val) {
		if (val == "1" || val == "on" || val == "true" || val == "yes")
			return true;
		else if (val == "0" || val == "off" || val == "false" || val == "no")
			return false;
		else
			return null;
	},

	parse_family: function(val) {
		if (val == 'any' || val == 'all' || val == '*')
			return 0;
		else if (val == 'inet' || index(val, '4') > -1)
			return 4;
		else if (index(val, '6') > -1)
			return 6;

		return null;
	},

	parse_zone_ref: function(val) {
		if (val == null)
			return null;

		if (val == '*')
			return { any: true };

		for (local zone in zones) {
			if (zone.name == val) {
				return {
					any: false,
					zone: zone
				};
			}
		}

		return null;
	},

	parse_device: function(val) {
		local rv = this.parse_invert(val);

		if (!rv)
			return null;

		if (rv.val == '*')
			rv.any = true;
		else
			rv.device = rv.val;

		return rv;
	},

	parse_direction: function(val) {
		if (val == 'in' || val == 'ingress')
			return true;
		else if (val == 'out' || val == 'egress')
			return false;

		return null;
	},

	parse_setmatch: function(val) {
		local rv = this.parse_invert(val);

		if (!rv)
			return null;

		rv.val = trim(replace(rv.val, /^[^ \t]+/, function(m) {
			rv.name = m;
			return '';
		}));

		local dir = split(rv.val, /[ \t,]/);

		for (local i = 0; i < 3 && i < length(dir); i++) {
			if (dir[i] == "dst" || dir[i] == "dest") {
				rv.dir = rv.dir || [];
				rv.dir[i] = "dst";
			}
			else if (dir[i] == "src") {
				rv.dir = rv.dir || [];
				rv.dir[i] = "src";
			}
		}

		return length(rv.name) ? rv : null;
	},

	parse_cthelper: function(val) {
		local rv = this.parse_invert(val);

		if (!rv)
			return null;

		local helper = filter(helpers, function(h) { h.name == rv.val })[0];

		if (!helper)
			return null;

		for (local k in helper)
			rv[k] = helper[k];

		return rv;
	},

	parse_protocol: function(val) {
		local p = this.parse_invert(val);

		if (!p)
			return null;

		p.val = lc(p.val);

		switch (p.val) {
		case 'all':
		case 'any':
		case '*':
			p.any = true;
			break;

		case '1':
		case 'icmp':
			p.name = 'icmp';
			break;

		case '58':
		case 'icmpv6':
		case 'ipv6-icmp':
			p.name = 'ipv6-icmp';
			break;

		case 'tcpudp':
			return [
				{ invert: p.invert, name: 'tcp' },
				{ invert: p.invert, name: 'udp' }
			];

		case '6':
			p.name = 'tcp';
			break;

		case '17':
			p.name = 'udp';
			break;

		default:
			p.name = p.val;
		}

		return (p.any || length(p.name)) ? p : null;
	},

	parse_mac: function(val) {
		local mac = this.parse_invert(val);
		local m = mac ? match(mac.val, /^([0-9a-f]{1,2})[:-]([0-9a-f]{1,2})[:-]([0-9a-f]{1,2})[:-]([0-9a-f]{1,2})[:-]([0-9a-f]{1,2})[:-]([0-9a-f]{1,2})$/i) : null;

		if (!m)
			return null;

		mac.mac = sprintf('%02x:%02x:%02x:%02x:%02x:%02x',
		                  hex(m[1]), hex(m[2]), hex(m[3]),
		                  hex(m[4]), hex(m[5]), hex(m[6]));

		return mac;
	},

	parse_port: function(val) {
		local port = this.parse_invert(val);
		local m = port ? match(port.val, /^([0-9]{1,5})([-:]([0-9]{1,5}))?$/i) : null;

		if (!m)
			return null;

		if (m[3]) {
			local min_port = +m[1];
			local max_port = +m[3];

			if (min_port > max_port ||
			    min_port < 0 || max_port < 0 ||
			    min_port > 65535 || max_port > 65535)
				return null;

			port.min = min_port;
			port.max = max_port;
		}
		else {
			local pn = +m[1];

			if (pn != pn || pn < 0 || pn > 65535)
				return null;

			port.min = pn;
			port.max = pn;
		}

		return port;
	},

	parse_network: function(val) {
		local rv = this.parse_invert(val);

		if (!rv)
			return null;

		local nets = this.parse_subnet(rv.val);

		if (nets === null)
			return false;

		for (local addr in nets) {
			rv.addrs = rv.addrs || [];
			push(rv.addrs, addr);
		}

		return rv;
	},

	parse_icmptype: function(val) {
		local rv = {};

		if (exists(ipv4_icmptypes, val)) {
			rv.family = 4;

			rv.type = ipv4_icmptypes[val][0];
			rv.code_min = ipv4_icmptypes[val][1];
			rv.code_max = ipv4_icmptypes[val][2];
		}

		if (exists(ipv6_icmptypes, val)) {
			rv.family = rv.family ? 0 : 6;

			rv.type6 = ipv6_icmptypes[val][0];
			rv.code6_min = ipv6_icmptypes[val][1];
			rv.code6_max = ipv6_icmptypes[val][2];
		}

		if (!exists(rv, "family")) {
			local m = match(val, /^([0-9]+)(\/([0-9]+))?$/);

			if (!m)
				return null;

			if (m[3]) {
				rv.type = +m[1];
				rv.code_min = +m[3];
				rv.code_max = rv.code_min;
			}
			else {
				rv.type = +m[1];
				rv.code_min = 0;
				rv.code_max = 0xFF;
			}

			if (rv.type > 0xFF || rv.code_min > 0xFF || rv.code_max > 0xFF)
				return null;

			rv.family = 0;

			rv.type6 = rv.type;
			rv.code6_min = rv.code_min;
			rv.code6_max = rv.code_max;
		}

		return rv;
	},

	parse_invert: function(val) {
		if (val == null)
			return null;

		local rv = { invert: false };

		rv.val = trim(replace(val, /^[ \t]*!/, function() {
			rv.invert = true;
			return '';
		}));

		return length(rv.val) ? rv : null;
	},

	parse_limit: function(val) {
		local rv = this.parse_invert(val);
		local m = rv ? match(rv.val, /^([0-9]+)(\/([a-z]+))?$/) : null;

		if (!m)
			return null;

		local n = +m[1];
		local u = m[3] ? this.parse_enum(m[3], [ "second", "minute", "hour", "day" ]) : "second";

		if (!u)
			return null;

		rv.rate = n;
		rv.unit = u;

		return rv;
	},

	parse_int: function(val) {
		local n = +val;

		return (n == n) ? n : null;
	},

	parse_date: function(val) {
		local m = match(val, /^([0-9-]+)T([0-9:]+)$/);
		local d = m ? match(m[1], /^([0-9]{1,4})(-([0-9]{1,2})(-([0-9]{1,2}))?)?$/) : null;
		local t = this.parse_time(m[2]);

		d[3] = d[3] || 1;
		d[5] = d[5] || 1;

		if (d == null || d[1] < 1970 || d[1] > 2038 || d[3] < 1 || d[3] > 12 || d[5] < 1 || d[5] > 31)
			return null;

		if (m[2] && !t)
			return null;

		return {
			year:  +d[1],
			month: +d[3],
			day:   +d[5],
			hour:  t ? +t[1] : 0,
			min:   t ? +t[3] : 0,
			sec:   t ? +t[5] : 0
		};
	},

	parse_time: function(val) {
		local t = match(val, /^([0-9]{1,2})(:([0-9]{1,2})(:([0-9]{1,2}))?)?$/);

		if (t == null || t[1] > 23 || t[3] > 59 || t[5] > 59)
			return null;

		return {
			hour: +t[1],
			min:  +t[3],
			sec:  +t[5]
		};
	},

	parse_weekdays: function(val) {
		local rv = this.parse_invert(val);

		if (!rv)
			return null;

		for (local day in to_array(rv.val)) {
			day = this.parse_enum(day, [
				"monday",
				"tuesday",
				"wednesday",
				"thursday",
				"friday",
				"saturday",
				"sunday"
			]);

			if (!day)
				return null;

			rv.days = rv.days || {};
			rv.days[day] = true;
		}

		rv.days = keys(rv.days);

		return rv.days ? rv : null;
	},

	parse_monthdays: function(val) {
		local rv = this.parse_invert(val);

		if (!rv)
			return null;

		for (local day in to_array(rv.val)) {
			day = +day;

			if (day < 1 || day > 31)
				return null;

			rv.days = rv.days || [];
			rv.days[day] = true;
		}

		return rv.days ? rv : null;
	},

	parse_mark: function(val) {
		local rv = this.parse_invert(val);
		local m = rv ? match(rv.val, /^(0?x?[0-9a-f]+)(\/(0?x?[0-9a-f]+))?$/i) : null;

		if (!m)
			return null;

		local n = +m[1];

		if (n != n || n > 0xFFFFFFFF)
			return null;

		rv.mark = n;
		rv.mask = 0xFFFFFFFF;

		if (m[3]) {
			n = +m[3];

			if (n != n || n > 0xFFFFFFFF)
				return null;

			rv.mask = n;
		}

		return rv;
	},

	parse_dscp: function(val) {
		local rv = this.parse_invert(val);

		if (!rv)
			return null;

		rv.val = uc(rv.val);

		if (exists(dscp_classes, rv.val)) {
			rv.dscp = dscp_classes[rv.val];
		}
		else {
			local n = +val;

			if (n != n || n < 0 || n > 0x3F)
				return null;

			rv.dscp = n;
		}

		return rv;
	},

	parse_target: function(val) {
		return this.parse_enum(val, [
			"accept",
			"reject",
			"drop",
			"notrack",
			"helper",
			"mark",
			"dscp",
			"dnat",
			"snat",
			"masquerade",
			"accept",
			"reject",
			"drop"
		]);
	},

	parse_reject_code: function(val) {
		return this.parse_enum(val, [
			"tcp-reset",
			"port-unreachable",
			"admin-prohibited",
			"host-unreachable",
			"no-route"
		]);
	},

	parse_reflection_source: function(val) {
		return this.parse_enum(val, [
			"internal",
			"external"
		]);
	},

	parse_string: function(val) {
		return "" + val;
	},

	parse_opt: function(s, opt, fn, defval, flags) {
		local val = s[opt];

		if (val == null) {
			if (flags & REQUIRED) {
				this.warn_section(sid, "option '" + opt + "' is mandatory but not set");
				return NaN;
			}

			val = defval;
		}

		if (type(val) == "array") {
			this.warn_section(sid, "option '" + opt + "' must not be a list");
			return NaN;
		}
		else if (val == null) {
			return null;
		}

		local res = this[fn](val);

		if (res === null) {
			this.warn_section(sid, "option '" + opt + "' specifies invalid value '" + val + "'");
			return NaN;
		}

		return res;
	},

	parse_list: function(s, opt, fn, defval, flags) {
		local val = s[opt];
		local rv = [];

		if (val == null) {
			if (flags & REQUIRED) {
				this.warn_section(sid, "option '" + opt + "' is mandatory but not set");
				return NaN;
			}

			val = defval;
		}

		for (local val in to_array(val)) {
			local res = this[fn](val);

			if (res === null) {
				this.warn_section(sid, "option '" + opt + "' specifies invalid value '" + val + "'");
				return NaN;
			}

			if (flags & FLATTEN_LIST)
				for (res in to_array(res))
					push(rv, res);
			else
				push(rv, res);
		}

		return length(rv) ? rv : null;
	},

	at_least_once: function(v) {
		if (type(v) == "array")
			return length(v) ? v : [ null ];

		return [ v != null ? v : null ];
	},

	quote: function(s, force) {
		if (force === true || !match(s, /^([0-9A-Fa-f:.\/]+)( \. [0-9A-Fa-f:.\/]+)*$/))
			return sprintf('"%s"', replace(s + "", /(["\\])/g, '\\$1'));

		return s;
	},

	cidr: function(a) {
		if (a.range)
			return sprintf("%s-%s", a.addr, a.addr2);

		if ((a.family == 4 && a.bits == 32) ||
		    (a.family == 6 && a.bits == 128))
		    return a.addr;

		return sprintf("%s/%d", apply_mask(a.addr, a.bits), a.bits);
	},

	host: function(a) {
		return a.range
			? sprintf("%s-%s", a.addr, a.addr2)
			: apply_mask(a.addr, a.bits);
	},

	port: function(p) {
		if (p.min == p.max)
			return sprintf('%d', p.min);

		return sprintf('%d-%d', p.min, p.max);
	},

	set: function(v) {
		v = to_array(v);

		if (length(v) != 1)
			return sprintf('{ %s }', join(', ', map(v, this.quote)));

		return this.quote(v[0]);
	},

	ipproto: function(family) {
		switch (family) {
		case 4:
			return "ip";

		case 6:
			return "ip6";
		}
	},

	nfproto: function(family, human_readable) {
		switch (family) {
		case 4:
			return human_readable ? "IPv4" : "ipv4";

		case 6:
			return human_readable ? "IPv6" : "ipv6";

		default:
			return human_readable ? "IPv4/IPv6" : null;
		}
	},

	datetime: function(stamp) {
		return sprintf('"%04d-%02d-%02d %02d:%02d:%02d"',
		               stamp.year, stamp.month, stamp.day,
		               stamp.hour, stamp.min, stamp.sec);
	},

	date: function(stamp) {
		return sprintf('"%04d-%02d-%02d"', stamp.year, stamp.month, stamp.day);
	},

	time: function(stamp) {
		return sprintf('"%02d:%02d:%02d"', stamp.hour, stamp.min, stamp.sec);
	},

	hex: function(n) {
		return sprintf('0x%x', n);
	},

	is_loopback_dev: function(dev) {
		local fd = fs.open(sprintf("/sys/class/net/%s/flags", dev), "r");

		if (!fd)
			return false;

		local flags = +fd.read("line");

		fd.close();

		return !!(flags & 0x8);
	},

	is_loopback_addr: function(addr) {
		return (index(addr, "127.") == 0 || addr == "::1" || addr == "::1/128");
	},

	filter_loopback_devs: function(devs, invert) {
		local self = this;
		return filter(devs, function(d) { self.is_loopback_dev(d) == invert });
	},

	filter_loopback_addrs: function(addrs, invert) {
		local self = this;
		return filter(addrs, function(a) { self.is_loopback_addr(a) == invert });
	},


	input_policy: function(reject_as_drop) {
		return (!reject_as_drop || defaults.input != 'reject') ? defaults.input : 'drop';
	},

	output_policy: function(reject_as_drop) {
		return (!reject_as_drop || defaults.output != 'reject') ? defaults.output : 'drop';
	},

	forward_policy: function(reject_as_drop) {
		return (!reject_as_drop || defaults.forward != 'reject') ? defaults.forward : 'drop';
	},

	default_option: function(flag) {
		return defaults[flag];
	},

	helpers: function() {
		return helpers;
	},

	zones: function() {
		return zones;
	},

	rules: function(chain) {
		return filter(rules, function(r) { r.chain == chain });
	},

	redirects: function(chain) {
		return filter(redirects, function(r) { r.chain == chain });
	},

	uses_chain: function(chain) {
		return !!chains[chain];
	}
};
