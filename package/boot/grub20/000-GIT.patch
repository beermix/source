diff --color -Naur grub-2.04-orig/gentpl.py grub-2.04/gentpl.py
--- grub-2.04-orig/gentpl.py	2021-01-29 19:34:15.143012561 +0300
+++ grub-2.04/gentpl.py	2021-01-29 19:37:38.157399341 +0300
@@ -766,7 +766,7 @@
 if test x$(TARGET_APPLE_LINKER) = x1; then \
   $(MACHO2IMG) $< $@; \
 else \
-  $(TARGET_OBJCOPY) $(""" + cname(defn) + """_OBJCOPYFLAGS) --strip-unneeded -R .note -R .comment -R .note.gnu.build-id -R .MIPS.abiflags -R .reginfo -R .rel.dyn -R .note.gnu.gold-version -R .ARM.exidx $< $@; \
+  $(TARGET_OBJCOPY) $(""" + cname(defn) + """_OBJCOPYFLAGS) --strip-unneeded -R .note -R .comment -R .note.gnu.build-id -R .MIPS.abiflags -R .reginfo -R .rel.dyn -R .note.gnu.gold-version -R .note.gnu.property -R .ARM.exidx $< $@; \
 fi
 """)
 
diff --color -Naur grub-2.04-orig/grub-core/commands/i386/cmostest.c grub-2.04/grub-core/commands/i386/cmostest.c
--- grub-2.04-orig/grub-core/commands/i386/cmostest.c	2021-01-29 19:34:15.151012292 +0300
+++ grub-2.04/grub-core/commands/i386/cmostest.c	2021-01-29 19:27:31.276384000 +0300
@@ -27,7 +27,7 @@
 static grub_err_t
 parse_args (int argc, char *argv[], int *byte, int *bit)
 {
-  char *rest;
+  const char *rest;
 
   if (argc != 1)
     return grub_error (GRUB_ERR_BAD_ARGUMENT, "address required");
diff --color -Naur grub-2.04-orig/grub-core/commands/i386/pc/play.c grub-2.04/grub-core/commands/i386/pc/play.c
--- grub-2.04-orig/grub-core/commands/i386/pc/play.c	2021-01-29 19:34:15.151012292 +0300
+++ grub-2.04/grub-core/commands/i386/pc/play.c	2021-01-29 19:27:31.276384000 +0300
@@ -132,7 +132,7 @@
     }
   else
     {
-      char *end;
+      const char *end;
       unsigned tempo;
       struct note note;
       int i;
diff --color -Naur grub-2.04-orig/grub-core/commands/i386/pc/smbios.c grub-2.04/grub-core/commands/i386/pc/smbios.c
--- grub-2.04-orig/grub-core/commands/i386/pc/smbios.c	1970-01-01 03:00:00.000000000 +0300
+++ grub-2.04/grub-core/commands/i386/pc/smbios.c	2021-01-29 19:27:31.276384000 +0300
@@ -0,0 +1,52 @@
+/* smbios.c - get smbios tables. */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2019  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/acpi.h>
+#include <grub/smbios.h>
+#include <grub/misc.h>
+
+struct grub_smbios_eps *
+grub_machine_smbios_get_eps (void)
+{
+  grub_uint8_t *ptr;
+
+  grub_dprintf ("smbios", "Looking for SMBIOS EPS. Scanning BIOS\n");
+
+  for (ptr = (grub_uint8_t *) 0xf0000; ptr < (grub_uint8_t *) 0x100000; ptr += 16)
+    if (grub_memcmp (ptr, "_SM_", 4) == 0
+	&& grub_byte_checksum (ptr, sizeof (struct grub_smbios_eps)) == 0)
+      return (struct grub_smbios_eps *) ptr;
+
+  return 0;
+}
+
+struct grub_smbios_eps3 *
+grub_machine_smbios_get_eps3 (void)
+{
+  grub_uint8_t *ptr;
+
+  grub_dprintf ("smbios", "Looking for SMBIOS3 EPS. Scanning BIOS\n");
+
+  for (ptr = (grub_uint8_t *) 0xf0000; ptr < (grub_uint8_t *) 0x100000; ptr += 16)
+    if (grub_memcmp (ptr, "_SM3_", 5) == 0
+	&& grub_byte_checksum (ptr, sizeof (struct grub_smbios_eps3)) == 0)
+      return (struct grub_smbios_eps3 *) ptr;
+
+  return 0;
+}
diff --color -Naur grub-2.04-orig/grub-core/commands/i386/rdmsr.c grub-2.04/grub-core/commands/i386/rdmsr.c
--- grub-2.04-orig/grub-core/commands/i386/rdmsr.c	2021-01-29 19:34:15.151012292 +0300
+++ grub-2.04/grub-core/commands/i386/rdmsr.c	2021-01-29 19:27:31.276384000 +0300
@@ -44,7 +44,7 @@
 {
   grub_uint32_t manufacturer[3], max_cpuid, a, b, c, features, addr;
   grub_uint64_t value;
-  char *ptr;
+  const char *ptr;
   char buf[sizeof("1122334455667788")];
 
   /*
diff --color -Naur grub-2.04-orig/grub-core/commands/i386/wrmsr.c grub-2.04/grub-core/commands/i386/wrmsr.c
--- grub-2.04-orig/grub-core/commands/i386/wrmsr.c	2021-01-29 19:34:15.151012292 +0300
+++ grub-2.04/grub-core/commands/i386/wrmsr.c	2021-01-29 19:27:31.276384000 +0300
@@ -37,7 +37,7 @@
 {
   grub_uint32_t manufacturer[3], max_cpuid, a, b, c, features, addr;
   grub_uint64_t value;
-  char *ptr;
+  const char *ptr;
 
   /*
    * The CPUID instruction should be used to determine whether MSRs
diff --color -Naur grub-2.04-orig/grub-core/disk/ieee1275/ofdisk.c grub-2.04/grub-core/disk/ieee1275/ofdisk.c
--- grub-2.04-orig/grub-core/disk/ieee1275/ofdisk.c	2021-01-29 19:34:15.151012292 +0300
+++ grub-2.04/grub-core/disk/ieee1275/ofdisk.c	2021-01-29 19:27:31.280383000 +0300
@@ -297,7 +297,7 @@
       /* Power machines documentation specify 672 as maximum SAS disks in
          one system. Using a slightly larger value to be safe. */
       table_size = 768;
-      table = grub_malloc (table_size * sizeof (grub_uint64_t));
+      table = grub_calloc (table_size, sizeof (grub_uint64_t));
 
       if (!table)
         {
diff --color -Naur grub-2.04-orig/grub-core/efiemu/i386/pc/cfgtables.c grub-2.04/grub-core/efiemu/i386/pc/cfgtables.c
--- grub-2.04-orig/grub-core/efiemu/i386/pc/cfgtables.c	2021-01-29 19:34:15.151012292 +0300
+++ grub-2.04/grub-core/efiemu/i386/pc/cfgtables.c	2021-01-29 19:27:31.280383000 +0300
@@ -22,11 +22,11 @@
 #include <grub/misc.h>
 #include <grub/mm.h>
 #include <grub/acpi.h>
+#include <grub/smbios.h>
 
 grub_err_t
 grub_machine_efiemu_init_tables (void)
 {
-  grub_uint8_t *ptr;
   void *table;
   grub_err_t err;
   grub_efi_guid_t smbios = GRUB_EFI_SMBIOS_TABLE_GUID;
@@ -57,17 +57,10 @@
       if (err)
 	return err;
     }
-
-  for (ptr = (grub_uint8_t *) 0xf0000; ptr < (grub_uint8_t *) 0x100000;
-       ptr += 16)
-    if (grub_memcmp (ptr, "_SM_", 4) == 0
-	&& grub_byte_checksum (ptr, *(ptr + 5)) == 0)
-      break;
-
-  if (ptr < (grub_uint8_t *) 0x100000)
+  table = grub_smbios_get_eps ();
+  if (table)
     {
-      grub_dprintf ("efiemu", "Registering SMBIOS\n");
-      err = grub_efiemu_register_configuration_table (smbios, 0, 0, ptr);
+      err = grub_efiemu_register_configuration_table (smbios, 0, 0, table);
       if (err)
 	return err;
     }
diff --color -Naur grub-2.04-orig/grub-core/lib/i386/relocator16.S grub-2.04/grub-core/lib/i386/relocator16.S
--- grub-2.04-orig/grub-core/lib/i386/relocator16.S	2021-01-29 19:34:15.159012024 +0300
+++ grub-2.04/grub-core/lib/i386/relocator16.S	2021-01-29 19:27:31.296383000 +0300
@@ -38,15 +38,21 @@
 #ifdef __APPLE__
 	LOCAL(cs_base_bytes12_offset) = LOCAL (cs_base_bytes12) - LOCAL (base)
 	LOCAL(cs_base_byte3_offset) = LOCAL (cs_base_byte3) - LOCAL (base)
+	LOCAL(ds_base_bytes12_offset) = LOCAL (ds_base_bytes12) - LOCAL (base)
+	LOCAL(ds_base_byte3_offset) = LOCAL (ds_base_byte3) - LOCAL (base)
 	movl 	%esi, %eax
 	movw	%ax, (LOCAL(cs_base_bytes12_offset)) (RSI, 1)
+	movw	%ax, (LOCAL(ds_base_bytes12_offset)) (RSI, 1)
 	shrl	$16, %eax
 	movb	%al, (LOCAL (cs_base_byte3_offset)) (RSI, 1)
+	movb	%al, (LOCAL (ds_base_byte3_offset)) (RSI, 1)
 #else
 	movl 	%esi, %eax
 	movw	%ax, (LOCAL (cs_base_bytes12) - LOCAL (base)) (RSI, 1)
+	movw	%ax, (LOCAL (ds_base_bytes12) - LOCAL (base)) (RSI, 1)
 	shrl	$16, %eax
 	movb	%al, (LOCAL (cs_base_byte3) - LOCAL (base)) (RSI, 1)
+	movb	%al, (LOCAL (ds_base_byte3) - LOCAL (base)) (RSI, 1)
 #endif
 
 	RELOAD_GDT
@@ -88,15 +94,15 @@
 	LOCAL(segment_offset) = LOCAL (segment) - LOCAL (base)
 	LOCAL(idt_offset) = LOCAL(relocator16_idt) - LOCAL (base)
 	LOCAL(cont2_offset) = LOCAL (cont2) - LOCAL(base)
-	movw	%ax, LOCAL(segment_offset) (%esi, 1)
-	lidt LOCAL(idt_offset) (%esi, 1)
+	movw	%ax, (LOCAL(segment_offset))
+	lidt (LOCAL(idt_offset))
 	
 	/* jump to a 16 bit segment */
 	ljmp	$PSEUDO_REAL_CSEG, $(LOCAL(cont2_offset))
 #else
-	movw	%ax, (LOCAL (segment) - LOCAL (base)) (%esi, 1)
+	movw	%ax, (LOCAL (segment) - LOCAL (base))
 
-	lidt (EXT_C(grub_relocator16_idt) - LOCAL (base)) (%esi, 1)
+	lidt (EXT_C(grub_relocator16_idt) - LOCAL (base))
 	
 	/* jump to a 16 bit segment */
 	ljmp	$PSEUDO_REAL_CSEG, $(LOCAL (cont2) - LOCAL(base))
@@ -311,11 +317,17 @@
 	.byte	0x9E, 0, 0
 
 	/* -- 16 bit real mode DS --
-	 * base = 0x00000000, limit 0x0FFFF (1 B Granularity), present
+	 * base = filled by code, limit 0x0FFFF (1 B Granularity), present
 	 * type = 16 bit data read/write, DPL = 0
 	 */
-	.word	0xFFFF, 0
-	.byte	0, 0x92, 0, 0
+	.word	0xFFFF
+LOCAL(ds_base_bytes12):
+	.word	0
+LOCAL(ds_base_byte3):
+	.byte	0
+
+	.byte	0x92, 0, 0
+
 LOCAL(gdt_end):
 
 #ifdef __APPLE__
diff --color -Naur grub-2.04-orig/grub-core/lib/i386/relocator.c grub-2.04/grub-core/lib/i386/relocator.c
--- grub-2.04-orig/grub-core/lib/i386/relocator.c	2021-01-29 19:34:15.159012024 +0300
+++ grub-2.04/grub-core/lib/i386/relocator.c	2021-01-29 19:27:31.296383000 +0300
@@ -83,11 +83,10 @@
   /* Specific memory range due to Global Descriptor Table for use by payload
      that we will store in returned chunk.  The address range and preference
      are based on "THE LINUX/x86 BOOT PROTOCOL" specification.  */
-  err = grub_relocator_alloc_chunk_align (rel, &ch, 0x1000,
-					  0x9a000 - RELOCATOR_SIZEOF (32),
-					  RELOCATOR_SIZEOF (32), 16,
-					  GRUB_RELOCATOR_PREFERENCE_LOW,
-					  avoid_efi_bootservices);
+  err = grub_relocator_alloc_chunk_align_safe (rel, &ch, 0x1000, 0x9a000,
+					       RELOCATOR_SIZEOF (32), 16,
+					       GRUB_RELOCATOR_PREFERENCE_LOW,
+					       avoid_efi_bootservices);
   if (err)
     return err;
 
@@ -125,13 +124,10 @@
   grub_relocator_chunk_t ch;
 
   /* Put it higher than the byte it checks for A20 check.  */
-  err = grub_relocator_alloc_chunk_align (rel, &ch, 0x8010,
-					  0xa0000 - RELOCATOR_SIZEOF (16)
-					  - GRUB_RELOCATOR16_STACK_SIZE,
-					  RELOCATOR_SIZEOF (16)
-					  + GRUB_RELOCATOR16_STACK_SIZE, 16,
-					  GRUB_RELOCATOR_PREFERENCE_NONE,
-					  0);
+  err = grub_relocator_alloc_chunk_align_safe (rel, &ch, 0x8010, 0xa0000,
+					       RELOCATOR_SIZEOF (16) +
+					       GRUB_RELOCATOR16_STACK_SIZE, 16,
+					       GRUB_RELOCATOR_PREFERENCE_NONE, 0);
   if (err)
     return err;
 
@@ -183,11 +179,9 @@
   void *relst;
   grub_relocator_chunk_t ch;
 
-  err = grub_relocator_alloc_chunk_align (rel, &ch, min_addr,
-					  max_addr - RELOCATOR_SIZEOF (64),
-					  RELOCATOR_SIZEOF (64), 16,
-					  GRUB_RELOCATOR_PREFERENCE_NONE,
-					  0);
+  err = grub_relocator_alloc_chunk_align_safe (rel, &ch, min_addr, max_addr,
+					       RELOCATOR_SIZEOF (64), 16,
+					       GRUB_RELOCATOR_PREFERENCE_NONE, 0);
   if (err)
     return err;
 
diff --color -Naur grub-2.04-orig/grub-core/lib/i386/relocator_common.S grub-2.04/grub-core/lib/i386/relocator_common.S
--- grub-2.04-orig/grub-core/lib/i386/relocator_common.S	2021-01-29 19:34:15.159012024 +0300
+++ grub-2.04/grub-core/lib/i386/relocator_common.S	2021-01-29 19:27:31.296383000 +0300
@@ -29,8 +29,6 @@
 #endif
 
 	.macro DISABLE_PAGING
-#ifdef GRUB_MACHINE_IEEE1275
-#endif
 
 	movl	%cr0, %eax
 	andl	$(~GRUB_MEMORY_CPU_CR0_PAGING_ON), %eax
diff --color -Naur grub-2.04-orig/grub-core/lib/x86_64/efi/relocator.c grub-2.04/grub-core/lib/x86_64/efi/relocator.c
--- grub-2.04-orig/grub-core/lib/x86_64/efi/relocator.c	2021-01-29 19:34:15.167011755 +0300
+++ grub-2.04/grub-core/lib/x86_64/efi/relocator.c	2021-01-29 19:27:31.316383000 +0300
@@ -50,10 +50,9 @@
    * 64-bit relocator code may live above 4 GiB quite well.
    * However, I do not want ask for problems. Just in case.
    */
-  err = grub_relocator_alloc_chunk_align (rel, &ch, 0,
-					  0x100000000 - RELOCATOR_SIZEOF (64_efi),
-					  RELOCATOR_SIZEOF (64_efi), 16,
-					  GRUB_RELOCATOR_PREFERENCE_NONE, 1);
+  err = grub_relocator_alloc_chunk_align_safe (rel, &ch, 0, 0x100000000,
+					       RELOCATOR_SIZEOF (64_efi), 16,
+					       GRUB_RELOCATOR_PREFERENCE_NONE, 1);
   if (err)
     return err;
 
diff --color -Naur grub-2.04-orig/grub-core/loader/i386/pc/linux.c grub-2.04/grub-core/loader/i386/pc/linux.c
--- grub-2.04-orig/grub-core/loader/i386/pc/linux.c	2021-01-29 19:34:15.167011755 +0300
+++ grub-2.04/grub-core/loader/i386/pc/linux.c	2021-01-29 19:27:31.324382000 +0300
@@ -35,6 +35,7 @@
 #include <grub/i386/floppy.h>
 #include <grub/lib/cmdline.h>
 #include <grub/linux.h>
+#include <grub/safemath.h>
 
 GRUB_MOD_LICENSE ("GPLv3+");
 
@@ -218,8 +219,12 @@
     setup_sects = GRUB_LINUX_DEFAULT_SETUP_SECTS;
 
   real_size = setup_sects << GRUB_DISK_SECTOR_BITS;
-  grub_linux16_prot_size = grub_file_size (file)
-    - real_size - GRUB_DISK_SECTOR_SIZE;
+  if (grub_sub (grub_file_size (file), real_size, &grub_linux16_prot_size) ||
+      grub_sub (grub_linux16_prot_size, GRUB_DISK_SECTOR_SIZE, &grub_linux16_prot_size))
+    {
+      grub_error (GRUB_ERR_OUT_OF_RANGE, N_("overflow is detected"));
+      goto fail;
+    }
 
   if (! grub_linux_is_bzimage
       && GRUB_LINUX_ZIMAGE_ADDR + grub_linux16_prot_size
@@ -259,7 +264,7 @@
       }
     else if (grub_memcmp (argv[i], "mem=", 4) == 0)
       {
-	char *val = argv[i] + 4;
+	const char *val = argv[i] + 4;
 
 	linux_mem_size = grub_strtoul (val, &val, 0);
 
@@ -448,10 +453,8 @@
 
   {
     grub_relocator_chunk_t ch;
-    err = grub_relocator_alloc_chunk_align (relocator, &ch,
-					    addr_min, addr_max - size,
-					    size, 0x1000,
-					    GRUB_RELOCATOR_PREFERENCE_HIGH, 0);
+    err = grub_relocator_alloc_chunk_align_safe (relocator, &ch, addr_min, addr_max, size,
+						 0x1000, GRUB_RELOCATOR_PREFERENCE_HIGH, 0);
     if (err)
       return err;
     initrd_chunk = get_virtual_current_address (ch);
